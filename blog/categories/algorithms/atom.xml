<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithms | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-12T00:16:57-07:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Array and Strings]]></title>
    <link href="http://distkeys.com/blog/2013/12/30/array-and-strings/"/>
    <updated>2013-12-30T01:26:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/12/30/array-and-strings</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#array-problems">Array Problems</a>    <ul>
      <li><a href="#sum-of-2-numbers">Sum of 2 numbers</a></li>
      <li><a href="#sum-of-2-numbers-greater-or-equal-to-given-sum">Sum of 2 numbers greater or equal to given sum*</a></li>
      <li><a href="#sum-of-3-numbers">Sum of 3 numbers*</a></li>
      <li><a href="#find-repeatingduplicate-numbers">Find repeating/duplicate numbers*</a></li>
      <li><a href="#find-the-number-when-size-of-array-is-unknown">Find the number when size of array is unknown*</a></li>
      <li><a href="#merge-two-sorted-array">Merge two sorted array</a></li>
      <li><a href="#merge-2-non-sorted-array-and-remove-duplicates">Merge 2 non sorted array and remove duplicates</a></li>
    </ul>
  </li>
  <li><a href="#define-arr1size-5">define ARR1SIZE 5</a>    <ul>
      <li><a href="#sort-array-based-on-count">Sort array based on count</a></li>
    </ul>
  </li>
  <li><a href="#define-arraysize-6">define ARRAYSIZE 6</a>    <ul>
      <li><a href="#find-odd-number-of-occurrence">Find odd number of occurrence</a></li>
      <li><a href="#find-2-numbers-with-odd-occurence">Find 2 numbers with odd occurence</a></li>
      <li><a href="#searching-an-element-in-a-rotated-sorted-array">Searching an Element in a Rotated Sorted Array</a></li>
      <li><a href="#largest-sum-contiguous-subarray">Largest Sum Contiguous Subarray</a></li>
      <li><a href="#string-problems">String Problems</a>        <ul>
          <li><a href="#reverse-a-string-without-extra-space">Reverse a string without extra space</a></li>
          <li><a href="#duplicates-and-count">Duplicates and Count*</a></li>
          <li><a href="#remove-duplicate-spaces">Remove duplicate spaces*</a></li>
          <li><a href="#remove-spaces">Remove spaces*</a></li>
          <li><a href="#remove-all-consequtive-duplicate-elements">Remove all consequtive duplicate elements*</a></li>
          <li><a href="#rotate-a-string">Rotate a string*</a></li>
          <li><a href="#permutation-of-a-string">Permutation of a string</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="array-problems">Array Problems</h3>

<h4 id="sum-of-2-numbers">Sum of 2 numbers</h4>

<p>We are given a sorted array A of length n and a value k. We want to find out if there are indices i, j such that A[i] + A[j] == k. <br /><br />
Give a Θ(n) way of solving this problem. Prove its running time and correctness. <br />Your algorithm should also output one pair of indices i, j such that A[i] + A[j] == k (if at least one pair exists; if multiple exist, you only need to output one of them). </p>

<p><strong>Other variant of the same problem</strong> <br />
When array is not sorted<br />
We need to find pair of numbers in an array whose sum is equal to a given value.<br />
Input [6,4,5,7,9,1,2]<br />
Sum = 10 <br />
Then the pairs are  [6,4] , [9,1]
<!-- more --></p>

<p><br />
<strong>Solution</strong></p>

<p>There are three solutions<br /></p>

<p><strong>Sorted array</strong> <br />
1. When array is sorted, take two index variable. Indx1 point to fisrt index and Indx2 points to the last index<br />
2. If Indx1 + Indx2 &lt; sum then increment the Indx1<br />
3. Else if Indx1 + Indx2 &gt; sum then decrement Indx 2<br />
4. If Indx 1 &gt; Indx 2 then halt -&gt; No pairs found<br /></p>

<p>If pair found then keep doing the same to find next pair.
{% coderay lang:c linenos:true Sorted array http://ideone.com/fmKgvW Run Code %}
#include <stdio.h /></p>

<p>void printPairs(int arr[], int arr_size, int sum)
{
    int front = 0;
    int back = arr_size - 1;</p>

<pre><code>while (front &lt; back) {
    if (arr[front] + arr[back] &lt; sum) {
        front++;
    } else if (arr[front] + arr[back] &gt; sum) {
        back--;
    } else {
        printf ("Pair with given sum %d is (%d, %d) \n",
                sum, arr[front], arr[back]);
        back--;
    }
} }
</code></pre>

<p>/* Driver program to test above function */
int main()
{
    int A[] = {4, 5, 6, 10, 12, 12};
    int sum = 16;
    int arr_size = 6;</p>

<pre><code>printPairs(A, arr_size, sum);

return 0; } {% endcoderay %}
</code></pre>

<p><strong>Hashing/Binary Map</strong><br />
Another solution works for both <em>sorted</em> and <em>unsorted</em> array. 
In this approach we not actually using the hash function fundamental idea is to maintain the occurrence of number i.e. Binary Map</p>

<blockquote>
  <p>The caveat is that we need extra memory.</p>
</blockquote>

<ol>
  <li>Get the number from input array<br /></li>
  <li>Num2 = Sum - arr[i]<br /></li>
  <li>If we have encountered Num2 already in input array then we found a pair i.e.<br /> if(binMap[Num2] == 1)<br /></li>
  <li>Else record input element in Binary map i.e. binMap[arr[i]] = 1;<br /></li>
</ol>

<p>{% coderay lang:c linenos:true Binary Map http://ideone.com/S0CNlO Run Code %}
#include <stdio.h>
#define MAX 100000</stdio.h></p>

<p>void printPairs(int arr[], int arr_size, int sum)
{
    int i = 0;
    int temp = 0;
    int binMap[MAX] = {0}; /<em>initialize hash map as 0</em>/</p>

<pre><code>for(i = 0; i &lt; arr_size; i++)
{
    temp = sum - arr[i];
    if(temp &gt;= 0 &amp;&amp; binMap[temp] == 1)
    {
        printf("Pair with given sum %d is (%d, %d) \n",
                sum, arr[i], temp);
    }
    binMap[arr[i]] = 1;
} }
</code></pre>

<p>/* Driver program to test above function */
int main()
{
    int A[] = {12, 4, 45, 6, 10, 12};
    int sum = 16;
    int arr_size = 6;</p>

<pre><code>printPairs(A, arr_size, sum);

return 0; } {% endcoderay %}
</code></pre>

<p><strong>Bit Vector</strong><br /></p>

<p>This approach is similar to Binary map except using array for extra space we use bit vector to save some of extra space.</p>

<blockquote>
  <p>This program works for max for 31 as bit map is <em>int</em> which is 32 bits. For numbers more than 31 more memory could be allocated.</p>
</blockquote>

<p>{% coderay lang:c linenos:true Bit Vector http://ideone.com/iFDimZ Run Code %}
#include <stdio.h /></p>

<p>void printPairs(int arr[], int arr_size, int sum)
{
    int i = 0;
    int temp = 0;
    int bitmap = 0; // all bits are 0
    int bitmask = 0;</p>

<pre><code>for(i = 0; i &lt; arr_size; i++)
{
    temp = sum - arr[i];

    bitmask = 0;
    bitmask = 1 &lt;&lt; temp;

    if(temp &gt;= 0 &amp;&amp; (bitmap &amp; bitmask))
    {
        printf("Pair with given sum %d is (%d, %d) \n",
               sum, arr[i], temp);
    }
    bitmap |= 1 &lt;&lt; arr[i];
} }
</code></pre>

<p>/* Driver program to test above function */
int main()
{
    int A[] = {12, 4, 13, 6, 10, 3};
    int sum = 16;
    int arr_size = 6;</p>

<pre><code>printPairs(A, arr_size, sum);

return 0; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="sum-of-2-numbers-greater-or-equal-to-given-sum">Sum of 2 numbers greater or equal to given sum*</h4>

<p>We are given a sorted array A of length n and a value k. We want to find out if there are indices i, j such that A[i] + A[j] &gt;= k. <br /></p>

<p>Your algorithm should also output all the pairs of indices i, j such that A[i] + A[j] &gt;= k </p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="sum-of-3-numbers">Sum of 3 numbers*</h4>
<p>We need to find three numbers in an array whose sum is equal to a given value.</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="find-repeatingduplicate-numbers">Find repeating/duplicate numbers*</h4>
<p>Find all the numbers repeating in a array</p>

<p>Input [2,1, 3, 2, 3, 1, 4]</p>

<p>Output  [2,1,3] </p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="find-the-number-when-size-of-array-is-unknown">Find the number when size of array is unknown*</h4>

<p>Given an array of integers find the given element is present when size of array is not given</p>

<p>Input array
2,1, 3, 2, 3, 1, 4</p>

<p>Element to find 3. Find solution in less than O(n) time.</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="merge-two-sorted-array">Merge two sorted array</h4>
<p>Input array1 [1, 3, 6, 7] <br />
Input array2 [1, 2, 4]</p>

<p>Output [1, 1, 2, 3, 4, 6, 7]</p>

<p>{% coderay lang:c linenos:true Merge Sorted Arrays http://ideone.com/WaTPEt Run Code %}
#include <stdio.h /></p>

<p>int lSize = 4;
int rSize = 3;
int L[4] = {1, 3, 6, 7};
int R[4] = {1, 2, 4};
int finalArray[7];</p>

<p>void merge()
{
    int lIndx = 0;
    int rIndx = 0;
    int i = 0;</p>

<pre><code>for (i = 0; i &lt; (lSize + rSize); i++) {
    if (L[lIndx] &lt;= R[rIndx]) {
        finalArray[i] = L[lIndx++];
        if (lIndx == lSize) {
            break;
        }
    } else {
        finalArray[i] = R[rIndx++];
        if (rIndx == rSize) {
            break;
        }
    }
}

i++;
if (lIndx != lSize) {
    while(1) {
        finalArray[i++] = L[lIndx++];

        if (lIndx == lSize) {
            return;
        }
    }
}
if (rIndx != rSize) {
    while(1) {
        finalArray[i++] = R[rIndx++];

        if (rIndx == rSize) {
            return;
        }
    }
} }
</code></pre>

<p>void display()
{
    int i = 0;</p>

<pre><code>printf("\n\nArray1: ");
for (i = 0; i &lt; lSize; i++) {
    printf("%d ", L[i]);
}

printf("\nArray2: ");
for (i = 0; i &lt; rSize; i++) {
    printf("%d ", R[i]);
}

printf("\nMerge array: ");
for (i = 0; i &lt; lSize+rSize; i++) {
    printf("%d ", finalArray[i]);
} }
</code></pre>

<p>int main()
{
    // Test 1
    merge();
    display();</p>

<pre><code>// Test 2
R[0] = 1;
R[1] = 3;
R[2] = 6;
R[3] = 7;
L[0] = 1;
L[1] = 2;
L[2] = 4;
lSize = 3;
rSize = 4;
merge();
display();

// test 3
L[0] = 1;
R[0] = 1;
lSize = 1;
rSize = 1;
merge();
display();

return 0; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="merge-2-non-sorted-array-and-remove-duplicates">Merge 2 non sorted array and remove duplicates</h4>

<p>Input array1 [6, 3, 6, 1, 7] <br />
Input array2 [5, 1, 2, 4, 6]</p>

<p>Output could be in sorted order or non-sorted order based on algorithm you choose to solve it.</p>

<p>Output [1, 2, 3, 4, 5, 6, 7]  OR<br />
 Output [6, 3, 1, 7, 5, 2, 4] OR <br />
 Output [5, 1, 2, 4, 6, 3, 7] OR <br />
 Output [6, 5, 3, 1, 2, 4, 7] etc…</p>

<p>{% coderay lang:c linenos:true Merge Unsorted Arrays http://ideone.com/IScZ7r Run Code %}
#include <stdio.h /></p>

<h1 id="define-arr1size-5">define ARR1SIZE 5</h1>
<p>#define ARR2SIZE 5</p>

<p>int main()
{
    int arr1[] = {6, 3, 6, 1, 7};
    int arr2[] = {5, 1, 2, 4, 6};
    int arr3[ARR1SIZE + ARR2SIZE];</p>

<pre><code>// Using bit map, All bits are 0
int bitMap = 0;
int bitMask = 0;
int i = 0;
int k = 0;

for (i = 0; i &lt; ARR1SIZE; i++) {
    // Check if value already exist
    bitMask = 0;
    bitMask = 1 &lt;&lt; arr1[i];

    if (bitMap &amp; bitMask) {
        continue;
    }
    arr3[k++] = arr1[i];

    // Mark bitMap that value exist
    bitMap |= 1 &lt;&lt; arr1[i];
}

for (i = 0; i &lt; ARR2SIZE; i++) {
    // Check if value already exist
    bitMask = 0;
    bitMask = 1 &lt;&lt; arr2[i];

    if (bitMap &amp; bitMask) {
        continue;
    }
    arr3[k++] = arr2[i];

    // Mark bitMap that value exist
    bitMap |= 1 &lt;&lt; arr2[i];
}

printf("Merged Array\n");
for (i = 0; i &lt; k; i++) {
    printf("%d ", arr3[i]);
}

return 0; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="sort-array-based-on-count">Sort array based on count</h4>

<p>Given number in array [2, 1, 3, 2, 1, 4] sort array based on count of numbers.</p>

<p>Sort them as [1, 1, 2, 2, 3, 4]</p>

<p>{% coderay lang:c linenos:true Counting Sort http://ideone.com/0BumWs Run Code %}
#include <stdio.h /></p>

<h1 id="define-arraysize-6">define ARRAYSIZE 6</h1>
<p>#define MAX 4</p>

<p>int main()
{
    int arr[] = {2, 1, 3, 2, 1, 4};
    int final[ARRAYSIZE];</p>

<pre><code>// Given we know max element in array
// This technique is based on counting sort
int count[MAX + 1] = {0};
int i = 0;
int j = 0;

for (i = 0; i &lt; ARRAYSIZE; i++) {
    count[arr[i]]++;
}

for (i = 0; i &lt; MAX + 1; i++) {
    if (count[i] != 0) {
        while (count[i] != 0) {
            final[j++] = i;
            count[i]--;
        }
    }
}

printf("Sorted Array\n");
for (i = 0; i &lt; ARRAYSIZE; i++) {
    printf("%d ", final[i]);
}

return 0; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="find-odd-number-of-occurrence">Find odd number of occurrence</h4>

<p>Given an array of positive integers. All numbers occur even number of times except one number which occurs odd number of times. Find the number in O(n) time &amp; constant space.</p>

<p>{% coderay lang:c linenos:true Odd occurence  %}
#include <stdio.h /></p>

<p>int getOddOccurrence(int ar[], int ar_size)
{
     int i;
     int res = 0; 
     for (i=0; i &lt; ar_size; i++)   <br />
        res = res ^ ar[i];</p>

<pre><code> return res; }
</code></pre>

<p>/* Diver function to test above function */
int main()
{
     int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};
     int n = sizeof(ar)/sizeof(ar[0]);
     printf(“%d”, getOddOccurrence(ar, n));
     return 0;
}
{% endcoderay %}</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /><br /></p>

<h4 id="find-2-numbers-with-odd-occurence">Find 2 numbers with odd occurence</h4>

<p>Given an unsorted array that contains even number of occurrences for all numbers except two numbers. Find the two numbers which have odd occurrences in O(n) time complexity and O(1) extra space.</p>

<p>Input: [12, 23, 34, 12, 12, 23, 12, 45]<br />
Output: 34 and 45</p>

<p>Input: [4, 4, 100, 5000, 4, 4, 4, 4, 100, 100]<br />
Output: 100 and 5000</p>

<p>Input: [10, 20]<br />
Output: 10 and 20</p>

<p><a href="http://www.geeksforgeeks.org/find-the-two-numbers-with-odd-occurences-in-an-unsorted-array/" target="_blank">Solution Explanation</a></p>

<p>{% coderay lang:c linenos:true 2 Odd Num  %}
// Program to find the two odd occurring elements
#include<stdio.h /></p>

<p>/* Prints two numbers that occur odd number of times. The
   function assumes that the array size is at least 2 and
   there are exactly two numbers occurring odd number of times. <em>/
void printTwoOdd(int arr[], int size)
{
  int xor2 = arr[0]; /</em> Will hold XOR of two odd occurring elements <em>/
  int set_bit_no;  /</em> Will have only single set bit of xor2 */
  int i;
  int n = size - 2;
  int x = 0, y = 0;</p>

<p>/* Get the xor of all elements in arr[]. The xor will basically
     be xor of two odd occurring elements */
  for(i = 1; i &lt; size; i++)
    xor2 = xor2 ^ arr[i];</p>

<p>/* Get one set bit in the xor2. We get rightmost set bit
     in the following line as it is easy to get */
  set_bit_no = xor2 &amp; ~(xor2-1);</p>

<p>/* Now divide elements in two sets: 
    1) The elements having the corresponding bit as 1. 
    2) The elements having the corresponding bit as 0.  <em>/
  for(i = 0; i &lt; size; i++)
  {
     /</em> XOR of first set is finally going to hold one odd 
       occurring number x */
    if(arr[i] &amp; set_bit_no)
      x = x ^ arr[i];</p>

<pre><code> /* XOR of second set is finally going to hold the other 
   odd occurring number y */
else
  y = y ^ arr[i];    }
</code></pre>

<p>printf(“\n The two ODD elements are %d &amp; %d “, x, y);
}</p>

<p>/* Driver program to test above function */
int main()
{
  int arr[] = {4, 2, 4, 5, 2, 3, 3, 1};
  int arr_size = sizeof(arr)/sizeof(arr[0]);
  printTwoOdd(arr, arr_size);</p>

<p>return 0;
}
{% endcoderay %}</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="searching-an-element-in-a-rotated-sorted-array">Searching an Element in a Rotated Sorted Array</h4>

<p>This <a href="http://leetcode.com/2010/04/searching-element-in-rotated-array.html" target="_blank">article</a> explains the reasoning for searching an element in a rotated sorted array.</p>

<p>It even explains how to find the minimum number i.e. from where rotation started.</p>

<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h4 id="largest-sum-contiguous-subarray">Largest Sum Contiguous Subarray</h4>
<p>Write an efficient C program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.</p>

<p>Array [-2, -3, 4, -1, -2, 1, 5, -3] <br />
Sum 7</p>

<p>{% coderay lang:c linenos:true Largest Sum http://ideone.com/cVpfgF Run Code %}
#include <stdio.h /></p>

<p>int main()
{
    int arr[] = {-2, -3, 4, -1, -2, 1, 5, -3};</p>

<pre><code>int best = -1110;
int sum = 0;
int indx = 0;
int i = 0;
int x = 0; // start of max sub array
int y = 0; // end of max sub array
int n = 8; // size of array

for (i = 0; i &lt; n; i++) {
    if (sum &lt;= 0) {
        sum = arr[i];
        indx = i;
    } else {
        sum += arr[i];
    }

    if (best &lt; sum) {
        best = sum;
        x = indx;
        y = i;
    }
}

printf("Max sum %d, start index %d, end index %d\n", best, x, y);

return 0; } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt;&lt;br&gt;
</code></pre>

<h3 id="string-problems">String Problems</h3>

<h4 id="reverse-a-string-without-extra-space">Reverse a string without extra space</h4>

<p>String could be reversed without using extra space using bitwise operator <a href="http://distkeys.com/blog/2013/10/08/world-of-bits-and-bytes/#bitwise-operators" target="_blank">XOR</a></p>

<p>{% coderay lang:c linenos:true String Reverse http://ideone.com/vfTxcr Run Code %}
#include <stdio.h>
#include <string.h /></stdio.h></p>

<p>int main(void) {
    int i = 0;
    char str[] = “testString”;
    int len = strlen(str);</p>

<pre><code>for(i = 0; i &lt; len/2; i++){
	str[len - i - 1] ^= str[i];
	str[i] ^= str[len - i - 1];
	str[len - i - 1] ^= str[i];
}

printf("Reverse String %s \n", str);
 
return 0; }
</code></pre>

<p>{% endcoderay %}
<br /></p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="duplicates-and-count">Duplicates and Count*</h4>

<p>Print all duplicate characters and their count</p>

<p>Input string<br />
Foo Bar</p>

<p>Output<br />
a1B1F1o2r1</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="remove-duplicate-spaces">Remove duplicate spaces*</h4>
<p>Remove all duplicate spaces from the string</p>

<p>Input string<br />
Hi^^^There!!!^^Wassup<br />
 ^ - Represents  space</p>

<p>Output<br />
Hi^There!!!^Wassup</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="remove-spaces">Remove spaces*</h4>
<p>Remove all the spaces from a string</p>

<p>Input string<br />
Hi there!!! Wassup</p>

<p>Output<br />
Hithere!!!Wassup</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="remove-all-consequtive-duplicate-elements">Remove all consequtive duplicate elements*</h4>
<p>Remove all consequtive duplicate elements from the string</p>

<p>Input string<br />
aabbccddd</p>

<p>Output <br />
abcd</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="rotate-a-string">Rotate a string*</h4>
<p>Rotate a string for a ‘n’ times</p>

<p>Input string<br />
1234567 <br />
Rotate 2 times</p>

<p>Output <br />
3456712</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="permutation-of-a-string">Permutation of a string</h4>

<p><a href="http://distkeys.com/blog/2013/11/18/recursion/#string-permutation-non-repeating" target="_blank">Permutation</a></p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<p><br /><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Algorithms]]></title>
    <link href="http://distkeys.com/blog/2013/12/14/graph-algorithms/"/>
    <updated>2013-12-14T13:03:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/12/14/graph-algorithms</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#graph-problems">Graph problems</a>    <ul>
      <li><a href="#find-neighbour-in-array">Find neighbour in array</a></li>
      <li><a href="#find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</a></li>
    </ul>
  </li>
  <li><a href="#define-xindex-3">define xIndex 3</a></li>
</ul>

<h3 id="graph-problems">Graph problems</h3>

<h4 id="find-neighbour-in-array">Find neighbour in array</h4>

<p>Find all the neighbours of a given element in array<br /></p>

<p>Neighbours can be defined as<br /></p>

<ol>
  <li>Neighbours are only vertical and horizontal elements next to given element<br /></li>
  <li>Neighbours are only vertical, horizontal and diagonal elements next to given element<br /></li>
  <li>Neighbours are all vertical, horizontal and diagonal elements next to given element<br /></li>
</ol>

<!-- more -->
<p>{% coderay lang:c linenos:true Neighbour1 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: neighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8
 * Neighbour for 1 (0,0) = 4, 2
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void neighbour(int sx, int sy)
{
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf(“\n[%d][%d]: %d “, sx, sy - 1, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
            printf("\n[%d][%d]: %d ", sx - 1, sy, array[sx - 1][sy]);
}

if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
            printf("\n[%d][%d]: %d ", sx, sy + 1, array[sx][sy + 1]);
}

if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
            printf("\n[%d][%d]: %d ", sx + 1, sy,array[sx + 1][sy]);
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour2 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: diagnolNeighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy and
 * diagonal neighbours too.
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8, 1, 3, 7, 9
 * Neighbour for 1 (0,0) = 4, 2, 5
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void diagnolNeighbour(int sx, int sy) {
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf(“%d “, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
            printf("%d ", array[sx - 1][sy]);
 
            //Diagnols
            if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf("%d ", array[sx - 1][sy - 1]);
            }
            if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
                printf("%d ", array[sx - 1][sy + 1]);
            }
}
 
if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
            printf("%d ", array[sx][sy + 1]);
}
 
if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
            printf("%d ", array[sx + 1][sy]);
 
            //Diagnols
            if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf("%d ", array[sx + 1][sy - 1]);
            }
            if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
                printf("%d ", array[sx + 1][sy + 1]);
            }
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour3 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**
 * Function: allNeighbour(int sx, int sy)
 * This function returns all the neighbour of sx, sy and
 * all diagonal neighbours.
 * For e.g.
 * 1   2   3   4
 * 5   6   7   8
 * 9   10  11  12
 * 13  14  15  16
 *
 * Neighbour for 5  (1,0) = 1, 9, 13, 6, 7, 8, 10, 15
 * Neighbour for 11 (2,2) = 3, 7, 15, 9, 10, 12, 1, 6, 16
 * **</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void allNeighbour(int sx, int sy)
{
    int done = 0;
    int tempX = sx;
    int tempY = sy;
    int i = 0;
    int j = 0;</p>

<pre><code>// Get all the elements in row
for (i = 0; i &lt;= row; i++) {
            if (array[i][sy] == array[sx][sy]) {
                continue;
            }
            printf("%d ", array[i][sy]);
}
 
// Get all the elements in col
for (j = 0; j &lt;= col; j++) {
            if (array[sx][j] == array[sx][sy]) {
                continue;
            }
            printf("%d ", array[sx][j]);
}
 
// Diagnols
while (1) {
    tempX--; tempY--;
            if (tempX &gt;= startRow  &amp;&amp; tempY &gt;= startCol) {
                printf("%d ", array[tempX][tempY]);
            } else {
                done = 1;
            }
 
            sx++,sy++;
            if (sx &lt;= row &amp;&amp; sy &lt;= col) {
                printf("%d ", array[sx][sy]);
            } else if (done) {
                break;
            }
} } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt; &lt;br&gt;&lt;br&gt;
</code></pre>

<h4 id="find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</h4>

<p>Given array as
<br /></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[\begin{array}{cc} 1 & 6 & 8\\ 4 & 7 & 9\\ 5 & 2 & 3
\end{array}\right]
 %]]&gt;</script>

<p>Find all the paths from 1 to 3.
The possible ascending path are</p>

<p><code class="numberCircle">1</code> -&gt;6-&gt;8-&gt;9-&gt; <code class="numberCircle">3</code><br /></p>

<p><code class="numberCircle">1</code> -&gt;4-&gt;7-&gt;9-&gt;<code class="numberCircle">3</code></p>

<p><br />
<code class="numberCircle">1</code> -&gt;6-&gt;7-&gt;2-&gt;<code class="numberCircle">3</code> is not the right solution as 7 &gt; 2</p>

<p>{% coderay lang:c linenos:true Graph Traversal  http://ideone.com/0oLlT1 Run code %}
#include <stdio.h>
#include <stdlib.h /></stdio.h></p>

<h1 id="define-xindex-3">define xIndex 3</h1>
<p>#define yIndex 3
#define TRUE 1
#define FALSE 0</p>

<p>int startIndX = 0;
int startIndY = 0;
int endIndX = 2;
int endIndY = 2;</p>

<p>// Structure to construct final path
typedef struct node {
        int x;
        int y;
        int parentVal;
} parent;</p>

<p>typedef struct queue {
    int x;
    int y;
    struct queue *next;
} qnode;</p>

<p>qnode *head;
qnode *tail;</p>

<p>// Neighbour index coordinates
int neighbourIndex[4][2];
int array[xIndex][yIndex];
int visited[xIndex][yIndex];
int row = xIndex - 1;
int col = yIndex - 1;
int startRow = 0;
int startCol = 0;</p>

<p>parent* parentArr[xIndex][yIndex];</p>

<p>// Function declarations
void neighbour(int sx, int sy);
int isVisited(int x, int y);
void markVisited(int x, int y);
void markUnvisited(int x, int y);
void markParent(int childX, int childY, int parentX, int parentY);
void findPath(int startX, int startY, int endX, int endY);
void enqueue(int x, int y);
qnode* dequeue();
int isQueueEmpty();
void printPath(int x, int y);
void freeQueue();
void test1();</p>

<p>void neighbour(int sx, int sy)
{
    int i = 0;
    int j = 0;</p>

<pre><code>for (i = 0; i &lt; 4; i++) {
    for (j = 0; j &lt; 2; j++) {
        neighbourIndex[i][j] = -1;
    }
}

i = 0; j = 0;

if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
    neighbourIndex[i][0] = sx;
    neighbourIndex[i][1] = sy - 1;
    i++;
}

if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
    neighbourIndex[i][0] = sx - 1;
    neighbourIndex[i][1] = sy;
    i++;
}

if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
    neighbourIndex[i][0] = sx;
    neighbourIndex[i][1] = sy + 1;
    i++;
}

if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
    neighbourIndex[i][0] = sx + 1;
    neighbourIndex[i][1] = sy;
    i++;
} }
</code></pre>

<p>int isVisited(int x, int y)
{
    return visited[x][y];
}</p>

<p>void markVisited(int x, int y)
{
    visited[x][y] = 1;
}</p>

<p>void markUnvisited(int x, int y)
{
    visited[x][y] = 0;
}</p>

<p>void markParent(int childX, int childY, int parentX, int parentY)
{
    parent* temp = (parent *)malloc(sizeof(parent));</p>

<pre><code>if (temp == NULL) {
    // Put ASSERT
}

temp-&gt;x = parentX;
temp-&gt;y = parentY;
temp-&gt;parentVal = array[parentX][parentY];

parentArr[childX][childY] = temp; }
</code></pre>

<p>void enqueue(int x, int y)
{
    qnode *temp = (qnode *)malloc(sizeof(qnode));
    if (temp == NULL) {
    // Put ASSERT
    }</p>

<pre><code>temp-&gt;x = x;
temp-&gt;y = y;
temp-&gt;next = NULL;

tail-&gt;next = temp;

tail = temp; }
</code></pre>

<p>qnode* dequeue()
{
    qnode *temp;</p>

<pre><code>if (!isQueueEmpty()) {
    temp = head-&gt;next;

    if (temp == tail) {
        tail = head;
    }
    head-&gt;next = temp-&gt;next;
    return temp;
}

return head-&gt;next; }
</code></pre>

<p>int isQueueEmpty()
{
    if (head-&gt;next == NULL) {
        return TRUE;
    }</p>

<pre><code>return FALSE; }
</code></pre>

<p>void freeQueue()
{
    qnode* temp;</p>

<pre><code>while (head-&gt;next != NULL) {
    temp = head-&gt;next;
    head-&gt;next = head-&gt;next-&gt;next;

    free (temp);
}
</code></pre>

<p>}</p>

<p>void printPath(int x, int y)
{
    parent *pInfo;</p>

<pre><code>printf("Path:\n");
while (1) {
    printf ("%d ", array[x][y]);

    pInfo = parentArr[x][y];
    x = pInfo-&gt;x;
    y = pInfo-&gt;y;

    if (x == startIndX &amp;&amp; y == startIndY) {
        printf ("%d ", array[x][y]);
        break;
    }
} }
</code></pre>

<p>void findPath(int startX, int startY, int endX, int endY)
{
    int i = 0;
    int j = 0;
    int x = startX;
    int y = startY;
    int neighbourX = startX;
    int neighbourY = startY;
    int reached = FALSE;
    qnode *nextNode;</p>

<pre><code>while (1) {
    neighbour(x, y);

    // Check, are we neighbour of destination?
    for (i = 0; i &lt; 4; i++) {
        if (neighbourIndex[i][0] == endX &amp;&amp; neighbourIndex[i][1] == endY) {
            // Reached destination
            neighbourX = neighbourIndex[i][0];
            neighbourY = neighbourIndex[i][1];
            markParent(neighbourX, neighbourY, x, y);

            reached = TRUE;
            break;
        } else {
            // Validate neighbour
            if (neighbourIndex[i][0] != -1) {
                neighbourX = neighbourIndex[i][0];
                neighbourY = neighbourIndex[i][1];
                if (array[x][y] &lt; array[neighbourX][neighbourY]) {
                    // Mark neighbour index as visited
                    markVisited(x, y);
                    markVisited(neighbourX, neighbourY);

                    // Make me parent of neighbour index
                    markParent(neighbourX, neighbourY, x, y);

                    // Add neighbour to queue
                    enqueue(neighbourX, neighbourY);
                }
            }
        }
    } // end of for

    if (reached) {
        // print path
        printPath(endIndX, endIndY);
        break;
    }

    if (isQueueEmpty()) {
        // If queue is empty then halt, no path found
        printf ("No valid path exist");
        break;
    }

    // Get next item from queue
    nextNode = dequeue();
    if (nextNode != NULL) {
        x = nextNode-&gt;x;
        y = nextNode-&gt;y;

        free (nextNode);
    }
} // end of while }
</code></pre>

<p>void test1()
{
    int i = 0;
    int j = 0;</p>

<pre><code>array[0][0] = 1;
array[0][1] = 6;
array[0][2] = 8;
array[1][0] = 4;
array[1][1] = 7;
array[1][2] = 9;
array[2][0] = 5;
array[2][1] = 2;
array[2][2] = 3;

printf("\n\n");
for (i = 0; i &lt;= row; i++) {
    for (j = 0; j &lt;= col; j++) {
        printf("%d   ", array[i][j]);
    }
    printf("\n");
}

findPath(startIndX, startIndY, endIndX, endIndY);
freeQueue(); }
</code></pre>

<p>int main()
{
    head = (qnode*)malloc(sizeof(qnode));
    head-&gt;x = -1;
    head-&gt;y = -1;
    head-&gt;next = NULL;</p>

<pre><code>tail = head;

test1();

return 0; } {% endcoderay %}
</code></pre>

<p><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sorting]]></title>
    <link href="http://distkeys.com/blog/2013/10/12/sorting/"/>
    <updated>2013-10-12T13:08:00-07:00</updated>
    <id>http://distkeys.com/blog/2013/10/12/sorting</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#dictionary-of-algorithms">Dictionary of algorithms</a></li>
  <li><a href="#sorting-visualization">Sorting Visualization</a></li>
  <li><a href="#sorting-wiki-summary">Sorting Wiki Summary</a></li>
  <li><a href="#sorting-algorithms">Sorting algorithms</a></li>
  <li><a href="#comparisons-based-sorting">Comparisons based sorting</a></li>
  <li><a href="#online-sorts">Online sorts</a></li>
  <li><a href="#stable-sorts">Stable sorts</a></li>
  <li><a href="#time-complexity-chart">Time complexity chart</a></li>
</ul>

<p>This article talks about Sorting, Sorting techniques/algorithms in computer science</p>

<p>Let’s start with Wikipedia entry about sorting</p>

<p>{% wikipedia Sorting_algorithm %}
<!-- more -->
<br /></p>

<h3 id="dictionary-of-algorithms">Dictionary of algorithms</h3>

<p><a href="http://xlinux.nist.gov/dads//" target="_blank">Dictionary of algorithms</a></p>

<p><br /></p>

<h3 id="sorting-visualization">Sorting Visualization</h3>

<p><a href="http://corte.si/posts/code/visualisingsorting/index.html" target="_blank">Sorting Visualization</a></p>

<p><br /></p>

<h3 id="sorting-wiki-summary">Sorting Wiki Summary</h3>

<p><a href="http://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank">Sorting Wiki Summary</a></p>

<p><br /></p>

<p>Sorting algorithms can be divided into categories</p>

<h3 id="sorting-algorithms">Sorting algorithms</h3>
<ol>
  <li><strong><em>Comparisons based sorts</em></strong> - 24 algorithms in this category</li>
  <li><strong><em>Online sorts</em></strong>            - 5 algorithms in this category</li>
  <li><strong><em>Stable sorts</em></strong>            - 14 algorithms in this category</li>
</ol>

<p>Donald Knuth pioneer in algorithms and field of Computer Science have divided sorting into</p>

<ol>
  <li><strong><em>Internal sorting</em></strong> - by insertion, by exchange, by selection, by merging, by distribution<br /></li>
  <li><strong><em>Optimum sorting</em></strong>  - min-comparison sorting, min-comparison merging, min-comparison selection<br /></li>
  <li><strong><em>External sorting</em></strong> <br /></li>
</ol>

<h3 id="comparisons-based-sorting">Comparisons based sorting</h3>
<p>It is particular type of sorting algorithm which read the list elements through comparison operator that determines which of two elements should occur first int he final sorted list.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Adaptive_heap_sort" target="_blank">Adaptive heap sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Bogosort" target="_blank">Bogosort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Bubble sort</a>                       - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Cascade_merge_sort" target="_blank">Cascade merge sort</a>         - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Cocktail_sort" target="_blank">Cocktail sort</a>                   - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Comb_sort" target="_blank">Comb sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Cycle_sort" target="_blank">Cycle sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Gnome_sort" target="_blank">Gnome sort</a>                         - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank">Heapsort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a>                 - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Introsort" target="_blank">Introsort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a>                     - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a>                         - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Odd–even_sort" target="_blank">Odd–even sort</a>                   - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Oscillating_merge_sort" target="_blank">Oscillating merge sort</a> - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Patience_sorting" target="_blank">Patience sorting</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Polyphase_merge_sort" target="_blank">Polyphase merge sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank">Quicksort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Selection_sort" target="_blank">Selection sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Shellsort" target="_blank">Shellsort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Smoothsort" target="_blank">Smoothsort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Stooge_sort" target="_blank">Stooge sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Strand_sort" target="_blank">Strand sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Timsort" target="_blank">Timsort</a></li>
</ul>

<p>*(S) - Stable sorts
<br /></p>

<h3 id="online-sorts">Online sorts</h3>

<p>These sorts can start sorting their input without having received all of it. It can process its input piece-by-piece in a serial fashion, i.e., in the order that the input is fed to the algorithm, without having the entire input available from the start.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Cycle_sort" target="_blank">Cycle sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a>                 - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a>                     - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a>                         - (S)</li>
  <li><a href="http://en.wikipedia.org/wiki/Polyphase_merge_sort" target="_blank">Polyphase merge sort</a></li>
</ul>

<p>*(S) - Stable sorts
<br /></p>

<h3 id="stable-sorts">Stable sorts</h3>

<p>A sorting algorithm is stable if whenever there are two records R and S with the <code>same key</code> and with R appearing before S in the original list, <code>R will appear before S</code> in the sorted list.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Bubble sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Bucket_sort" target="_blank">Bucket sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Cascade_merge_sort" target="_blank">Cascade merge sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Cocktail_sort" target="_blank">Cocktail sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Counting_sort" target="_blank">Counting sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Gnome_sort" target="_blank">Gnome sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Odd–even_sort" target="_blank">Odd–even sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Oscillating_merge_sort" target="_blank">Oscillating merge sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Pigeonhole_sort" target="_blank">Pigeonhole sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Proxmap_sort" target="_blank">Proxmap sort</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Radix_sort" target="_blank">Radix sort</a></li>
</ul>

<h3 id="time-complexity-chart">Time complexity chart</h3>

<table>
<thead>
<tr>
    <th><code class="mygreen">Good</code></th><th><code class="myyellow">Fair</code></th><th><code class="myred">Poor</code></th>
</tr>
</thead>
</table>

<p><br /></p>

<p><sup>*</sup>(V/D) - Variant or derived from</p>

<p><br /></p>
<table>
<thead>
<tr>
    <th>Algorithm</th><th colspan="3">Time complexity</th><th>Space complexity</th><th>Notes</th>
</tr>
<tr>
    <th /><th>Best</th><th>Average</th><th>Worst</th><th /><th />
</tr>
</thead>
<tbody>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Adaptive_heap_sort" target="_blank">Adaptive heap sort</a></td>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Bogosort" target="_blank">Bogosort</a></code></td>
    <td><code class="myyellow">Ω(n)</code></td>
    <td>O(n × n!)</td>
    <td><code class="myred">Unbounded</code></td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Bubble sort</a></code></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Cascade_merge_sort" target="_blank">Cascade merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Cocktail_sort" target="_blank">Cocktail sort</a></code></td>
    <td>O(n)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
    <td>(V/D) - Bubble Sort</td>
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Comb_sort" target="_blank">Comb sort</a></code></td>
    <td>O(n)</td>
    <td>Ω(<math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><mrow><msup><mi>2</mi><mn>p</mn></msup></mrow></mfrac></math>)</td>
    <td>Ω(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
    <td>(V/D) - Bubble Sort</td>
</tr>
<tr>
    <td><code class="myyellow"><a href="http://en.wikipedia.org/wiki/Cycle_sort" target="_blank">Cycle sort</a></code></td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(n)</td>
    <td><code class="mygreen">Write efficient</code></td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Gnome_sort" target="_blank">Gnome sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
    <td>Bubble + Insertion sort</td>
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank">Heapsort</a></code></td>
    <td>Ω(n), O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td><code class="mygreen">O(1)</code></td>
    <td><a href="http://distkeys.com/blog/2013/10/13/comparison-based-sorting/#table-based-comparison" target="_blank">Detailed notes</a></td>
</tr>
<tr>
    <td><code class="myyellow"><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a></code></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Introsort" target="_blank">Introsort</a></code></td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td />
    <td>Quick sort + Heap sort<br /><a href="https://www.dropbox.com/s/21q1ymf2y86kqcz/introsort.pdf" target="_blank"> IntroSort Paper</a></td>
</tr>
<tr>
    <td><code class="myyellow"><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a></code></td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td><code class="myred">O(n)</code></td>
    <td>(V/D) - Insertion sort</td>
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a></code></td>
    <td>O(n), O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td><code class="myred">O(n)</code></td>
    <td><a href="http://distkeys.com/blog/2013/10/13/comparison-based-sorting/#table-based-comparison" target="_blank">Detailed notes</a></td>
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Odd–even_sort" target="_blank">Odd–even sort</a></code></td>
    <td>O(n)</td>
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
    <td>*(V/D) - Bubble sort</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Oscillating_merge_sort" target="_blank">Oscillating merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Patience_sorting" target="_blank">Patience sorting</a></code></td>
    <td />
    <td />
    <td>O(nlogn)</td>
    <td>O(n)</td>
    <td><a href="http://wordaligned.org/articles/patience-sort" target="_blank">Longest common sequence</a></td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Polyphase_merge_sort" target="_blank">Polyphase merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank">Quicksort</a></code></td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Selection_sort" target="_blank">Selection sort</a></code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><code class="myyellow"><a href="http://en.wikipedia.org/wiki/Shellsort" target="_blank">Shellsort</a></code></td>
    <td>Depends on gap seq</td>
    <td>Depends on gap seq</td>
    <td>Depends on gap seq</td>
    <td>O(n)</td>
    <td>Faster on partial sorted list</td>
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Smoothsort" target="_blank">Smoothsort</a></code></td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
    <td>*(V/D) - Heap sort</td>
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Stooge_sort" target="_blank">Stooge sort</a></code></td>
    <td />
    <td />
    <td />
    <td>O(n)</td>
    <td>Slower than bubble sort</td>
</tr>
<tr>
    <td><code class="myred"><a href="http://en.wikipedia.org/wiki/Strand_sort" target="_blank">Strand sort</a></code></td>
    <td>O(n)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
    <td />
</tr>
<tr>
    <td><code class="mygreen"><a href="http://en.wikipedia.org/wiki/Timsort" target="_blank">Timsort</a></code></td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
    <td>Merge + Insertion sort</td>
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Online sorting</th>
    <th />
    <th />
    <th />
    <th />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Cycle_sort" target="_blank">Cycle sort</a></td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(n)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a></td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a></td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Polyphase_merge_sort" target="_blank">Polyphase merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Stable sorting</th>
    <th />
    <th />
    <th />
    <th />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Bubble sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Bucket_sort" target="_blank">Bucket sort</a></td>
    <td />
    <td>O(n + k)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n.k)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Cascade_merge_sort" target="_blank">Cascade merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Cocktail_sort" target="_blank">Cocktail sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Counting_sort" target="_blank">Counting sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Gnome_sort" target="_blank">Gnome sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">Insertion sort</a></td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Library_sort" target="_blank">Library sort</a></td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge sort</a></td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Odd–even_sort" target="_blank">Odd–even sort</a></td>
    <td />
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Oscillating_merge_sort" target="_blank">Oscillating merge sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Pigeonhole_sort" target="_blank">Pigeonhole sort</a></td>
    <td />
    <td />
    <td>O(N + n)</td>
    <td>O(N + n)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Proxmap_sort" target="_blank">Proxmap sort</a></td>
    <td>O(n)</td>
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Radix_sort" target="_blank">Radix sort</a></td>
    <td />
    <td />
    <td>O(kN)</td>
    <td>O(k + N)</td>
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Non-category Sorts</th>
    <th />
    <th />
    <th />
    <th />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Adaptive_sort" target="_blank">Adaptive sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/American_flag_sort" target="_blank">American flag sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Bead_sort" target="_blank">Bead sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Burstsort" target="_blank">Burstsort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Cartesian_tree" target="_blank">Cartesian tree</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Comparison_sort" target="_blank">Comparison sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Dutch_national_flag_problem" target="_blank">Dutch national flag problem</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Elevator_algorithm" target="_blank">Elevator algorithm</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank">External sorting</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Flashsort" target="_blank">Flashsort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Integer_sorting" target="_blank">Integer sorting</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Internal_sort" target="_blank">Internal sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/J_sort" target="_blank">J sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Median_cut" target="_blank">Median cut</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Ordicate" target="_blank">Ordicate</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Pairwise_sorting_network" target="_blank">Pairwise sorting network</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Pancake_sorting" target="_blank">Pancake sorting</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Partial_sorting" target="_blank">Partial sorting</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Proxmap_sort" target="_blank">Proxmap sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Quantum_sort" target="_blank">Quantum sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Samplesort" target="_blank">Samplesort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Sorting_network" target="_blank">Sorting network</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Spaghetti_sort" target="_blank">Spaghetti sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Spreadsort" target="_blank">Spreadsort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Topological_sorting" target="_blank">Topological sorting</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Tournament_sort" target="_blank">Tournament sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/Tree_sort" target="_blank">Tree sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td><a href="http://en.wikipedia.org/wiki/UnShuffle_sort" target="_blank">UnShuffle sort</a></td>
    <td />
    <td />
    <td />
    <td />
</tr>
</tbody>
</table>
]]></content>
  </entry>
  
</feed>

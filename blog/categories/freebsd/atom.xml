<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: FreeBSD | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/freebsd/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-12-31T12:55:31-08:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fork code in FreeBSD]]></title>
    <link href="http://distkeys.com/blog/2014/12/31/fork-in-freebsd/"/>
    <updated>2014-12-31T11:51:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/12/31/fork-in-freebsd</id>
    <content type="html"><![CDATA[<p>In computing, particularly in the context of the Unix operating system and its workalikes, fork is an operation whereby a process creates a copy of itself. It is usually a system call, implemented in the kernel. Fork is the primary (and historically, only) method of process creation on Unix-like operating systems.</p>

<p><a href="http://en.wikipedia.org/wiki/Fork_(system_call)">Read More</a></p>

<!-- more -->
<p><br /></p>

<blockquote>
  <p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process.</p>
</blockquote>

<p><a href="https://github.com/coolgoose85/FreeBSD/tree/master/sys">FreeBSD source code</a></p>

<p>{% coderay lang:C  Function Fork() %}
Function fork(td, uap)
{
    …
     error = fork1(td, RFFDG | RFPROC, 0, &amp;p2);</p>

<pre><code> Return pid of child
 td-&gt;td_retval[0] = p2-&gt;p_pid; } {% endcoderay %} 
</code></pre>

<p><br /></p>

<p>{% coderay lang:c  Function Fork1() %}
Function fork1(td, flags, pages, procp)
{
     struct proc *p1, *p2, *pptr; //p1 = parent process, p2 = child process</p>

<pre><code> Parent process
 p1 = td-&gt;td_proc;

 ...
 ...
 Allocate a new process
 newproc = uma_zalloc(proc_zone, M_WAITOK);

 To run a process we need to have atleast one thread,
 so allocate a new thread
 td2 = thread_alloc();

 Linkup thread to process
 proc_linkup(newproc, td2);
 ...
 ...

 Now we have to gro through the process address space and copy each section for new process
 Sections of process address space are
 1. Text area (read only)
 2. Initialized area
 3. Uninitiaized area
 4. Stack/Heap area

 vm2 = vmspace_fork(p1-&gt;p_vmspace);

      Function vmspace_fork(p1-&gt;p_vmspace) {
                Process virtual address space is as follows
                /*
                * struct vmspace {
                *      struct vm_map vm_map;     /* VM address map */
                *      struct shmmap_state *vm_shm;     /* SYS5 shared memory private data XXX */
                *      segsz_t vm_swrss;     /* resident set size before last swap */
                *      segsz_t vm_tsize;     /* text size (pages) XXX */
                *      segsz_t vm_dsize;     /* data size (pages) XXX */
                *      segsz_t vm_ssize;     /* stack size (pages) */
                *      caddr_t vm_taddr;     /* (c) user virtual address of text */
                *      caddr_t vm_daddr;     /* (c) user virtual address of data */
                *      caddr_t vm_maxsaddr;     /* user VA at max stack growth */
                *      int     vm_refcnt;     /* number of references */
                *      /*
                *       * Keep the PMAP last, so that CPU-specific variations of that
                *       * structure on a single architecture don't result in offset
                *       * variations of the machine-independent fields in the vmspace.
                *       */
                *      struct pmap vm_pmap;     /* private physical map */
                * };
                */

           We allocate the process address space
           struct vmspace *vm2;
           ...
           vm2 = vmspace_alloc(old_map-&gt;min_offset, old_map-&gt;max_offset);    
           ...
           ...

           Now we have to go through each vm map entries one at a time and allocate each for new process
           while (old_entry != &amp;old_map-&gt;header) {
                case VM_INHERIT_NONE:
                     ...

                case VM_INHERIT_SHARE:
                     ...

                case VM_INHERIT_COPY:
                     This is our case where we have to clone the entries and link into the map
                     new_entry = vm_map_entry_create(new_map);
                     ..
                     vm_map_entry_link(new_map, new_map-&gt;header.prev, new_entry);
                     vmspace_map_entry_forked(vm1, vm2, new_entry);
                     vm_map_copy_entry(old_map, new_map, old_entry,         
           }
      } // end vmspace_fork()


 We will be now locking the process tree as we need to give new process process id
 Process of allocating a new Pid is system will scan the existing pids and try to come
 up with a range of free pids. Once a range of free pids found system will use that range
 for next lets say "k" forks. Once the range is exhausted then system on next fork will
 again find the range and so on.

 sx_slock(&amp;proctree_lock);

 Determine if we are exceeding process createlimit
 Check privledge to increase the limit

 //Try to allocate the pids
 trypid = lastpid + 1;

 ...

 Check if we have hit the end of the range
 if (trypid &gt;= pidchecked) {
      We have exhausted the range so find a new range
      Scan the active and Zombie procs to check whether pid is in use
      ...
      ...
 }
 sx_sunlock(&amp;proctree_lock);

 If we are within range then
 lastpid = trypid;

 p2 = newproc;
 p2-&gt;p_state = PRS_NEW;          /* protect against others */
 p2-&gt;p_pid = trypid;


 sched_fork(td, td2);
           Function sched_fork(struct thread *td, struct thread *child) {
                sched_fork_thread(td, child);
                          Function sched_fork_thread(td, child) {
                               Initialize schedule related values from parent to child
                               Assign CPU estimate info and priority
                               ...
                          }
           } // end sched_fork()
     
 Insert new process to process list
 LIST_INSERT_HEAD(&amp;allproc, p2, p_list);

 Insert into PID HASH
 LIST_INSERT_HEAD(PIDHASH(p2-&gt;p_pid), p2, p_hash);


 Lock P1
 Lock P2
 Relase Lock for All proc since we took all proc lock to allocate new pid
 sx_xunlock(&amp;allproc_lock);

 copy the blocks
 bcopy(&amp;p1-&gt;p_startcopy, &amp;p2-&gt;p_startcopy,
     __rangeof(struct proc, p_startcopy, p_endcopy));

 Zero out the blocks
 bzero(&amp;p2-&gt;p_startzero,
     __rangeof(struct proc, p_startzero, p_endzero));

 ...
 Allocate new signals

 Copy File descriptors of all the open files by parent to child
 fd = fdcopy(p1-&gt;p_fd);


 In a new process, we created a thread now copy the blocks for this new thread
 bzero(&amp;td2-&gt;td_startzero,
     __rangeof(struct thread, td_startzero, td_endzero));

 bcopy(&amp;td-&gt;td_startcopy, &amp;td2-&gt;td_startcopy,
     __rangeof(struct thread, td_startcopy, td_endcopy));

 bcopy(&amp;p2-&gt;p_comm, &amp;td2-&gt;td_name, sizeof(td2-&gt;td_name));

 ...
 ...

 Copy the vnode pointer of text from parent to child
 p2-&gt;p_textvp = p1-&gt;p_textvp;   // Vnode of executable. and increase the ref count
 vref(p2-&gt;p_textvp);

 ...


 Processing related to process group, child and parent will belong to same process group
 Insert process into process group list


 Associate child with Parent
 pptr = p1;
 p2-&gt;p_pptr = pptr;

 Insert child process into sibling list
 LIST_INSERT_HEAD(&amp;pptr-&gt;p_children, p2, p_sibling);

 vm_forkproc(td, p2, td2, vm2, flags);
           Function vm_forkproc(td, p2, td2, vm2, flags) {
                ...
                ...

                cpu_fork(td, p2, td2, flags);
                          Function cpu_fork(struct thread *td1, struct proc *p2, struct thread *td2, int flags)
                          {
                               Copy PCB and the stack
                               pcb1 = td1-&gt;td_pcb;

                               Allocate PCB for child process
                               pcb2 = (struct pcb *)(td2-&gt;td_kstack +
                               td2-&gt;td_kstack_pages * PAGE_SIZE) - 1;
                               td2-&gt;td_pcb = pcb2;

                               Copy PCB1 to PCB2 (PCB struct is in pcb.h)
                               bcopy(td1-&gt;td_pcb, pcb2, sizeof(*pcb2));

                               Create a new stack for a new process
                               td2-&gt;td_frame = (struct trapframe *)((caddr_t)td2-&gt;td_pcb - 16) - 1;
                               bcopy(td1-&gt;td_frame, td2-&gt;td_frame, sizeof(struct trapframe));
                               ...
                               td2-&gt;td_frame-&gt;tf_eax = 0;          /* Child returns zero */
                               ...
                               ...

                               In instruction pointer of child process we will set the address of trampoline code
                               pcb2-&gt;pcb_eip = (int)fork_trampoline;

                               //Fork_trampoline code will call fork_return
                               pcb2-&gt;pcb_esi = (int)fork_return;     /* fork_trampoline argument */
                               pcb2-&gt;pcb_ebx = (int)td2;          /* fork_trampoline argument */

                                         Looking into fork_trampoline in i386/exception.s
                                              ENTRY(fork_trampoline)
                                                        pushl     %esp               /* trapframe pointer */
                                                        pushl     %ebx               /* arg1 */
                                                        pushl     %esi               /* function */
                                                        call     fork_exit
                                              So, from fork_trampoline we are going to call fork_exit and its argument
                                              will be above we mentioned.

                                                   //Handle the return of a child process from fork1()
                                                   Function fork_exit(callout, arg, frame)         
                                                   {
                                                        ...
                                                        callout(arg, frame); // Here callout is fork_return, as we passed it
                                                                                      as a argument to fork_exit

                                                             Function fork_return() {                                            
                                                                  userret(td, frame);
                                                             }
                                                   }

                                              Once we return from fork_exit we will go to doreti
                                              which will load our frame and we have will go back to
                                              fork system call as a child. But the chils process will
                                              not execute right now because we have not scheduled it
                                              to run. This is the setup we are preparing and once
                                              all the setup is done we will schedule the child process
                                              and it will do as described above
                                              jmp     doreti    

                          } // end of cpu_fork()
           } //end of vm_forkproc


 Put child process on run queue
 sched_add(td2, SRQ_BORING);

 ...
 ...
</code></pre>

<p>} //end fork1()
{% endcoderay %} </p>

<p><br /></p>

<h2 id="call-tree">Call Tree</h2>

<p>{% img /images/fork1.png [fork1.png] %}</p>

<p><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug FreeBSD - Open]]></title>
    <link href="http://distkeys.com/blog/2014/08/04/debug-freebsd-open/"/>
    <updated>2014-08-04T19:10:00-07:00</updated>
    <id>http://distkeys.com/blog/2014/08/04/debug-freebsd-open</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bird-eye-view">Bird Eye View</a></li>
  <li><a href="#map---open">Map - Open</a></li>
  <li><a href="#file-structure--file-descriptor">File Structure &amp; File Descriptor</a>    <ul>
      <li><a href="#file-structure-allocation">File Structure Allocation</a></li>
      <li><a href="#file-descriptor">File Descriptor</a></li>
      <li><a href="#how-file-descriptor-is-allocated-fdalloc">How file descriptor is allocated (fdalloc)</a></li>
    </ul>
  </li>
  <li><a href="#call-tree">Call Tree</a></li>
  <li><a href="#pathname-lookup">Pathname Lookup</a></li>
  <li><a href="#associate-vnode-with-file-structure">Associate vnode with file structure</a></li>
  <li><a href="#return-file-descriptor-back-to-the-user">Return file descriptor back to the user</a></li>
</ul>

<p><strong>Open System Call</strong></p>

<p>For most file systems, a program initializes access to a file in a filesystem using the open system call. This allocates resources associated to the file (the file descriptor), and returns a handle that the process will use to refer to that file. In some cases the open is performed by the first access.</p>

<p>More information can be found at wikipedia <a href="http://en.wikipedia.org/wiki/Open_(system_call)" target="_blank">article</a> or <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank">Linux manual page.</a></p>

<!-- more -->

<p>This post will explore the code flow when open system call is issued.</p>

<p><br /><br /></p>

<h2 id="bird-eye-view">Bird Eye View</h2>

<p>Open system call goes through lot of twist and turns and explore some of the most complicated code paths. On a very high level it tries to do the following task.</p>

<ol>
  <li>Allocate file structure and file descriptor<br /></li>
  <li>Associate file structure with file descriptor<br /></li>
  <li>Pathname lookup will return vnode<br /></li>
  <li>Associate vnode with file structure<br /></li>
  <li>Return file descriptor back to the user<br /></li>
</ol>

<p><br /></p>

<h2 id="map---open">Map - Open</h2>

<p>All the system calls are mapped with system call number in <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/syscalls.master#L65" target="_blank">syscalls.master (kern)</a>.</p>

<p>For open system call</p>
<table>
<thead>
<tr>
	<th>System Call Number</th><th>System Call</th><th>System Call Signature</th>
</tr>
</thead>
<tbody>
<tr>
	<td>5</td>
	<td>AUE_OPEN_RWTC</td>
	<td>int open(char *path, int flags, int mode);</td>
</tr>
</tbody>
</table>

<p>More details about how system call is executed can be found <a href="http://distkeys.com/blog/2014/08/03/inside-freebsd/#system-calls" target="_blank">here.</a></p>

<p><br /><br /></p>

<h2 id="file-structure--file-descriptor">File Structure &amp; File Descriptor</h2>

<p>Open system call starts from function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1012" target="_blank">open(td, uap)</a> which calls function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1041" target="_blank">kern_open()</a> which finally calls function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat().</a> This is the function from where all the action starts.</p>

<p>In function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat()</a>, we are going to allocate the file descriptor. To do so we call function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1411" target="_blank">falloc()</a>.<br /><br /></p>

<blockquote>
  <p>Function falloc(struct thread *td, struct file **resultfp, int *resultfd) returns back pointer to the <code class="myyellow">file entry</code> and <code class="myyellow">file descriptor.</code></p>
</blockquote>

<p><br /></p>

<h3 id="file-structure-allocation">File Structure Allocation</h3>

<p>Allocate space for <code class="myyellow">file structure</code> in kernel either by malloc or we use zalloc here because memory is assigned from file zone. There are multiple zones like file_zone, proc_zone or thread_zone. So, we ask memory from file zone and we pass the parameter is space in this zone is not available then are we willing to wait. Its a synchronous call. If memory is not available then thread will go to sleep if M_WAITOK is set.</p>

<p>{% coderay lang:c  falloc()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1420 code %}
     fp = uma_zalloc(file_zone, M_WAITOK | M_ZERO);
{% endcoderay %}</p>

<p>We get back pointer to file entry.
Zone limits are set during boot up time and whenever allocation or free happens it happens from that limit allocated.</p>

<p><em>File structure</em> looks as follows
{% coderay lang:c  file structure https://github.com/coolgoose85/FreeBSD/blob/master/sys/sys/file.h#L116 code %}</p>

<p>struct file {
     void              <em>f_data;     /</em> file descriptor specific data <em>/
     struct fileops     *f_ops;          /</em> File operations <em>/
     struct ucred       *f_cred;     /</em> associated credentials. <em>/
     struct vnode      *f_vnode;     /</em> NULL or applicable vnode <em>/
     short          f_type;          /</em> descriptor type <em>/
     short          f_vnread_flags; /</em> (f) Sleep lock for f_offset <em>/
     volatile u_int     f_flag;          /</em> see fcntl.h <em>/
     volatile u_int      f_count;     /</em> reference count <em>/
     /</em>
      *  DTYPE_VNODE specific fields.
      <em>/
     int          f_seqcount;     /</em> Count of sequential accesses. <em>/
     off_t          f_nextoff;     /</em> next expected read/write offset. <em>/
     struct cdev_privdata *f_cdevpriv; /</em> (d) Private data for the cdev. <em>/
     /</em>
      *  DFLAG_SEEKABLE specific fields
      <em>/
     off_t          f_offset;
     /</em>
      * Mandatory Access control information.
      <em>/
     void          *f_label;     /</em> Place-holder for MAC label. */
     };
{% endcoderay %}     </p>

<p>We have created a <code class="myyellow">file structure</code> now we have to initialize it. So we, </p>

<ul>
  <li>Increment the ref count for the file structure to 1.</li>
  <li>Assign the input credentials.</li>
  <li>Initialize the file ops to <em>badfileops</em> and we will update it later as we figure it out.</li>
  <li>data is null</li>
  <li>There are no <em>vnode</em> associated yet.
<br /><br /></li>
</ul>

<h3 id="file-descriptor">File Descriptor</h3>

<p>Now, allocate the file descriptor. For that get lock and call <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1446" target="_blank">fdalloc()</a> to allocate fd.</p>

<p>{% coderay lang:c  fdalloc()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1446 code %}
if ((error = fdalloc(td, 0, &amp;i))) {
{% endcoderay %}
Here ‘i’ is the file descriptor to be returned.</p>

<p>Once we get file descriptor from function fdalloc() we associate the file descriptor to file structure we allocated above.
{% coderay lang:c  fdalloc()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1453 code %}
p-&gt;p_fd-&gt;fd_ofiles[i] = fp;
{% endcoderay %}
Here p is the process structure where it maintains all the files opened.</p>

<p>Return the fd and file structure pointer from function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1411" target="_blank">falloc()</a> to function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat()</a></p>

<p><br /></p>

<h3 id="how-file-descriptor-is-allocated-fdalloc">How file descriptor is allocated (fdalloc)</h3>

<p>In function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1331" target="_blank">fdalloc()</a>, we search the bitmap for a free descriptor. If we can’t find then grow the file table until limit is hit.</p>

<p>{% coderay lang:c  fdalloc() https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1352 code %}
for (;;) {
          fd = fd_first_free(fdp, minfd, fdp-&gt;fd_nfiles);
          if (fd &gt;= maxfd)
               return (EMFILE);
          if (fd &lt; fdp-&gt;fd_nfiles)
               break;
          fdgrowtable(fdp, min(fdp-&gt;fd_nfiles * 2, maxfd));
          }
{% endcoderay %}</p>

<h2 id="call-tree">Call Tree</h2>

<p>{% img /images/CallsGraph-open.png [CallsGraph-open.png] %}</p>

<p><br /><br /></p>

<h2 id="pathname-lookup">Pathname Lookup</h2>

<p>Now we pick up the mode information for file provided as input. Mode value will be used if we have to create a file.</p>

<p>Now we call <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_vnops.c#L89" target="_blank">vn_open()</a> function and pass the input information.</p>

<p>{% coderay lang:c  vn_open() https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_vnops.c#L89  code %}
error = vn_open(&amp;nd, &amp;flags, cmode, fp); 
{% endcoderay %}</p>

<p>Here, struct nameidata nd;<br />
If we don’t hit any error then we will get node related information in nd and all we do is extract the information and tie up with the fp file structure pointer.</p>

<p><br /><br /></p>

<h2 id="associate-vnode-with-file-structure">Associate vnode with file structure</h2>

<p>If we don’t hit any error from vn_open() then we will get node related information in nd and all we do is extract the information and tie up with the <em>fp</em> file structure pointer.</p>

<p>{% coderay lang:c  Assign vnode https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1131 code %}
error = vn_open(&amp;nd, &amp;flags, cmode, fp); 
…
…
vp = nd.ni_vp;
fp-&gt;f_vnode = vp;
{% endcoderay %}</p>

<p>By this time if file operation is not set i.e. if it is still <em>badfileops</em> then we initialize it.</p>

<p>{% coderay lang:c  badfileops https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1138 code %}
if (fp-&gt;f_ops == &amp;badfileops) {
          KASSERT(vp-&gt;v_type != VFIFO, (“Unexpected fifo.”));
          fp-&gt;f_seqcount = 1;
          finit(fp, flags &amp; FMASK, DTYPE_VNODE, vp, &amp;vnops);
 }
{% endcoderay %}</p>

<p>So far, we have done all the book keeping operations. Once its done we need to write data to the file.
Now, we do the locking of a file. Based on what kind of locking is requested i.e.</p>

<ol>
  <li>Exclusive lock<br /></li>
  <li>Shared Lock<br /></li>
  <li>Write Lock<br /></li>
  <li>Read Lock<br /></li>
  <li>Lease to client<br /></li>
</ol>

<p>So, we do the locking of file. Write to the file and file set the attributes to the file.</p>

<p>{% coderay lang:c  file locking https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1145 code %}</p>

<p>if (flags &amp; (O_EXLOCK | O_SHLOCK)) {
     …
     …
          if ((error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &amp;lf,type)) != 0) {
               …
          }
     …
 }</p>

<p>if (flags &amp; O_TRUNC) {
          if ((error = vn_start_write(vp, &amp;mp, V_WAIT | PCATCH)) != 0)
               goto bad;
          VOP_LEASE(vp, td, td-&gt;td_ucred, LEASE_WRITE);
          …
          …
          vat.va_size = 0;
          …
          error = VOP_SETATTR(vp, &amp;vat, td-&gt;td_ucred);
          …
}
{% endcoderay %}</p>

<p><br /><br /></p>

<h2 id="return-file-descriptor-back-to-the-user">Return file descriptor back to the user</h2>

<p>Finally we return fd (indx) and 0 which is success from function kern_openat()</p>

<p>{% coderay lang:c  Return fd https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1184 code %}
 	td-&gt;td_retval[0] = indx;
	return (0);
 {% endcoderay %}</p>

<p><br /> <br /> <br /> <br /> <br /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inside FreeBSD - Debug System Call]]></title>
    <link href="http://distkeys.com/blog/2014/08/03/inside-freebsd/"/>
    <updated>2014-08-03T10:36:00-07:00</updated>
    <id>http://distkeys.com/blog/2014/08/03/inside-freebsd</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#system-calls">System Calls</a></li>
</ul>

<p>{% wikipedia System_call %}</p>

<!-- more -->

<p><br /><br /></p>

<h3 id="system-calls">System Calls</h3>

<p>Whenever system call is executed from user level a trap is generated and it gets handled at file <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/exception.s#L255" target="_blank">Exception.S (i386\i386)</a> </p>

<p>{% coderay lang:c linenos:true System Call  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/exception.s#L255 Code %}
/* 
 * Even though the name says ‘int0x80’, this is actually a TGT (trap gate)
 * rather then an IGT (interrupt gate).  Thus interrupts are enabled on
 * entry just as they are for a normal syscall.
 <em>/
     SUPERALIGN_TEXT
IDTVEC(int0x80_syscall)
     pushl     $2               /</em> sizeof “int 0x80” <em>/
     subl     $4,%esp               /</em> skip over tf_trapno */
     pushal
     pushl     %ds
     pushl     %es
     pushl     %fs
     SET_KERNEL_SREGS
     FAKE_MCOUNT(TF_EIP(%esp))
     pushl     %esp
     call     syscall   ==&gt; from here syscall function is called after pushing some prereq
     add     $4, %esp
     MEXITCOUNT
     jmp     doreti ==&gt; do return from interrupt 
{% endcoderay %}</p>

<p><br /></p>

<blockquote>
  <p><em>syscall()</em> is a function in <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L977" target="_blank">Trap.c (i386\i386)</a> is a machine dependent code area.<br /></p>
</blockquote>

<p><code class="myyellow">Function syscall()</code> is called with trap frame which has input values to system call.</p>

<p>{% coderay lang:c  struct trapframe %}
/*
 * Exception/Trap Stack Frame
 */</p>

<p>struct trapframe {
     int     tf_fs;
     int     tf_es;
     int     tf_ds;
     int     tf_edi;
     int     tf_esi;
     int     tf_ebp;
     int     tf_isp;
     int     tf_ebx;
     int     tf_edx;
     int     tf_ecx;
     int     tf_eax;
     int     tf_trapno;
     /* below portion defined in 386 hardware <em>/
     int     tf_err;
     int     tf_eip;
     int     tf_cs;
     int     tf_eflags;
     /</em> below only when crossing rings (e.g. user to kernel) */
     int     tf_esp;
     int     tf_ss;
};
{% endcoderay %}</p>

<p><br /></p>

<p><code class="myyellow">Function syscall()</code> now gets all the values of system call input and store in kernel so that kernel code can access the values while processing system call.</p>

<p>{% coderay lang:c  syscall()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L997 code %}
	params = (caddr_t)frame-&gt;tf_esp + sizeof(int);
     code = frame-&gt;tf_eax;   // code is system call code
     orig_tf_eflags = frame-&gt;tf_eflags;
{% endcoderay %}</p>

<p><br /></p>

<p>Then check we have direct or indirect system call. Indirect system call is one which is like loadable kernel module which loads system call. Once loaded then it can pass the system call number as argument which can be injected in here.</p>

<p><br />
Then given the system call code we check if we have the code as valid number. If system call code is valid then lookup in system call table which system call is referred else simply store the pointer to indirect system call which is system call 0.
<br />
{% coderay lang:c  syscall()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1030 code %}
if (code &gt;= p-&gt;p_sysent-&gt;sv_size)
           callp = &amp;p-&gt;p_sysent-&gt;sv_table[0];
       else
           callp = &amp;p-&gt;p_sysent-&gt;sv_table[code]; 
{% endcoderay %}
<br />
where <strong>sv_table</strong> entry will have following values</p>

<p>{% coderay lang:c  sv_table %}
struct sysent {               /* system call table <em>/
     int     sy_narg;     /</em> number of arguments <em>/
     sy_call_t *sy_call;     /</em> implementing function <em>/
     au_event_t sy_auevent;     /</em> audit event associated with syscall <em>/
     systrace_args_func_t sy_systrace_args_func;
                    /</em> optional argument conversion function. <em>/
     u_int32_t sy_entry;     /</em> DTrace entry ID for systrace. <em>/
     u_int32_t sy_return;     /</em> DTrace return ID for systrace. */
};
{% endcoderay %}</p>

<p>Once we know which system it is then we determine how many arguments it have</p>

<blockquote>
  <p>narg = callp-&gt;sy_narg;</p>
</blockquote>

<p>Then we copy all the user space arguments into kernel space using function copying which validates the addresses of source and destination etc.</p>

<p>{% coderay lang:c  syscall()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1040 code %}
  /*
      * copyin and the ktrsyscall()/ktrsysret() code is MP-aware
      * copy data from params to args
      */
     if (params != NULL &amp;&amp; narg != 0)
          error = copyin(params, (caddr_t)args,
                        (u_int)(narg * sizeof(int)));</p>

<p>{% endcoderay %}</p>

<p>Now, check if we saw any error so far. If we did find the error then we need to return the error but, at this time in kernel it does not know how to return in user space. So, we set the register 0 to be non zero which is the error number and we set another register which is carry bit(eflag). <br /></p>

<p>So, when system call is returned, C lib which issued the system call will check if carry bit(eflag) is set or not. If it is set then it will get the error number from register 0 and map it to human readable error <em>errorno</em> and then override the register 0 with -1. <br />
So, say if open system call encounters error then its going to get the error value from register 0; translate it to meaningful error and then override the register 0 with -1. So open returned the value -1 which is failure.</p>

<p>{% coderay lang:c  syscall()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1056 code %}
if (error == 0) {
          td-&gt;td_retval[0] = 0;
          td-&gt;td_retval[1] = frame-&gt;tf_edx; // return another value in register 1 if we have anything to return
{% endcoderay %}</p>

<p>Now we call the actual system call
&gt; error = (*callp-&gt;sy_call)(td, args);</p>

<p>Here, 
<em>td</em> is the thread pointer
<em>args</em> are the arguments we have copied above from user space to kernel space</p>

<p>We check error and if all fine then we return the values back to user space</p>

<p>{% coderay lang:c  syscall()  https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1094 code %}
switch (error) {
     case 0:
          frame-&gt;tf_eax = td-&gt;td_retval[0];
          frame-&gt;tf_edx = td-&gt;td_retval[1];
          frame-&gt;tf_eflags &amp;= ~PSL_C;
          break;</p>

<p>else we handle the error
          frame-&gt;tf_eax = error;
          frame-&gt;tf_eflags |= PSL_C;
{% endcoderay %}</p>

<p>Now we fall back to assembly program from where this function was called.</p>

<p><br /><br /><br /><br /></p>

<p><a href="http://distkeys.com/blog/2014/08/04/debug-freebsd-open/" target="_blank">Continue to Open System Call</a></p>

<p><br /><br /><br /><br /></p>
]]></content>
  </entry>
  
</feed>

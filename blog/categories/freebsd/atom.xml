<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: FreeBSD | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/freebsd/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2015-01-02T21:34:19-08:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Virtual Memory in FreeBSD - Part 1]]></title>
    <link href="http://distkeys.com/blog/2015/01/02/virtual-memory1/"/>
    <updated>2015-01-02T20:25:00-08:00</updated>
    <id>http://distkeys.com/blog/2015/01/02/virtual-memory1</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#components-of-process-address-space">Components of Process Address Space</a></li>
  <li><a href="#code-walk">Code walk</a>    <ul>
      <li><a href="#header-files">Header files</a>        <ul>
          <li><a href="#vmmap">vm_map</a></li>
          <li><a href="#vmmapentry">vm_map_entry</a></li>
          <li><a href="#vm-object-types">VM object types</a></li>
          <li><a href="#vnodeobject">vnode/object</a></li>
          <li><a href="#vmpage-least-active-use-algorithm">vm_page (Least active use algorithm)</a></li>
          <li><a href="#page-fault-reasons">Page fault reasons</a></li>
          <li><a href="#memory-allocators">Memory Allocators</a></li>
          <li><a href="#call-graph-mmap">Call graph mmap</a></li>
          <li><a href="#mmap-system-call">mmap system call</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>In computing, virtual memory is a memory management technique that is implemented using both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory but it lacks code details.</p>

<p><a href="http://en.wikipedia.org/wiki/Virtual_memory">Read More</a></p>

<p>Recently, I have come across a very good <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">blog post</a> about virtual memory which explains in theory what is virtual memory and talk a bit about code</p>

<p><a href="http://www.amazon.com/gp/product/0321968972/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=1944687722&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=0201702452&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=08NPEVW6K146C5A7TE6P">The Design and Implementation of the FreeBSD Operating System</a> is an excellent book and this is the book I am reading, following and learning.</p>

<!-- more -->
<p><br /></p>

<p>This post is about the code level details of virtual memory explaining how the process address space is mapped and managed.</p>

<p>In this post, I will only be talking about user process address not about the kernel process address space. Both anyway uses same data structures.</p>

<p><br /></p>

<h1 id="components-of-process-address-space">Components of Process Address Space</h1>

<ol>
  <li>vm_map - Head of list of vm_map_entry <br /></li>
  <li>vm_pmap - Machine dependent stuff resides<br /></li>
  <li>stats - Paging Stats<br /></li>
  <li>vm_map_entry<br /></li>
  <li>vnode/object<br /></li>
  <li>vm_page<br /></li>
</ol>

<p><img src="/images/processAddressSpace.png" title="[processAddressSpace.png]" ></p>

<p><br /></p>

<p><strong><em>vm_map_entry</em></strong> has a peice of address space it has start and end of virtual addresses.</p>

<p><em>vm_map_entry</em> has pointer to vnode or object which could be a file, executable or swap object if it is mapping anon memory, it could be device if it mapping a frame buffer.</p>

<p><strong><em>obj offset</em></strong> - Object offset is the value which says where in vnode/object we should start referencing. Lets say if vnode/object is executable file then we will skip the header part and start with where text begins. </p>

<p><strong><em>The second vm_map_entry</em></strong> 
<br />
This block is for <strong><em>Initialized area</em></strong>. This map will refer to the same vode/object(executable file) but at different place(offset) where initialized data resides in executable file. So first vm_map_entry block and second vm_map_entry block refers to the same vnode/object(executable) but at different section(offset) in the same file.
If two processes are sharing memory then two process can refer to same offset. So, if one process changes something other can see the changes.</p>

<p><strong><em>Third vm_map_entry</em></strong>
<br />
For anon objects like uninitialized data, stack it will point to vnode/object which is swap object. Initially, when system comes up we don’t allocate any space for swap object and lazy approach is followed. When the vnode/object (swap object) is touched first time zero base page is created and we write into it but when we start getting crunch in memory then the paging demon comes and find the space for swap object in hard disk and performs the paging.</p>

<p><strong><em>vm_page</em></strong>
<br />
Each <em>vm_page</em> structure reference to each physical page in the machine. So if there is page of size 4K then there will be lot of pages in the system. For every 4K page there will be one vm_page structure so lets say if there are 100 pages in the system there will be 100 <em>vm_page</em> structure. It could consume lot of memory, so we try to keep structure <em>vm_page</em> as small as possible.</p>

<p>Every <em>vm_pages</em> is referenced by only one PART(not the whole vnode/object) of vnode/object. So looking at vm_page and it will say I am logical block number 100(or something) of this executable(vnode/object).</p>

<p>Pages are logical containers for process. So, when one process goes out and other comes in the same pages will be used by that process references section in vnode/object. So, vm_page can be referenced by multiple processes.</p>

<p>Now, in intialized area lets say we want to change some values in that case we will modifying the page but now same page can be referenced by multiple pages so, we create a copy of page called shadow object and we modify that page.</p>

<p>For vm_page there is a data structure called pvEntry. For each page pvEntry will map to physical address in <em>vm_pmap</em> area(machine dependent area).</p>

<p>We also maintain another data structure which maps all pvEntries associated with vnode/objects.</p>

<p>vnode/pbject -&gt; vm_page1 -&gt;pvEntry1<br />
                			-&gt; vm_page2 -&gt;pvEntry2<br />
			                …<br />
            			    …<br />
			                -&gt; vm_pageN -&gt;pvEntryN<br /></p>

<p>vnode/object -&gt; pvEntry1<br />
            			    …<br />
			                …<br />
            			    -&gt; pvEntryN<br /></p>

<p>Zero filled memory/Uninitialized object/Swap objects = Third vm_map_entry’s vnode/object</p>

<p><br /><br /></p>

<h1 id="code-walk">Code walk</h1>

<h2 id="header-files">Header files</h2>

<ul>
  <li>vm header file - vm_param.h <br /></li>
  <li>vm header file - vm.h <br /></li>
  <li>vm header file - vm_map.h <br /></li>
</ul>

<p><strong>VM protections</strong><br />
     #define     VM_PROT_NONE          ((vm_prot_t) 0x00)
     #define     VM_PROT_READ          ((vm_prot_t) 0x01)
     #define     VM_PROT_WRITE          ((vm_prot_t) 0x02)
     #define     VM_PROT_EXECUTE          ((vm_prot_t) 0x04)
     #define     VM_PROT_OVERRIDE_WRITE     ((vm_prot_t) 0x08)     /* copy-on-write */</p>

<p><br />
### vmspace</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vmspace  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> vmspace {
     <span style="color:#080;font-weight:bold">struct</span> vm_map vm_map;     <span style="color:#777">/* VM address map &lt;em&gt;/
     struct shmmap_state *vm_shm;     /&lt;/em&gt; SYS5 shared memory private data XXX &lt;em&gt;/
     segsz_t vm_swrss;     /&lt;/em&gt; resident set size before last swap &lt;em&gt;/
     segsz_t vm_tsize;     /&lt;/em&gt; text size (pages) XXX &lt;em&gt;/
     segsz_t vm_dsize;     /&lt;/em&gt; data size (pages) XXX &lt;em&gt;/
     segsz_t vm_ssize;     /&lt;/em&gt; stack size (pages) &lt;em&gt;/
     caddr_t vm_taddr;     /&lt;/em&gt; (c) user virtual address of text &lt;em&gt;/
     caddr_t vm_daddr;     /&lt;/em&gt; (c) user virtual address of data &lt;em&gt;/
     caddr_t vm_maxsaddr;     /&lt;/em&gt; user VA at max stack growth &lt;em&gt;/
     int     vm_refcnt;     /&lt;/em&gt; number of references &lt;em&gt;/
     /&lt;/em&gt;
      * Keep the PMAP last, so that CPU-specific variations of that
      * structure on a single architecture don’t result in offset
      * variations of the machine-independent fields in the vmspace.
      &lt;em&gt;/
     struct pmap vm_pmap;     /&lt;/em&gt; private physical map */</span>
};
</pre></div>
</div>
 </figure></notextile></div> 
<br /></p>

<h3 id="vmmap">vm_map</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vm_map  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> vm_map {
     <span style="color:#080;font-weight:bold">struct</span> vm_map_entry header;     <span style="color:#777">/* List of entries &lt;em&gt;/
     struct sx lock;               /&lt;/em&gt; Lock for map data &lt;em&gt;/
     struct mtx system_mtx;
     int nentries;               /&lt;/em&gt; Number of entries &lt;em&gt;/
     vm_size_t size;               /&lt;/em&gt; virtual size &lt;em&gt;/
     u_int timestamp;          /&lt;/em&gt; Version number &lt;em&gt;/
     u_char needs_wakeup;
     u_char system_map;          /&lt;/em&gt; (c) Am I a system map? &lt;em&gt;/
     vm_flags_t flags;          /&lt;/em&gt; flags for this vm_map &lt;em&gt;/
     vm_map_entry_t root;          /&lt;/em&gt; Root of a binary search tree &lt;em&gt;/
     pmap_t pmap;               /&lt;/em&gt; (c) Physical map &lt;em&gt;/
     vm_map_entry_t deferred_freelist;
#define     min_offset     header.start     /&lt;/em&gt; (c) &lt;em&gt;/
#define     max_offset     header.end     /&lt;/em&gt; (c) */</span>
};
</pre></div>
</div>
 </figure></notextile></div> 
<br /></p>

<h3 id="vmmapentry">vm_map_entry</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vm_map_entry  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> vm_map_entry {
     Store the vm_map_entry node in LL as well in the form of tree
     <span style="color:#080;font-weight:bold">struct</span> vm_map_entry &lt;em&gt;prev;     /&lt;/em&gt; previous entry &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> vm_map_entry *next;     /&lt;/em&gt; next entry &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> vm_map_entry *left;     /&lt;/em&gt; left child in binary search tree &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> vm_map_entry *right;     /&lt;/em&gt; right child in binary search tree */&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vm_offset_t start;          <span style="color:#777">/* start address */</span>
 vm_offset_t end;          <span style="color:#777">/* end address */</span>
 vm_offset_t avail_ssize;     <span style="color:#777">/* amt can grow if this is a stack */</span>

 vm_size_t adj_free;          <span style="color:#777">/* amount of adjacent free space */</span>
 vm_size_t max_free;          <span style="color:#777">/* max free space in subtree */</span>

 <span style="color:#080;font-weight:bold">union</span> vm_map_object object;     <span style="color:#777">/* object I point to */</span>
 vm_ooffset_t offset;          <span style="color:#777">/* offset into object */</span>

 vm_eflags_t eflags;          <span style="color:#777">/* map entry flags */</span>

 <span style="color:#777">//Read, write, execute etc...</span>
 vm_prot_t protection;          <span style="color:#777">/* protection code */</span>
 vm_prot_t max_protection;     <span style="color:#777">/* maximum protection */</span>
 vm_inherit_t inheritance;     <span style="color:#777">/* inheritance */</span>
 <span style="color:#0a8;font-weight:bold">int</span> wired_count;          <span style="color:#777">/* can be paged if = 0 */</span>
 vm_pindex_t lastr;          <span style="color:#777">/* last read */</span> }; </pre></div>
</div>
 </figure></notextile></div>  &lt;br&gt;
</code></pre>

<h3 id="vm-object-types">VM object types</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>VM objects  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
     <span style="color:#080;font-weight:bold">enum</span> obj_type { OBJT_DEFAULT, OBJT_SWAP, OBJT_VNODE, OBJT_DEVICE, OBJT_PHYS,
                                OBJT_DEAD };
</pre></div>
</div>
 </figure></notextile></div> 
<br /></p>

<h3 id="vnodeobject">vnode/object</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vnode  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> vm_object {
     <span style="color:#080;font-weight:bold">struct</span> mtx mtx;
     TAILQ_ENTRY(vm_object) object_list; <span style="color:#777">/* list of all objects &lt;em&gt;/
     LIST_HEAD(, vm_object) shadow_head; /&lt;/em&gt; objects that this is a shadow for &lt;em&gt;/
     LIST_ENTRY(vm_object) shadow_list; /&lt;/em&gt; chain of shadow objects &lt;em&gt;/
     TAILQ_HEAD(, vm_page) memq;     /&lt;/em&gt; list of resident pages &lt;em&gt;/
     vm_page_t root;               /&lt;/em&gt; root of the resident page splay tree &lt;em&gt;/
     vm_pindex_t size;          /&lt;/em&gt; Object size &lt;em&gt;/
     int generation;               /&lt;/em&gt; generation ID &lt;em&gt;/
     int ref_count;               /&lt;/em&gt; How many refs?? &lt;em&gt;/
     int shadow_count;          /&lt;/em&gt; how many objects that this is a shadow for */</span>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; objtype_t type;               <span style="color:#777">/* type of pager */</span>
 u_short flags;               <span style="color:#777">/* see below */</span>
 u_short pg_color;          <span style="color:#777">/* (c) color of first page in obj i.e. suerppage etc. */</span>
 u_short paging_in_progress;     <span style="color:#777">/* Paging (in or out) so don't collapse or destroy */</span>
 <span style="color:#0a8;font-weight:bold">int</span> resident_page_count;     <span style="color:#777">/* number of resident pages */</span>
 <span style="color:#080;font-weight:bold">struct</span> vm_object *backing_object; <span style="color:#777">/* object that I'm a shadow of */</span>
 vm_ooffset_t backing_object_offset;<span style="color:#777">/* Offset in backing object */</span>

 TAILQ_ENTRY(vm_object) pager_object_list; <span style="color:#777">/* list of all objects of this pager type */</span>
 LIST_HEAD(, vm_reserv) rvq;     <span style="color:#777">/* list of reservations */</span>
 vm_page_t cache;          <span style="color:#777">/* root of the cache page splay tree */</span>
 <span style="color:#088;font-weight:bold">void</span> *handle;
 <span style="color:#080;font-weight:bold">union</span> {
      <span style="color:#777">/*
       * VNode pager
       *
       *     vnp_size - current size of file
       */</span>
      <span style="color:#080;font-weight:bold">struct</span> {
           off_t vnp_size;
      } vnp;

      <span style="color:#777">/*
       * Device pager
       *
       *     devp_pglist - list of allocated pages
       */</span>
      <span style="color:#080;font-weight:bold">struct</span> {
           TAILQ_HEAD(, vm_page) devp_pglist;
      } devp;

      <span style="color:#777">/*
       * Swap pager
       *
       *     swp_bcount - number of swap 'swblock' metablocks, each
       *               contains up to 16 swapblk assignments.
       *               see vm/swap_pager.h
       */</span>
      <span style="color:#080;font-weight:bold">struct</span> {
           <span style="color:#0a8;font-weight:bold">int</span> swp_bcount;
      } swp;
 } un_pager; }; </pre></div>
</div>
 </figure></notextile></div>  &lt;br&gt;
</code></pre>

<h3 id="vmpage-least-active-use-algorithm">vm_page (Least active use algorithm)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vm_page  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> vm_page {
     TAILQ_ENTRY(vm_page) pageq;     <span style="color:#777">/* queue info for FIFO queue or free list (P) &lt;em&gt;/
     TAILQ_ENTRY(vm_page) listq;     /&lt;/em&gt; pages in same object (O)      &lt;em&gt;/
     struct vm_page *left;          /&lt;/em&gt; splay tree link (O)          &lt;em&gt;/
     struct vm_page *right;          /&lt;/em&gt; splay tree link (O)          */</span>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vm_object_t object;          <span style="color:#777">/* which object am I in (O,P)*/</span>
 vm_pindex_t pindex;          <span style="color:#777">/* offset into object (O,P) */</span>
 vm_paddr_t phys_addr;          <span style="color:#777">/* physical address of page */</span>
 <span style="color:#080;font-weight:bold">struct</span> md_page md;          <span style="color:#777">/* machine dependant stuff */</span>
 uint8_t     queue;               <span style="color:#777">/* page queue index */</span>
 int8_t segind;
 u_short     flags;               <span style="color:#777">/* see below */</span>
 uint8_t     order;               <span style="color:#777">/* index of the buddy queue */</span>
 uint8_t pool;
 u_short cow;               <span style="color:#777">/* page cow mapping count */</span>
 u_int wire_count;          <span style="color:#777">/* wired down maps refs (P) */</span>
 <span style="color:#0a8;font-weight:bold">short</span> hold_count;          <span style="color:#777">/* page hold count */</span>
 u_short oflags;               <span style="color:#777">/* page flags (O) */</span>
 u_char     act_count;          <span style="color:#777">/* page usage count, Page active count */</span>
 u_char     busy;               <span style="color:#777">/* page busy count (O) */</span>
 <span style="color:#777">/* NOTE that these must support one bit per DEV_BSIZE in a page!!! */</span>
 <span style="color:#777">/* so, on normal X86 kernels, they must be at least 8 bits wide */</span> <span style="color:#579">#if</span> PAGE_SIZE == <span style="color:#00D">4096</span>
 u_char     valid;               <span style="color:#777">/* map of valid DEV_BSIZE chunks (O) */</span>
 u_char     dirty;               <span style="color:#777">/* map of dirty DEV_BSIZE chunks */</span> <span style="color:#579">#elif</span> PAGE_SIZE == <span style="color:#00D">8192</span>
 u_short     valid;               <span style="color:#777">/* map of valid DEV_BSIZE chunks (O) */</span>
 u_short     dirty;               <span style="color:#777">/* map of dirty DEV_BSIZE chunks */</span> <span style="color:#579">#elif</span> PAGE_SIZE == <span style="color:#00D">16384</span>
 u_int valid;               <span style="color:#777">/* map of valid DEV_BSIZE chunks (O) */</span>
 u_int dirty;               <span style="color:#777">/* map of dirty DEV_BSIZE chunks */</span> <span style="color:#579">#elif</span> PAGE_SIZE == <span style="color:#00D">32768</span>
 u_long valid;               <span style="color:#777">/* map of valid DEV_BSIZE chunks (O) */</span>
 u_long dirty;               <span style="color:#777">/* map of dirty DEV_BSIZE chunks */</span> <span style="color:#579">#endif</span> }; </pre></div>
</div>
 </figure></notextile></div>  &lt;br&gt;
</code></pre>

<h3 id="page-fault-reasons">Page fault reasons</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Page fault reasons  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#579">#define</span> PGEX_P          <span style="color:#02b">0x01</span>     <span style="color:#777">/* Protection violation vs. not present &lt;em&gt;/
#define PGEX_W          0x02     /&lt;/em&gt; during a Write cycle &lt;em&gt;/
#define PGEX_U          0x04     /&lt;/em&gt; access from User mode (UPL) &lt;em&gt;/
#define PGEX_RSV     0x08     /&lt;/em&gt; reserved PTE field is non-zero &lt;em&gt;/
#define PGEX_I          0x10     /&lt;/em&gt; during an instruction fetch */</span>
</pre></div>
</div>
 </figure></notextile></div> 
<br /></p>

<h3 id="memory-allocators">Memory Allocators</h3>

<p>uma.h - Universal memory allocator</p>

<p><br /></p>

<h3 id="call-graph-mmap">Call graph mmap</h3>

<p><img src="/images/mmap.png" title="[mmap.png]" ></p>

<p><br /></p>

<h3 id="mmap-system-call">mmap system call</h3>

<p>Maps files or devices into memory<br />
<em>mmap()</em> creates a new mapping in the virtual address space of the calling process.  The starting address for the new mapping is specified in addr.  The length argument specifies the length of the mapping.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>mmap  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> mmap_args {
     <span style="color:#088;font-weight:bold">void</span> *addr; ===&amp;gt; File segment address needs to be placed in address space
     size_t len;
     <span style="color:#0a8;font-weight:bold">int</span> prot; <span style="color:#777">// Protection</span>
     <span style="color:#0a8;font-weight:bold">int</span> flags;
     <span style="color:#0a8;font-weight:bold">int</span> fd;
     <span style="color:#0a8;font-weight:bold">long</span> pad;
     off_t pos;   <span style="color:#777">// We can map some part of file into memory</span>
};&lt;/p&gt;

&lt;p&gt;Function mmap(td, uap)
     <span style="color:#080;font-weight:bold">struct</span> thread *td;
     <span style="color:#080;font-weight:bold">struct</span> mmap_args *uap;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; addr = (vm_offset_t) uap-&amp;gt;addr;
 size = uap-&amp;gt;len;
 prot = uap-&amp;gt;prot &amp;amp; VM_PROT_ALL;
 flags = uap-&amp;gt;flags;
 pos = uap-&amp;gt;pos;

 ...
 Sanity checking of inputs
 ...

 If we are mapping in uninitialized area
 ...

 If we are mapping in swap area
 ...

 If we are mapping file area
 get file pointer
 <span style="color:#080;font-weight:bold">if</span> ((error = fget(td, uap-&amp;gt;fd, &amp;amp;fp)) != <span style="color:#00D">0</span>) {
      ...
 }

 ...
 ...

 Vode associated with file pointer
 vp = fp-&amp;gt;f_vnode;

 Assign memory protection i.e. read, write, execute etc.
 <span style="color:#080;font-weight:bold">if</span> (vp-&amp;gt;v_mount != <span style="color:#069">NULL</span> &amp;amp;&amp;amp; vp-&amp;gt;v_mount-&amp;gt;mnt_flag &amp;amp; MNT_NOEXEC)
           maxprot = VM_PROT_NONE;
      <span style="color:#080;font-weight:bold">else</span>
           maxprot = VM_PROT_EXECUTE;
      <span style="color:#080;font-weight:bold">if</span> (fp-&amp;gt;f_flag &amp;amp; FREAD) {
           maxprot |= VM_PROT_READ;
      } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (prot &amp;amp; PROT_READ) {
           error = EACCES;
           <span style="color:#080;font-weight:bold">goto</span> done;
 }

 For shared memory, protection should be write
 <span style="color:#080;font-weight:bold">if</span> ((flags &amp;amp; MAP_SHARED) != <span style="color:#00D">0</span>) {
           <span style="color:#080;font-weight:bold">if</span> ((fp-&amp;gt;f_flag &amp;amp; FWRITE) != <span style="color:#00D">0</span>) {
                maxprot |= VM_PROT_WRITE;
                ...
           }
      ...
 }

 handle = (<span style="color:#088;font-weight:bold">void</span> *)vp;
 handle_type = OBJT_VNODE;
 td-&amp;gt;td_fpop = fp;

 error = vm_mmap(&amp;amp;vms-&amp;gt;vm_map, &amp;amp;addr, size, prot, maxprot,
                    flags, handle_type, handle, pos);

 ...
 td-&amp;gt;td_retval[<span style="color:#00D">0</span>] = (register_t) (addr + pageoff);
 ...                       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div> </p>

<p><br /></p>

<p>mmap is just a wrapper around vm_mmap()</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vm_mmap  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Function vm_mmap()
{
     <span style="color:#F00;background-color:#FAA">…</span>
     Sanity Checking
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; <span style="color:#080;font-weight:bold">switch</span> (handle_type) {
      <span style="color:#080;font-weight:bold">case</span> OBJT_DEVICE:
           ...
           ...
      <span style="color:#080;font-weight:bold">case</span> OBJT_VNODE:
           error = vm_mmap_vnode(td, size, prot, &amp;amp;maxprot, &amp;amp;flags,
                                      handle, foff, &amp;amp;object);
           <span style="color:#080;font-weight:bold">break</span>;
      <span style="color:#080;font-weight:bold">case</span> OBJT_SWAP:
           error = vm_mmap_shm(td, size, prot, &amp;amp;maxprot, &amp;amp;flags,
                                    handle, foff, &amp;amp;object);

           ....
 }

      Our <span style="color:#080;font-weight:bold">case</span> is OBJT_VNODE, vp = handle
      Function vm_mmap_vnode() {
           ...
           ...
           Get a ref on vnode
           vfslocked = VFS_LOCK_GIANT(mp);
           <span style="color:#080;font-weight:bold">if</span> ((error = vget(vp, LK_SHARED, td)) != <span style="color:#00D">0</span>) {
                ..
           }

           obj = vp-&amp;gt;v_object;
           type = OBJT_VNODE;
           handle = vp;
           ...
           ...

           Getattr <span style="color:#080;font-weight:bold">for</span> vnode
           error = VOP_GETATTR(vp, &amp;amp;va, cred)
           ...
           ...
           obj = vm_pager_allocate(type, handle, objsize, prot, foff);
                     Function vm_pager_allocate() {
                          This function allocates the instance of a pager of given type
                          ...
                          ...
                          ops = pagertab[type];
                          <span style="color:#777">/*
                               struct pagerops *pagertab[] = {
                                    ...
                                    &amp;amp;vnodepagerops,          /* OBJT_VNODE */</span>
                                    ...
                               }

                               <span style="color:#080;font-weight:bold">struct</span> pagerops vnodepagerops = {
                                    .pgo_alloc =     vnode_pager_alloc,
                                    ...
                                    ...
                               }
                          */

                          <span style="color:#080;font-weight:bold">if</span> (ops)
                               ret = (*ops-&amp;gt;pgo_alloc) (handle, size, prot, off);

                               <span style="color:#777">//So we are going to call vnode_pager_alloc()</span>
                                    Function vnode_pager_alloc()
                                    {
                                         <span style="color:#777">//Allocates pager for a vnode</span>
                                         vp = (<span style="color:#080;font-weight:bold">struct</span> vnode *) handle;

                                         ...

                                         object = vm_object_allocate(OBJT_VNODE, OFF_TO_IDX(round_page(size)));
                                         ...
                                         vref(vp);
                                    } <span style="color:#777">//end of vnode_pager_alloc()</span>
                          }
                     } <span style="color:#777">// end of vm_pager_allocate()</span>

           vput(vp);
           VFS_UNLOCK_GIANT(vfslocked);

      } <span style="color:#777">//end vm_mmap_vnode()</span>


 So far we have allocated vm_page, vnode. Now, we need to allocate vm_map_entry and put it in
 appropriate data structure
 <span style="color:#080;font-weight:bold">if</span> (flags &amp;amp; MAP_STACK)
      rv = vm_map_stack(map, *addr, size, prot, maxprot,
          docow | MAP_STACK_GROWS_DOWN);
 <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (fitit)
      <span style="color:#777">// Try to find it above tje addr</span>
      rv = vm_map_find(map, object, foff, addr, size,
          object != <span style="color:#069">NULL</span> &amp;amp;&amp;amp; object-&amp;gt;type == OBJT_DEVICE ?
          VMFS_ALIGNED_SPACE : VMFS_ANY_SPACE, prot, maxprot, docow);
 <span style="color:#080;font-weight:bold">else</span>
      rv = vm_map_fixed(map, object, foff, *addr, size,
                 prot, maxprot, docow);

 ...
 ...
 ... } </pre></div>
</div>
 </figure></notextile></div> 
</code></pre>

<p><br /></p>

<p>vm_map_find finds an unallocated region in the target address
map with the given length.  The search is defined to be
first-fit from the specified address; the region found is
returned in the same parameter.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vm_map_find  </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Function vm_map_find(vm_map_t map, vm_object_t object, vm_ooffset_t offset,
                          vm_offset_t &lt;em&gt;addr,     /&lt;/em&gt; IN/OUT */
                          vm_size_t length, <span style="color:#0a8;font-weight:bold">int</span> find_space, vm_prot_t prot,
                          vm_prot_t max, <span style="color:#0a8;font-weight:bold">int</span> cow)
{
     Find space in a vm_map&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; start = *addr;

 vm_map_findspace(map, start, length, addr)

           Find the first <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">fit</span><span style="color:#710">&quot;</span></span> (lowest VM address) <span style="color:#080;font-weight:bold">for</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">length</span><span style="color:#710">&quot;</span></span> free bytes
           beginning at address &amp;gt;= start in the given map. This function returns
           the address (addr). This addr is not associated with vm_map entry.
          
           Function vm_map_findspace(vm_map_t map, vm_offset_t start, vm_size_t length,
                                           vm_offset_t *addr)
           {
                We have min/max of VM addresses, request must be within that range

                For the very first time when process boots up,
                there are no blocks in VM address space <span style="color:#080;font-weight:bold">for</span> process
                <span style="color:#080;font-weight:bold">if</span> (map-&amp;gt;root == <span style="color:#069">NULL</span>) {
                     *addr = start;
                     <span style="color:#080;font-weight:bold">goto</span> found;
                }

                ...
                ...
                Find the entry into tree where we can fit our entry into vm_entry_map
                     <span style="color:#080;font-weight:bold">while</span> (entry != <span style="color:#069">NULL</span>) {
                          <span style="color:#080;font-weight:bold">if</span> (entry-&amp;gt;left != <span style="color:#069">NULL</span> &amp;amp;&amp;amp; entry-&amp;gt;left-&amp;gt;max_free &amp;gt;= length)
                               entry = entry-&amp;gt;left;
                          <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (entry-&amp;gt;adj_free &amp;gt;= length) {
                               *addr = entry-&amp;gt;end;
                               <span style="color:#080;font-weight:bold">goto</span> found;
                          } <span style="color:#080;font-weight:bold">else</span>
                               entry = entry-&amp;gt;right;
                     }
                     ...
                     ...
           } <span style="color:#777">// end of vm_map_findspace()</span>
 ...
 ...

 Insert into vm_map (vm_map.c)
 result = vm_map_insert(map, object, offset, start, start +
                            length, prot, max, cow);

 So, we have pager, address in the vm_map list where we can we can insert vm_map_entry
 but we have not yet created allocated vm_map_entry. So, function vm_map_insert()
 will create the vm_map_entry and insert into vm_map

      <span style="color:#777">// Here start will have the addr value</span>
      Function vm_map_insert(vm_map_t map, vm_object_t object, vm_ooffset_t offset,
       vm_offset_t start, vm_offset_t end, vm_prot_t prot, vm_prot_t max,
       <span style="color:#0a8;font-weight:bold">int</span> cow)
     {
          ...
          Sanity Checking
          ...

          Lookup entry in the tree. Since, we already have address in the tree all we are doing
          here is given the address find where we are in that respect. Are we ahead or behind?
         
          vm_map_lookup_entry(map, start, &amp;amp;temp_entry)

          ...
          ...

          If we have request of extending the object/vnode. Lets say <span style="color:#080;font-weight:bold">if</span> we malloc then we need to
          extend the initialized area. Function vm_object_coalesce() will try to grow the object
          <span style="color:#080;font-weight:bold">if</span> (.... || vm_object_coalesce(...)) {
               ...
          }

          <span style="color:#777">//Create a new vm_map_entry</span>
          new_entry = vm_map_entry_create(map);

          Initialize the new_entry
          new_entry-&amp;gt;start = start;
           new_entry-&amp;gt;end = end;

           new_entry-&amp;gt;eflags = protoeflags;
           new_entry-&amp;gt;object.vm_object = object;
           new_entry-&amp;gt;offset = offset;

           <span style="color:#777">//Since its not a stack so size is 0</span>
           new_entry-&amp;gt;avail_ssize = <span style="color:#00D">0</span>;

           new_entry-&amp;gt;inheritance = VM_INHERIT_DEFAULT;
           new_entry-&amp;gt;protection = prot;
           new_entry-&amp;gt;max_protection = max;
           new_entry-&amp;gt;wired_count = <span style="color:#00D">0</span>;

           <span style="color:#777">//Inser new vm_map_entry into list</span>
           vm_map_entry_link(map, prev_entry, new_entry);

           <span style="color:#777">//Enter the vm_map_entry in pmap which is machine dependent part</span>
           vm_map_pmap_enter(map, start, prot,object, OFF_TO_IDX(offset), end - start,
                                 cow &amp;amp; MAP_PREFAULT_PARTIAL);

     } <span style="color:#777">//end vm_map_insert()</span>
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} <span style="color:#777">//end vm_map_find</span>
</pre></div>
</div>
 </figure></notextile></div> </p>

<p><br /></p>

<p>One lock for active &amp; inactive list<br />
Active list<br />
Inactive list<br /></p>

<p>One lock for cache and free list<br />
Cache list - Pages moves from Inactive list to cache list<br />
Free list - Pages moves from Cache list to free list<br /></p>

<p><br /><br /><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Signal code in FreeBSD]]></title>
    <link href="http://distkeys.com/blog/2014/12/31/signal-code-in-freebsd/"/>
    <updated>2014-12-31T13:00:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/12/31/signal-code-in-freebsd</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#kill-system-call">Kill System Call</a></li>
  <li><a href="#post-signal">Post Signal</a></li>
  <li><a href="#signal-delivery">Signal Delivery</a></li>
</ul>

<p>Signals are a limited form of inter-process communication used in Unix, Unix-like, and other POSIX-compliant operating systems. A signal is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred. Signals have been around since the 1970s Bell Labs Unix and have been more recently specified in the POSIX standard.</p>

<p><a href="http://en.wikipedia.org/wiki/Unix_signal">Read More</a></p>

<!-- more -->
<p><br /></p>

<h2 id="kill-system-call">Kill System Call</h2>
<p>kill - send signal to a process </p>

<blockquote>
  <p>int kill(pid_t pid, int sig);</p>
</blockquote>

<p>The kill() system call can be used to send any signal to any process group or process. </p>

<p><strong>If pid is greater than zero:</strong> <br />
 The sig signal is sent to the process whose ID is equal to pid.</p>

<p><strong>If pid is zero:</strong>  <br />
 The sig signal is sent to all processes whose group ID is equal
 to the process group ID of the sender, and for which the process
 has permission; this is a variant of killpg(2).</p>

<p><strong>If pid is -1:</strong>  <br />
 If the user has super-user privileges, the signal is sent to all
 processes excluding system processes (with P_SYSTEM flag set),
 process with ID 1 (usually init(8)), and the process sending the
 signal.  If the user is not the super user, the signal is sent to
 all processes with the same uid as the user excluding the process
 sending the signal.  No error is returned if any process could be
 signaled.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Function Kill() </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Argument to Kill system call (kern_sig.c)
<span style="color:#080;font-weight:bold">struct</span> kill_args {
     <span style="color:#0a8;font-weight:bold">int</span> pid;
     <span style="color:#0a8;font-weight:bold">int</span> signum;
};&lt;/p&gt;

&lt;p&gt;If process id is greater than <span style="color:#00D">0</span> then signal has to be send to that particular process <span style="color:#080;font-weight:bold">else</span> it is either broadcast
signal or own process group etc.&lt;/p&gt;

&lt;p&gt;<span style="color:#777">// If process id  &amp;gt; 0</span>
<span style="color:#080;font-weight:bold">if</span> (uap-&amp;gt;pid &amp;gt; <span style="color:#00D">0</span>) {
     Find the process
     <span style="color:#080;font-weight:bold">if</span> ((p = pfind(uap-&amp;gt;pid)) == <span style="color:#069">NULL</span>) {
          If its a zombie process
          <span style="color:#080;font-weight:bold">if</span> ((p = zpfind(uap-&amp;gt;pid)) == <span style="color:#069">NULL</span>) {
               <span style="color:#080;font-weight:bold">return</span> (ESRCH);
          }
     }
}&lt;/p&gt;

&lt;p&gt;Determine <span style="color:#080;font-weight:bold">if</span> we can send the signal to process &lt;/p&gt;

&lt;p&gt;error = p_cansignal(td, p, uap-&amp;gt;signum);&lt;/p&gt;

&lt;p&gt;In Function p_cansignal(). This function will determine <span style="color:#080;font-weight:bold">if</span> thread can send signal to processes
cr_cansignal(<span style="color:#080;font-weight:bold">struct</span> ucred *cred, <span style="color:#080;font-weight:bold">struct</span> proc *proc, <span style="color:#0a8;font-weight:bold">int</span> signum)
{
     Check <span style="color:#080;font-weight:bold">if</span> process to whom signal is to be send is in Jail semantics&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Check the creds i.e. otherUids, otherGids

 Allow only following signals, <span style="color:#080;font-weight:bold">for</span> other signals needs special privs
      <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">0</span>:
      <span style="color:#080;font-weight:bold">case</span> SIGKILL:
      <span style="color:#080;font-weight:bold">case</span> SIGINT:
      <span style="color:#080;font-weight:bold">case</span> SIGTERM:
      <span style="color:#080;font-weight:bold">case</span> SIGALRM:
      <span style="color:#080;font-weight:bold">case</span> SIGSTOP:
      <span style="color:#080;font-weight:bold">case</span> SIGTTIN:
      <span style="color:#080;font-weight:bold">case</span> SIGTTOU:
      <span style="color:#080;font-weight:bold">case</span> SIGTSTP:
      <span style="color:#080;font-weight:bold">case</span> SIGHUP:
      <span style="color:#080;font-weight:bold">case</span> SIGUSR1:
      <span style="color:#080;font-weight:bold">case</span> SIGUSR2:
           <span style="color:#080;font-weight:bold">break</span>;
      <span style="color:#080;font-weight:bold">default</span>:
           Need priv

 More priv checks

 Finally yes you can send signal }    </pre></div>
</div>
 </figure></notextile></div>  &lt;br&gt;
</code></pre>

<p><img src="/images/kill1.png" title="[kill1.png]" >
<br /><br /></p>

<h1 id="post-signal">Post Signal</h1>
<p>If we are allowed to send signal to other process then send the signal</p>

<p>Now, it can happen that in multiprocessor env other process may be running or may not. So, we post the signal and when the process come to life it will receive the signal and act appropriately.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Function Post Signal </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#777">//Post signal</span>
psignal(p, uap-&amp;gt;signum);
Function tdsignal(<span style="color:#080;font-weight:bold">struct</span> proc &lt;em&gt;p, <span style="color:#080;font-weight:bold">struct</span> thread *td, <span style="color:#0a8;font-weight:bold">int</span> sig, ksiginfo_t *ksi)
{
     Determine the property of signal
     <span style="color:#777">//Signal property table is in kern_sig.c </span>
     <span style="color:#777">// #define     SA_KILL          0x01          /&lt;/em&gt; terminates process by default &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_CORE          0x02          /&lt;/em&gt; ditto and coredumps &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_STOP          0x04          /&lt;/em&gt; suspend process &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_TTYSTOP     0x08          /&lt;/em&gt; ditto, from tty &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_IGNORE     0x10          /&lt;/em&gt; ignore by default &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_CONT          0x20          /&lt;/em&gt; continue if suspended &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_CANTMASK     0x40          /&lt;/em&gt; non-maskable, catchable &lt;em&gt;/</span>
     <span style="color:#777">// #define     SA_PROC          0x80          /&lt;/em&gt; deliverable to any thread */</span>
     <span style="color:#777">//static int sigproptbl[NSIG]&lt;/p&gt;</span>

&lt;pre&gt;&lt;code&gt; Post Signal to thread in a process
 td = sigtd(p, sig, prop);    
 Function sigtd(<span style="color:#080;font-weight:bold">struct</span> proc *p, <span style="color:#0a8;font-weight:bold">int</span> sig, <span style="color:#0a8;font-weight:bold">int</span> prop) {
      Check <span style="color:#080;font-weight:bold">if</span> we are current process
      For each thread in process check <span style="color:#080;font-weight:bold">if</span> thread is registered <span style="color:#080;font-weight:bold">for</span> signal handling

      If we can<span style="color:#F00;background-color:#FAA">’</span>t find any thread to post signal then just pick the first thread in process
      <span style="color:#080;font-weight:bold">return</span> the thread pointer
 }

 So far, we have signal to post and the thread pointer where to post
 There is a signal queue. So get the pointer to signal queue. 
 There are <span style="color:#00D">2</span> signal queues 
      <span style="color:#60E">1</span>. Signal queue <span style="color:#080;font-weight:bold">for</span> process
      <span style="color:#60E">2</span>. Signal queue <span style="color:#080;font-weight:bold">for</span> thread

 <span style="color:#080;font-weight:bold">if</span> (SIGISMEMBER(td-&amp;gt;td_sigmask, sig))
           sigqueue = &amp;amp;p-&amp;gt;p_sigqueue;
 <span style="color:#080;font-weight:bold">else</span>
           sigqueue = &amp;amp;td-&amp;gt;td_sigqueue;

 Check <span style="color:#080;font-weight:bold">if</span> the signal we will be sending is in our ignore list. If it is in our ignore list then <span style="color:#080;font-weight:bold">do</span> not
 process further and drop it

 We will now check the preferences/flags marked in the target thread regarding signals
 It can happen that thread have masked all the signals right now i.e. thread may be processing some signal
 and want all other signals to hold until it finishes processing
 <span style="color:#080;font-weight:bold">if</span> (SIGISMEMBER(td-&amp;gt;td_sigmask, sig))
      action = SIG_HOLD;   

 If signal is <span style="color:#088;font-weight:bold">register</span> to be catch
 <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (SIGISMEMBER(ps-&amp;gt;ps_sigcatch, sig))
     action = SIG_CATCH;

 Check the property of Signal
 If property of signal is to <span style="color:#080;font-weight:bold">continue</span> then go through signal queue and delete the signal which will stop
 the execution
 <span style="color:#080;font-weight:bold">if</span> (prop &amp;amp; SA_CONT)
      sigqueue_delete_stopmask_proc(p);
 <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span> (prop &amp;amp; SA_STOP) {
      <span style="color:#777">// Stop running the process</span>

 Finally, Add the signal to the signal queue
 ret = sigqueue_add(sigqueue, sig, ksi);
 
 Notify thread that Signal has been posted
 signotify(td);
 In function signotify() we check that what are all the pending signals <span style="color:#080;font-weight:bold">for</span> the thread and <span style="color:#080;font-weight:bold">for</span> which
 signal handler have not masked that means target thread signal handler wants to accept that signal.
 Then we enable the flags so that the target thread can to running state <span style="color:#080;font-weight:bold">if</span> suspended and when awake
 knows that some signal is posted <span style="color:#080;font-weight:bold">for</span> the thread
 td-&amp;gt;td_flags |= TDF_NEEDSIGCHK | TDF_ASTPENDING;

 ...
 
 If target process is in sleep state or sleep interruptible state then wake it up
 tdsigwakeup(td, sig, action, intrval);
           Function tdsigwakeup()     
           {
                bump up the thread priority
                sched_prio(td, PUSER);

                If thread is in the sleep queue and interruptible
                then wakeup the thread
                wakeup_swapper = sleepq_abort(td, intrval);
                              Function sleepq_abort(<span style="color:#080;font-weight:bold">struct</span> thread *td, <span style="color:#0a8;font-weight:bold">int</span> intrval) {
                                     ...
                                     ...
                                    Enable thread flags
                                    td-&amp;gt;td_intrval = intrval;
                                    td-&amp;gt;td_flags |= TDF_SLEEPABORT; 
                                    ...
                                    get the thread wait channel
                                    wchan = td-&amp;gt;td_wchan;

                                    Sleep queue of wait channel where thread resides currently when sleeping
                                    sq = sleepq_lookup(wchan);

                                    <span style="color:#777">//Wake up the thread </span>
                                    <span style="color:#080;font-weight:bold">return</span> (sleepq_resume_thread(sq, td, <span style="color:#00D">0</span>));
                                                         Whole idea is that there is a hash of all the wait channel We have already <span style="color:#080;font-weight:bold">for</span> the wait channel and now there are all the processes waiting on this wait channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;<span style="color:#777">//Removes a thread from a sleep queue and makes it runnable</span>
Function sleepq_resume_thread(<span style="color:#080;font-weight:bold">struct</span> sleepqueue *sq, <span style="color:#080;font-weight:bold">struct</span> thread *td, <span style="color:#0a8;font-weight:bold">int</span> pri) {
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     Remove process/thread from wait channel
     TAILQ_REMOVE(&amp;amp;sq-&amp;gt;sq_blocked[td-&amp;gt;td_sqqueue], td, td_slpq);
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Clear the sleeping flag and set it runnable
 <span style="color:#080;font-weight:bold">if</span> (TD_IS_SLEEPING(td)) {
      TD_CLR_SLEEPING(td);
      <span style="color:#080;font-weight:bold">return</span> (setrunnable(td));
                          Function setrunnable(<span style="color:#080;font-weight:bold">struct</span> thread *td)
      {
          
           ...
           ...
     
           sched_wakeup(td);
                Function sched_wakeup(<span style="color:#080;font-weight:bold">struct</span> thread *td) {    ====&amp;gt; sched_ule.c
                     This function let schedular know that thread needs to resume
                     ...
                     ...
                     sched_add()
                }
      } <span style="color:#777">// end setrunnable</span>
 } <span style="color:#777">// end sleepq_resume_thread</span>
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} <span style="color:#777">// end sleepq_resume_thread&lt;/p&gt;</span>

&lt;pre&gt;&lt;code&gt;                               } <span style="color:#777">// end sleepq_abort</span>
           } <span style="color:#777">//end tdsigwakeup() } // end tdsignal </span></pre></div>
</div>
 </figure></notextile></div> 
</code></pre>

<p><br /></p>

<p><img src="/images/kill2.png" title="[kill2.png]" ></p>

<p><br /></p>

<hr style="border-top: 1.5px dotted black" />

<p><br /></p>

<h1 id="signal-delivery">Signal Delivery</h1>

<p>So far, in above processing we have loaded the target process to to the run queue and eventually our process run time slice will over and now another process will run.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Signal Delivery </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
The <span style="color:#080;font-weight:bold">switch</span> of process will happen at 
Function mi_switch
<span style="color:#777">// The machine independent parts of context switching.&lt;/p&gt;</span>

&lt;p&gt;Function mi_switch(<span style="color:#0a8;font-weight:bold">int</span> flags, <span style="color:#080;font-weight:bold">struct</span> thread *newtd)
{
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#777">// Schedular come into the picture to switch the thread</span>
     sched_switch(td, newtd, flags);
               Function sched_switch(<span style="color:#080;font-weight:bold">struct</span> thread *td, <span style="color:#080;font-weight:bold">struct</span> thread *newtd, <span style="color:#0a8;font-weight:bold">int</span> flags)
               {
                    Save information related to thread before context switching
                    cpuid = PCPU_GET(cpuid);
                    tdq = TDQ_CPU(cpuid);
                    ts = td-&amp;gt;td_sched;
                    mtx = td-&amp;gt;td_lock;
                    ts-&amp;gt;ts_rltick = ticks;
                    td-&amp;gt;td_lastcpu = td-&amp;gt;td_oncpu;
                    td-&amp;gt;td_oncpu = NOCPU;
                    td-&amp;gt;td_flags &amp;amp;= ~TDF_NEEDRESCHED;
                    td-&amp;gt;td_owepreempt = <span style="color:#00D">0</span>;
                    tdq-&amp;gt;tdq_switchcnt++;
                    <span style="color:#F00;background-color:#FAA">…</span>
                    <span style="color:#F00;background-color:#FAA">…</span>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                choose new thread to run
                newtd = choosethread();
                     Function choosethread() {
                          ...
                          td = sched_choose();
                               Function sched_choose() {
                                    Choose next high priority thread to run from the same CPU
                                    tdq = TDQ_SELF();
                                    td = tdq_choose(tdq);
                                         Function tdq_choose(<span style="color:#080;font-weight:bold">struct</span> tdq *tdq) {
                                              Pick the thread from realtime thread queue
                                              td = runq_choose(&amp;amp;tdq-&amp;gt;tdq_realtime);

                                              If its <span style="color:#069">NULL</span>, then pick from Timshare queue
                                              td = runq_choose_from(&amp;amp;tdq-&amp;gt;tdq_timeshare, tdq-&amp;gt;tdq_ridx);

                                              If its <span style="color:#069">NULL</span>, then pick from Idle queue
                                              td = runq_choose(&amp;amp;tdq-&amp;gt;tdq_idle);
                                                        In function runq_choose we simply go to queue and get the
                                                        first item from the queue

                                         } <span style="color:#777">//end tdq_choose</span>

                                    ...
                                    <span style="color:#080;font-weight:bold">return</span> the thread    

                               } <span style="color:#777">//end sched_choose</span>
                     } <span style="color:#777">//end choosethread</span>

                So, newtd is the newthread we choose to run
                This function will <span style="color:#080;font-weight:bold">switch</span> the threads and newtd will be running after this function call
                This function is a assembly level code
                cpu_switch(td, newtd, mtx);    

           } <span style="color:#777">//end sched_switch } //end mi_switch</span>
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have target thread running.
When we were posting the signal we enabled the flag TDF_ASTPENDING in function
     signotify(td);
     In function signotify() we check that what are all the pending signals <span style="color:#080;font-weight:bold">for</span> the thread and <span style="color:#080;font-weight:bold">for</span> which signal
     handler have not masked that means target thread signal handler wants to accept that signal.
     Then we enable the flags so that the target thread can to running state <span style="color:#080;font-weight:bold">if</span> suspended and when awake
     knows that some signal is posted <span style="color:#080;font-weight:bold">for</span> the thread&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; td-&amp;gt;td_flags |= TDF_NEEDSIGCHK | TDF_ASTPENDING;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since, this flag is enable when the target process comes into like it will check this flag and <span style="color:#080;font-weight:bold">if</span> it is enable
then it will call function AST (Asynchronous software trap)
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /></p>

<p><img src="/images/ast.png" title="[ast.png]" ></p>

<p><br /></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Function ast() </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Function ast(<span style="color:#080;font-weight:bold">struct</span> trapframe *framep)
{
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     Check <span style="color:#080;font-weight:bold">if</span> any signals are posted
     <span style="color:#080;font-weight:bold">if</span> (flags &amp;amp; TDF_NEEDSIGCHK) {
          PROC_LOCK(p);
          mtx_lock(&amp;amp;p-&amp;gt;p_sigacts-&amp;gt;ps_mtx);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      This function will get the signal posted and which is unmasked
      We will process all the pending signals one-by-one
      <span style="color:#080;font-weight:bold">while</span> ((sig = cursig(td)) != <span style="color:#00D">0</span>)
           postsig(sig);
           mtx_unlock(&amp;amp;p-&amp;gt;p_sigacts-&amp;gt;ps_mtx);
           PROC_UNLOCK(p);

                Function cursig(<span style="color:#080;font-weight:bold">struct</span> thread *td) {
                     ...

                     Return <span style="color:#080;font-weight:bold">if</span> there is signal to process or <span style="color:#00D">0</span> when nothing to process
                     <span style="color:#080;font-weight:bold">return</span> (SIGPENDING(td) ? issignal(td) : <span style="color:#00D">0</span>);
                               Function issignal(td) {
                                    Find any pending signal
                                    sigpending = td-&amp;gt;td_sigqueue.sq_signals;

                                    Get first pending signal
                                    sig = sig_ffs(&amp;amp;sigpending);

                                    Handle special cases of SIGSTOP or SIGCONT

                                    Get properties of signal
                                    prop = sigprop(sig);

                                    Handle other cases i.e. Default Signal, Ignore Signal etc

                                    <span style="color:#080;font-weight:bold">return</span> signal
                               } <span style="color:#777">//end of issignal(td)                                  </span>
                } <span style="color:#777">//end of cursig(struct thread *td)</span>


                <span style="color:#777">// This function take action for specified signal</span>
                Function postsig(sig) {
                     <span style="color:#088;font-weight:bold">register</span> <span style="color:#080;font-weight:bold">struct</span> proc *p = td-&amp;gt;td_proc;
                     ...
                     ...
                     Get signal action
                     action = ps-&amp;gt;ps_sigact[_SIG_IDX(sig)];

                     Now we will check action and process accordingly
                     <span style="color:#777">//Default action which is kill the process</span>
                     <span style="color:#080;font-weight:bold">if</span> (action == SIG_DFL) {
                          sigexit(td, sig);

                               Function sigexit(td, sig) {
                                    ...
                                    exit1(td, W_EXITCODE(<span style="color:#00D">0</span>, sig));
                               }
                     } <span style="color:#080;font-weight:bold">else</span> {
                          ...
                          get signal mask
                          returnmask = td-&amp;gt;td_sigmask;
                          ...
                          <span style="color:#777">// Send signal to signal handler</span>
                          <span style="color:#777">// In process structure</span>
                          <span style="color:#777">// struct sysentvec *p_sysent;     /* (b) Syscall dispatch info. */</span>
                          (*p-&amp;gt;p_sysent-&amp;gt;sv_sendsig)(action, &amp;amp;ksi, &amp;amp;returnmask);

                                    <span style="color:#777">// i386/machdep.c</span>
                                    Function sendsig(sig_t catcher, ksiginfo_t *ksi, sigset_t *mask) {
                                         <span style="color:#080;font-weight:bold">struct</span> sigframe sf;
                                         ...
                                         When stack is context switched it will save the stack frame,
                     <span style="color:#088;font-weight:bold">register</span> contents etc
                                         Get the stack frame pointer of thread
                                         regs = td-&amp;gt;td_frame;
                                         ...

                                         Make a copy of stack frame because we will be changing the
                     frame to handle the signal.
                                         Once the signal is handled and the processing is done this
                     stack frame will be brought back.
                                         bcopy(regs, &amp;amp;sf.sf_uc.uc_mcontext.mc_fs, <span style="color:#080;font-weight:bold">sizeof</span>(*regs));

                                         Allocate space <span style="color:#080;font-weight:bold">for</span> signal handler context and put that in stack frame
                                         sp = (<span style="color:#0a8;font-weight:bold">char</span> *)regs-&amp;gt;tf_esp - <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#080;font-weight:bold">struct</span> sigframe);
                                         ...

                                         Build argument list <span style="color:#080;font-weight:bold">for</span> signal handler
                                         sf.sf_signum = sig;

                                         Pointer to signal context
                                         sf.sf_ucontext = (register_t)&amp;amp;sfp-&amp;gt;sf_uc;

                                         We are in kernel space currently, we will be going to user space soon
                                         and we want the signal catcher code to be executed in user space
                                         We are assigning the address of catcher function to be called from user space
                                         sf.sf_ahu.sf_action = (__siginfohandler_t *)catcher;
                                         ...
                                         ...

                                         Copy the signal frame to user<span style="color:#D20">'s</span> stack
                                         <span style="color:#080;font-weight:bold">if</span> (copyout(&amp;amp;sf, sfp, <span style="color:#080;font-weight:bold">sizeof</span>(*sfp)) != <span style="color:#00D">0</span>) {
                                              sigexit(td, SIGILL);
                                         }

                                         Stack frame pointer we got above <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">regs</span><span style="color:#710">&quot;</span></span> will copy sigtramp() to
                     instruction pointer. So, after returning from here we think
                     we will <span style="color:#080;font-weight:bold">return</span> from ast() and go to user code back but
                                         instead now we will be going to trampoline code.

                                         regs-&amp;gt;tf_eip = PS_STRINGS - szfreebsd4_sigcode;
                                    } <span style="color:#777">// end sendsig</span>
                     }
                } <span style="color:#777">//end postsig()</span>
 } } <span style="color:#777">//end of ast()</span>
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In i386/locore.s code <span style="color:#080;font-weight:bold">for</span> signal trampoline in user space
NON_GPROF_ENTRY(sigcode)
     calll     &lt;em&gt;SIGF_HANDLER(%esp)
     leal     SIGF_UC(%esp),%eax     /&lt;/em&gt; get ucontext */
     pushl     %eax
<span style="color:#F00;background-color:#FAA">…</span>
<span style="color:#F00;background-color:#FAA">…</span>
     movl $SYS_sigreturn,%eax&lt;/p&gt;

&lt;p&gt;Function sigreturn()
Function sigreturn(td, uap)
{
     regs = td-&amp;gt;td_frame;
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     lot of snaity checking
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
     bcopy(&amp;amp;ucp-&amp;gt;uc_mcontext.mc_fs, regs, <span style="color:#080;font-weight:bold">sizeof</span>(*regs));
     <span style="color:#F00;background-color:#FAA">…</span>&lt;/p&gt;

&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fork code in FreeBSD]]></title>
    <link href="http://distkeys.com/blog/2014/12/31/fork-in-freebsd/"/>
    <updated>2014-12-31T11:51:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/12/31/fork-in-freebsd</id>
    <content type="html"><![CDATA[<p>In computing, particularly in the context of the Unix operating system and its workalikes, fork is an operation whereby a process creates a copy of itself. It is usually a system call, implemented in the kernel. Fork is the primary (and historically, only) method of process creation on Unix-like operating systems.</p>

<p><a href="http://en.wikipedia.org/wiki/Fork_(system_call)">Read More</a></p>

<!-- more -->
<p><br /></p>

<blockquote>
  <p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process.</p>
</blockquote>

<p><a href="https://github.com/coolgoose85/FreeBSD/tree/master/sys">FreeBSD source code</a></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Function Fork() </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Function fork(td, uap)
{
    <span style="color:#F00;background-color:#FAA">…</span>
     error = fork1(td, RFFDG | RFPROC, <span style="color:#00D">0</span>, &amp;amp;p2);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Return pid of child
 td-&amp;gt;td_retval[<span style="color:#00D">0</span>] = p2-&amp;gt;p_pid; } </pre></div>
</div>
 </figure></notextile></div> 
</code></pre>

<p><br /></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Function Fork1() </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
Function fork1(td, flags, pages, procp)
{
     <span style="color:#080;font-weight:bold">struct</span> proc *p1, *p2, *pptr; <span style="color:#777">//p1 = parent process, p2 = child process&lt;/p&gt;</span>

&lt;pre&gt;&lt;code&gt; Parent process
 p1 = td-&amp;gt;td_proc;

 ...
 ...
 Allocate a new process
 newproc = uma_zalloc(proc_zone, M_WAITOK);

 To run a process we need to have atleast one thread,
 so allocate a new thread
 td2 = thread_alloc();

 Linkup thread to process
 proc_linkup(newproc, td2);
 ...
 ...

 Now we have to gro through the process address space and copy each section <span style="color:#080;font-weight:bold">for</span> new process
 Sections of process address space are
 <span style="color:#60E">1</span>. Text area (read only)
 <span style="color:#60E">2</span>. Initialized area
 <span style="color:#60E">3</span>. Uninitiaized area
 <span style="color:#60E">4</span>. Stack/Heap area

 vm2 = vmspace_fork(p1-&amp;gt;p_vmspace);

      Function vmspace_fork(p1-&amp;gt;p_vmspace) {
                Process virtual address space is as follows
                <span style="color:#777">/*
                * struct vmspace {
                *      struct vm_map vm_map;     /* VM address map */</span>
                *      <span style="color:#080;font-weight:bold">struct</span> shmmap_state *vm_shm;     <span style="color:#777">/* SYS5 shared memory private data XXX */</span>
                *      segsz_t vm_swrss;     <span style="color:#777">/* resident set size before last swap */</span>
                *      segsz_t vm_tsize;     <span style="color:#777">/* text size (pages) XXX */</span>
                *      segsz_t vm_dsize;     <span style="color:#777">/* data size (pages) XXX */</span>
                *      segsz_t vm_ssize;     <span style="color:#777">/* stack size (pages) */</span>
                *      caddr_t vm_taddr;     <span style="color:#777">/* (c) user virtual address of text */</span>
                *      caddr_t vm_daddr;     <span style="color:#777">/* (c) user virtual address of data */</span>
                *      caddr_t vm_maxsaddr;     <span style="color:#777">/* user VA at max stack growth */</span>
                *      <span style="color:#0a8;font-weight:bold">int</span>     vm_refcnt;     <span style="color:#777">/* number of references */</span>
                *      <span style="color:#777">/*
                *       * Keep the PMAP last, so that CPU-specific variations of that
                *       * structure on a single architecture don't result in offset
                *       * variations of the machine-independent fields in the vmspace.
                *       */</span>
                *      <span style="color:#080;font-weight:bold">struct</span> pmap vm_pmap;     <span style="color:#777">/* private physical map */</span>
                * };
                */

           We allocate the process address space
           <span style="color:#080;font-weight:bold">struct</span> vmspace *vm2;
           ...
           vm2 = vmspace_alloc(old_map-&amp;gt;min_offset, old_map-&amp;gt;max_offset);    
           ...
           ...

           Now we have to go through each vm map entries one at a time and allocate each <span style="color:#080;font-weight:bold">for</span> new process
           <span style="color:#080;font-weight:bold">while</span> (old_entry != &amp;amp;old_map-&amp;gt;header) {
                <span style="color:#080;font-weight:bold">case</span> VM_INHERIT_NONE:
                     ...

                <span style="color:#080;font-weight:bold">case</span> VM_INHERIT_SHARE:
                     ...

                <span style="color:#080;font-weight:bold">case</span> VM_INHERIT_COPY:
                     This is our <span style="color:#080;font-weight:bold">case</span> where we have to clone the entries and link into the map
                     new_entry = vm_map_entry_create(new_map);
                     ..
                     vm_map_entry_link(new_map, new_map-&amp;gt;header.prev, new_entry);
                     vmspace_map_entry_forked(vm1, vm2, new_entry);
                     vm_map_copy_entry(old_map, new_map, old_entry,         
           }
      } <span style="color:#777">// end vmspace_fork()</span>


 We will be now locking the process tree as we need to give new process process id
 Process of allocating a new Pid is system will scan the existing pids and try to come
 up with a range of free pids. Once a range of free pids found system will use that range
 <span style="color:#080;font-weight:bold">for</span> next lets say <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">k</span><span style="color:#710">&quot;</span></span> forks. Once the range is exhausted then system on next fork will
 again find the range and so on.

 sx_slock(&amp;amp;proctree_lock);

 Determine <span style="color:#080;font-weight:bold">if</span> we are exceeding process createlimit
 Check privledge to increase the limit

 <span style="color:#777">//Try to allocate the pids</span>
 trypid = lastpid + <span style="color:#00D">1</span>;

 ...

 Check <span style="color:#080;font-weight:bold">if</span> we have hit the end of the range
 <span style="color:#080;font-weight:bold">if</span> (trypid &amp;gt;= pidchecked) {
      We have exhausted the range so find a new range
      Scan the active and Zombie procs to check whether pid is in use
      ...
      ...
 }
 sx_sunlock(&amp;amp;proctree_lock);

 If we are within range then
 lastpid = trypid;

 p2 = newproc;
 p2-&amp;gt;p_state = PRS_NEW;          <span style="color:#777">/* protect against others */</span>
 p2-&amp;gt;p_pid = trypid;


 sched_fork(td, td2);
           Function sched_fork(<span style="color:#080;font-weight:bold">struct</span> thread *td, <span style="color:#080;font-weight:bold">struct</span> thread *child) {
                sched_fork_thread(td, child);
                          Function sched_fork_thread(td, child) {
                               Initialize schedule related values from parent to child
                               Assign CPU estimate info and priority
                               ...
                          }
           } <span style="color:#777">// end sched_fork()</span>
     
 Insert new process to process list
 LIST_INSERT_HEAD(&amp;amp;allproc, p2, p_list);

 Insert into PID HASH
 LIST_INSERT_HEAD(PIDHASH(p2-&amp;gt;p_pid), p2, p_hash);


 Lock P1
 Lock P2
 Relase Lock <span style="color:#080;font-weight:bold">for</span> All proc since we took all proc lock to allocate new pid
 sx_xunlock(&amp;amp;allproc_lock);

 copy the blocks
 bcopy(&amp;amp;p1-&amp;gt;p_startcopy, &amp;amp;p2-&amp;gt;p_startcopy,
     __rangeof(<span style="color:#080;font-weight:bold">struct</span> proc, p_startcopy, p_endcopy));

 Zero out the blocks
 bzero(&amp;amp;p2-&amp;gt;p_startzero,
     __rangeof(<span style="color:#080;font-weight:bold">struct</span> proc, p_startzero, p_endzero));

 ...
 Allocate new signals

 Copy File descriptors of all the open files by parent to child
 fd = fdcopy(p1-&amp;gt;p_fd);


 In a new process, we created a thread now copy the blocks <span style="color:#080;font-weight:bold">for</span> this new thread
 bzero(&amp;amp;td2-&amp;gt;td_startzero,
     __rangeof(<span style="color:#080;font-weight:bold">struct</span> thread, td_startzero, td_endzero));

 bcopy(&amp;amp;td-&amp;gt;td_startcopy, &amp;amp;td2-&amp;gt;td_startcopy,
     __rangeof(<span style="color:#080;font-weight:bold">struct</span> thread, td_startcopy, td_endcopy));

 bcopy(&amp;amp;p2-&amp;gt;p_comm, &amp;amp;td2-&amp;gt;td_name, <span style="color:#080;font-weight:bold">sizeof</span>(td2-&amp;gt;td_name));

 ...
 ...

 Copy the vnode pointer of text from parent to child
 p2-&amp;gt;p_textvp = p1-&amp;gt;p_textvp;   <span style="color:#777">// Vnode of executable. and increase the ref count</span>
 vref(p2-&amp;gt;p_textvp);

 ...


 Processing related to process group, child and parent will belong to same process group
 Insert process into process group list


 Associate child with Parent
 pptr = p1;
 p2-&amp;gt;p_pptr = pptr;

 Insert child process into sibling list
 LIST_INSERT_HEAD(&amp;amp;pptr-&amp;gt;p_children, p2, p_sibling);

 vm_forkproc(td, p2, td2, vm2, flags);
           Function vm_forkproc(td, p2, td2, vm2, flags) {
                ...
                ...

                cpu_fork(td, p2, td2, flags);
                          Function cpu_fork(<span style="color:#080;font-weight:bold">struct</span> thread *td1, <span style="color:#080;font-weight:bold">struct</span> proc *p2, <span style="color:#080;font-weight:bold">struct</span> thread *td2, <span style="color:#0a8;font-weight:bold">int</span> flags)
                          {
                               Copy PCB and the stack
                               pcb1 = td1-&amp;gt;td_pcb;

                               Allocate PCB <span style="color:#080;font-weight:bold">for</span> child process
                               pcb2 = (<span style="color:#080;font-weight:bold">struct</span> pcb *)(td2-&amp;gt;td_kstack +
                               td2-&amp;gt;td_kstack_pages * PAGE_SIZE) - <span style="color:#00D">1</span>;
                               td2-&amp;gt;td_pcb = pcb2;

                               Copy PCB1 to PCB2 (PCB <span style="color:#080;font-weight:bold">struct</span> is in pcb.h)
                               bcopy(td1-&amp;gt;td_pcb, pcb2, <span style="color:#080;font-weight:bold">sizeof</span>(*pcb2));

                               Create a new stack <span style="color:#080;font-weight:bold">for</span> a new process
                               td2-&amp;gt;td_frame = (<span style="color:#080;font-weight:bold">struct</span> trapframe *)((caddr_t)td2-&amp;gt;td_pcb - <span style="color:#00D">16</span>) - <span style="color:#00D">1</span>;
                               bcopy(td1-&amp;gt;td_frame, td2-&amp;gt;td_frame, <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#080;font-weight:bold">struct</span> trapframe));
                               ...
                               td2-&amp;gt;td_frame-&amp;gt;tf_eax = <span style="color:#00D">0</span>;          <span style="color:#777">/* Child returns zero */</span>
                               ...
                               ...

                               In instruction pointer of child process we will set the address of trampoline code
                               pcb2-&amp;gt;pcb_eip = (<span style="color:#0a8;font-weight:bold">int</span>)fork_trampoline;

                               <span style="color:#777">//Fork_trampoline code will call fork_return</span>
                               pcb2-&amp;gt;pcb_esi = (<span style="color:#0a8;font-weight:bold">int</span>)fork_return;     <span style="color:#777">/* fork_trampoline argument */</span>
                               pcb2-&amp;gt;pcb_ebx = (<span style="color:#0a8;font-weight:bold">int</span>)td2;          <span style="color:#777">/* fork_trampoline argument */</span>

                                         Looking into fork_trampoline in i386/exception.s
                                              ENTRY(fork_trampoline)
                                                        pushl     %esp               <span style="color:#777">/* trapframe pointer */</span>
                                                        pushl     %ebx               <span style="color:#777">/* arg1 */</span>
                                                        pushl     %esi               <span style="color:#777">/* function */</span>
                                                        call     fork_exit
                                              So, from fork_trampoline we are going to call fork_exit and its argument
                                              will be above we mentioned.

                                                   <span style="color:#777">//Handle the return of a child process from fork1()</span>
                                                   Function fork_exit(callout, arg, frame)         
                                                   {
                                                        ...
                                                        callout(arg, frame); <span style="color:#777">// Here callout is fork_return, as we passed it</span>
                                                                                      as a argument to fork_exit

                                                             Function fork_return() {                                            
                                                                  userret(td, frame);
                                                             }
                                                   }

                                              Once we <span style="color:#080;font-weight:bold">return</span> from fork_exit we will go to doreti
                                              which will load our frame and we have will go back to
                                              fork system call as a child. But the chils process will
                                              not execute right now because we have not scheduled it
                                              to run. This is the setup we are preparing and once
                                              all the setup is done we will schedule the child process
                                              and it will <span style="color:#080;font-weight:bold">do</span> as described above
                                              jmp     doreti    

                          } <span style="color:#777">// end of cpu_fork()</span>
           } <span style="color:#777">//end of vm_forkproc</span>


 Put child process on run queue
 sched_add(td2, SRQ_BORING);

 ...
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} <span style="color:#777">//end fork1()</span>
</pre></div>
</div>
 </figure></notextile></div> </p>

<p><br /></p>

<h2 id="call-tree">Call Tree</h2>

<p><img src="/images/fork1.png" title="[fork1.png]" ></p>

<p><br /><br /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug FreeBSD - Open]]></title>
    <link href="http://distkeys.com/blog/2014/08/04/debug-freebsd-open/"/>
    <updated>2014-08-04T19:10:00-07:00</updated>
    <id>http://distkeys.com/blog/2014/08/04/debug-freebsd-open</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bird-eye-view">Bird Eye View</a></li>
  <li><a href="#map---open">Map - Open</a></li>
  <li><a href="#file-structure--file-descriptor">File Structure &amp; File Descriptor</a>    <ul>
      <li><a href="#file-structure-allocation">File Structure Allocation</a></li>
      <li><a href="#file-descriptor">File Descriptor</a></li>
      <li><a href="#how-file-descriptor-is-allocated-fdalloc">How file descriptor is allocated (fdalloc)</a></li>
    </ul>
  </li>
  <li><a href="#call-tree">Call Tree</a></li>
  <li><a href="#pathname-lookup">Pathname Lookup</a></li>
  <li><a href="#associate-vnode-with-file-structure">Associate vnode with file structure</a></li>
  <li><a href="#return-file-descriptor-back-to-the-user">Return file descriptor back to the user</a></li>
</ul>

<p><strong>Open System Call</strong></p>

<p>For most file systems, a program initializes access to a file in a filesystem using the open system call. This allocates resources associated to the file (the file descriptor), and returns a handle that the process will use to refer to that file. In some cases the open is performed by the first access.</p>

<p>More information can be found at wikipedia <a href="http://en.wikipedia.org/wiki/Open_(system_call)" target="_blank">article</a> or <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank">Linux manual page.</a></p>

<!-- more -->

<p>This post will explore the code flow when open system call is issued.</p>

<p><br /><br /></p>

<h2 id="bird-eye-view">Bird Eye View</h2>

<p>Open system call goes through lot of twist and turns and explore some of the most complicated code paths. On a very high level it tries to do the following task.</p>

<ol>
  <li>Allocate file structure and file descriptor<br /></li>
  <li>Associate file structure with file descriptor<br /></li>
  <li>Pathname lookup will return vnode<br /></li>
  <li>Associate vnode with file structure<br /></li>
  <li>Return file descriptor back to the user<br /></li>
</ol>

<p><br /></p>

<h2 id="map---open">Map - Open</h2>

<p>All the system calls are mapped with system call number in <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/syscalls.master#L65" target="_blank">syscalls.master (kern)</a>.</p>

<p>For open system call</p>
<table>
<thead>
<tr>
	<th>System Call Number</th><th>System Call</th><th>System Call Signature</th>
</tr>
</thead>
<tbody>
<tr>
	<td>5</td>
	<td>AUE_OPEN_RWTC</td>
	<td>int open(char *path, int flags, int mode);</td>
</tr>
</tbody>
</table>

<p>More details about how system call is executed can be found <a href="http://distkeys.com/blog/2014/08/03/inside-freebsd/#system-calls" target="_blank">here.</a></p>

<p><br /><br /></p>

<h2 id="file-structure--file-descriptor">File Structure &amp; File Descriptor</h2>

<p>Open system call starts from function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1012" target="_blank">open(td, uap)</a> which calls function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1041" target="_blank">kern_open()</a> which finally calls function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat().</a> This is the function from where all the action starts.</p>

<p>In function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat()</a>, we are going to allocate the file descriptor. To do so we call function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1411" target="_blank">falloc()</a>.<br /><br /></p>

<blockquote>
  <p>Function falloc(struct thread *td, struct file **resultfp, int *resultfd) returns back pointer to the <code class="myyellow">file entry</code> and <code class="myyellow">file descriptor.</code></p>
</blockquote>

<p><br /></p>

<h3 id="file-structure-allocation">File Structure Allocation</h3>

<p>Allocate space for <code class="myyellow">file structure</code> in kernel either by malloc or we use zalloc here because memory is assigned from file zone. There are multiple zones like file_zone, proc_zone or thread_zone. So, we ask memory from file zone and we pass the parameter is space in this zone is not available then are we willing to wait. Its a synchronous call. If memory is not available then thread will go to sleep if M_WAITOK is set.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>falloc() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1420' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
     fp = uma_zalloc(file_zone, M_WAITOK | M_ZERO);
</pre></div>
</div>
 </figure></notextile></div></p>

<p>We get back pointer to file entry.
Zone limits are set during boot up time and whenever allocation or free happens it happens from that limit allocated.</p>

<p><em>File structure</em> looks as follows
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>file structure</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/sys/file.h#L116' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>&lt;/p&gt;

&lt;p&gt;<span style="color:#080;font-weight:bold">struct</span> file {
     <span style="color:#088;font-weight:bold">void</span>              &lt;em&gt;f_data;     /&lt;/em&gt; file descriptor specific data &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> fileops     *f_ops;          /&lt;/em&gt; File operations &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> ucred       *f_cred;     /&lt;/em&gt; associated credentials. &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> vnode      *f_vnode;     /&lt;/em&gt; <span style="color:#069">NULL</span> or applicable vnode &lt;em&gt;/
     <span style="color:#0a8;font-weight:bold">short</span>          f_type;          /&lt;/em&gt; descriptor type &lt;em&gt;/
     <span style="color:#0a8;font-weight:bold">short</span>          f_vnread_flags; /&lt;/em&gt; (f) Sleep lock <span style="color:#080;font-weight:bold">for</span> f_offset &lt;em&gt;/
     <span style="color:#088;font-weight:bold">volatile</span> u_int     f_flag;          /&lt;/em&gt; see fcntl.h &lt;em&gt;/
     <span style="color:#088;font-weight:bold">volatile</span> u_int      f_count;     /&lt;/em&gt; reference count &lt;em&gt;/
     /&lt;/em&gt;
      *  DTYPE_VNODE specific fields.
      &lt;em&gt;/
     <span style="color:#0a8;font-weight:bold">int</span>          f_seqcount;     /&lt;/em&gt; Count of sequential accesses. &lt;em&gt;/
     off_t          f_nextoff;     /&lt;/em&gt; next expected read/write offset. &lt;em&gt;/
     <span style="color:#080;font-weight:bold">struct</span> cdev_privdata *f_cdevpriv; /&lt;/em&gt; (d) Private data <span style="color:#080;font-weight:bold">for</span> the cdev. &lt;em&gt;/
     /&lt;/em&gt;
      *  DFLAG_SEEKABLE specific fields
      &lt;em&gt;/
     off_t          f_offset;
     /&lt;/em&gt;
      * Mandatory Access control information.
      &lt;em&gt;/
     <span style="color:#088;font-weight:bold">void</span>          *f_label;     /&lt;/em&gt; Place-holder <span style="color:#080;font-weight:bold">for</span> MAC label. */
     };
</pre></div>
</div>
 </figure></notextile></div>     </p>

<p>We have created a <code class="myyellow">file structure</code> now we have to initialize it. So we, </p>

<ul>
  <li>Increment the ref count for the file structure to 1.</li>
  <li>Assign the input credentials.</li>
  <li>Initialize the file ops to <em>badfileops</em> and we will update it later as we figure it out.</li>
  <li>data is null</li>
  <li>There are no <em>vnode</em> associated yet.
<br /><br /></li>
</ul>

<h3 id="file-descriptor">File Descriptor</h3>

<p>Now, allocate the file descriptor. For that get lock and call <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1446" target="_blank">fdalloc()</a> to allocate fd.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>fdalloc() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1446' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">if</span> ((error = fdalloc(td, <span style="color:#00D">0</span>, &amp;amp;i))) {
</pre></div>
</div>
 </figure></notextile></div>
Here ‘i’ is the file descriptor to be returned.</p>

<p>Once we get file descriptor from function fdalloc() we associate the file descriptor to file structure we allocated above.
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>fdalloc() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1453' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
p-&amp;gt;p_fd-&amp;gt;fd_ofiles[i] = fp;
</pre></div>
</div>
 </figure></notextile></div>
Here p is the process structure where it maintains all the files opened.</p>

<p>Return the fd and file structure pointer from function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1411" target="_blank">falloc()</a> to function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1049" target="_blank">kern_openat()</a></p>

<p><br /></p>

<h3 id="how-file-descriptor-is-allocated-fdalloc">How file descriptor is allocated (fdalloc)</h3>

<p>In function <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1331" target="_blank">fdalloc()</a>, we search the bitmap for a free descriptor. If we can’t find then grow the file table until limit is hit.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>fdalloc()</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/kern_descrip.c#L1352' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">for</span> (;;) {
          fd = fd_first_free(fdp, minfd, fdp-&amp;gt;fd_nfiles);
          <span style="color:#080;font-weight:bold">if</span> (fd &amp;gt;= maxfd)
               <span style="color:#080;font-weight:bold">return</span> (EMFILE);
          <span style="color:#080;font-weight:bold">if</span> (fd &amp;lt; fdp-&amp;gt;fd_nfiles)
               <span style="color:#080;font-weight:bold">break</span>;
          fdgrowtable(fdp, min(fdp-&amp;gt;fd_nfiles * <span style="color:#00D">2</span>, maxfd));
          }
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="call-tree">Call Tree</h2>

<p><img src="/images/CallsGraph-open.png" title="[CallsGraph-open.png]" ></p>

<p><br /><br /></p>

<h2 id="pathname-lookup">Pathname Lookup</h2>

<p>Now we pick up the mode information for file provided as input. Mode value will be used if we have to create a file.</p>

<p>Now we call <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_vnops.c#L89" target="_blank">vn_open()</a> function and pass the input information.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>vn_open()</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_vnops.c#L89' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
error = vn_open(&amp;amp;nd, &amp;amp;flags, cmode, fp); 
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Here, struct nameidata nd;<br />
If we don’t hit any error then we will get node related information in nd and all we do is extract the information and tie up with the fp file structure pointer.</p>

<p><br /><br /></p>

<h2 id="associate-vnode-with-file-structure">Associate vnode with file structure</h2>

<p>If we don’t hit any error from vn_open() then we will get node related information in nd and all we do is extract the information and tie up with the <em>fp</em> file structure pointer.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Assign vnode</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1131' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
error = vn_open(&amp;amp;nd, &amp;amp;flags, cmode, fp); 
<span style="color:#F00;background-color:#FAA">…</span>
<span style="color:#F00;background-color:#FAA">…</span>
vp = nd.ni_vp;
fp-&amp;gt;f_vnode = vp;
</pre></div>
</div>
 </figure></notextile></div></p>

<p>By this time if file operation is not set i.e. if it is still <em>badfileops</em> then we initialize it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>badfileops</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1138' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">if</span> (fp-&amp;gt;f_ops == &amp;amp;badfileops) {
          KASSERT(vp-&amp;gt;v_type != VFIFO, (<span style="color:#F00;background-color:#FAA">“</span>Unexpected fifo.<span style="color:#F00;background-color:#FAA">”</span>));
          fp-&amp;gt;f_seqcount = <span style="color:#00D">1</span>;
          finit(fp, flags &amp;amp; FMASK, DTYPE_VNODE, vp, &amp;amp;vnops);
 }
</pre></div>
</div>
 </figure></notextile></div></p>

<p>So far, we have done all the book keeping operations. Once its done we need to write data to the file.
Now, we do the locking of a file. Based on what kind of locking is requested i.e.</p>

<ol>
  <li>Exclusive lock<br /></li>
  <li>Shared Lock<br /></li>
  <li>Write Lock<br /></li>
  <li>Read Lock<br /></li>
  <li>Lease to client<br /></li>
</ol>

<p>So, we do the locking of file. Write to the file and file set the attributes to the file.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>file locking</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1145' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>&lt;/p&gt;

&lt;p&gt;<span style="color:#080;font-weight:bold">if</span> (flags &amp;amp; (O_EXLOCK | O_SHLOCK)) {
     <span style="color:#F00;background-color:#FAA">…</span>
     <span style="color:#F00;background-color:#FAA">…</span>
          <span style="color:#080;font-weight:bold">if</span> ((error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &amp;amp;lf,type)) != <span style="color:#00D">0</span>) {
               <span style="color:#F00;background-color:#FAA">…</span>
          }
     <span style="color:#F00;background-color:#FAA">…</span>
 }&lt;/p&gt;

&lt;p&gt;<span style="color:#080;font-weight:bold">if</span> (flags &amp;amp; O_TRUNC) {
          <span style="color:#080;font-weight:bold">if</span> ((error = vn_start_write(vp, &amp;amp;mp, V_WAIT | PCATCH)) != <span style="color:#00D">0</span>)
               <span style="color:#080;font-weight:bold">goto</span> bad;
          VOP_LEASE(vp, td, td-&amp;gt;td_ucred, LEASE_WRITE);
          <span style="color:#F00;background-color:#FAA">…</span>
          <span style="color:#F00;background-color:#FAA">…</span>
          vat.va_size = <span style="color:#00D">0</span>;
          <span style="color:#F00;background-color:#FAA">…</span>
          error = VOP_SETATTR(vp, &amp;amp;vat, td-&amp;gt;td_ucred);
          <span style="color:#F00;background-color:#FAA">…</span>
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /><br /></p>

<h2 id="return-file-descriptor-back-to-the-user">Return file descriptor back to the user</h2>

<p>Finally we return fd (indx) and 0 which is success from function kern_openat()</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Return fd</span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/kern/vfs_syscalls.c#L1184' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
     td-&amp;gt;td_retval[<span style="color:#00D">0</span>] = indx;
    <span style="color:#080;font-weight:bold">return</span> (<span style="color:#00D">0</span>);
 </pre></div>
</div>
 </figure></notextile></div></p>

<p><br /> <br /> <br /> <br /> <br /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inside FreeBSD - Debug System Call]]></title>
    <link href="http://distkeys.com/blog/2014/08/03/inside-freebsd/"/>
    <updated>2014-08-03T10:36:00-07:00</updated>
    <id>http://distkeys.com/blog/2014/08/03/inside-freebsd</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#system-calls">System Calls</a></li>
</ul>

<p><div class="wikipedia">
  
    <img src="//upload.wikimedia.org/wikipedia/commons/thumb/6/68/Linux_kernel_interfaces.svg/300px-Linux_kernel_interfaces.svg.png"/>
  
  <h2>system call</h2>
  <div>
    <p>In <a href="http://en.wikipedia.org/wiki/Computing" title="Computing">computing</a>, a <strong>system call</strong> is how a program requests a service from an <a href="http://en.wikipedia.org/wiki/Operating_system" title="Operating system">operating system</a>'s <a href="http://en.wikipedia.org/wiki/Kernel_(computing)" title="Kernel (computing)" class="mw-redirect">kernel</a>. This may include hardware related services (e.g. accessing the hard disk), creating and executing new <a href="http://en.wikipedia.org/wiki/Process_(computing)" title="Process (computing)">processes</a>, and communicating with integral kernel services (like scheduling). System calls provide an essential interface between a process and the operating system.
</p>
  </div>
  <a href="http://en.wikipedia.org/wiki/System_call">Read more</a>
</div>
</p>

<!-- more -->

<p><br /><br /></p>

<h3 id="system-calls">System Calls</h3>

<p>Whenever system call is executed from user level a trap is generated and it gets handled at file <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/exception.s#L255" target="_blank">Exception.S (i386\i386)</a> </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>System Call </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/exception.s#L255' target='_blank'>Code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span style="color:#777">/* </span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span><span style="color:#777"> * Even though the name says ‘int0x80’, this is actually a TGT (trap gate)</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span><span style="color:#777"> * rather then an IGT (interrupt gate).  Thus interrupts are enabled on</span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span><span style="color:#777"> * entry just as they are for a normal syscall.</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span><span style="color:#777"> &lt;em&gt;/</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span><span style="color:#777">     SUPERALIGN_TEXT</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span style="color:#777">IDTVEC(int0x80_syscall)</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span style="color:#777">     pushl     $2               /&lt;/em&gt; sizeof “int 0x80” &lt;em&gt;/</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span style="color:#777">     subl     $4,%esp               /&lt;/em&gt; skip over tf_trapno */</span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>     pushal
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>     pushl     %ds
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>     pushl     %es
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>     pushl     %fs
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>     SET_KERNEL_SREGS
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>     FAKE_MCOUNT(TF_EIP(%esp))
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>     pushl     %esp
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>     call     syscall   ==&amp;gt; from here syscall function is called after pushing some prereq
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>     add     $<span style="color:#00D">4</span>, %esp
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>     MEXITCOUNT
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>     jmp     doreti ==&amp;gt; <span style="color:#080;font-weight:bold">do</span> <span style="color:#080;font-weight:bold">return</span> from interrupt 
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /></p>

<blockquote>
  <p><em>syscall()</em> is a function in <a href="https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L977" target="_blank">Trap.c (i386\i386)</a> is a machine dependent code area.<br /></p>
</blockquote>

<p><code class="myyellow">Function syscall()</code> is called with trap frame which has input values to system call.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>struct trapframe </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#777">/*
 * Exception/Trap Stack Frame
 */</span>&lt;/p&gt;

&lt;p&gt;<span style="color:#080;font-weight:bold">struct</span> trapframe {
     <span style="color:#0a8;font-weight:bold">int</span>     tf_fs;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_es;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_ds;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_edi;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_esi;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_ebp;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_isp;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_ebx;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_edx;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_ecx;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_eax;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_trapno;
     <span style="color:#777">/* below portion defined in 386 hardware &lt;em&gt;/
     int     tf_err;
     int     tf_eip;
     int     tf_cs;
     int     tf_eflags;
     /&lt;/em&gt; below only when crossing rings (e.g. user to kernel) */</span>
     <span style="color:#0a8;font-weight:bold">int</span>     tf_esp;
     <span style="color:#0a8;font-weight:bold">int</span>     tf_ss;
};
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /></p>

<p><code class="myyellow">Function syscall()</code> now gets all the values of system call input and store in kernel so that kernel code can access the values while processing system call.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>syscall() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L997' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
    params = (caddr_t)frame-&amp;gt;tf_esp + <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">int</span>);
     code = frame-&amp;gt;tf_eax;   <span style="color:#777">// code is system call code</span>
     orig_tf_eflags = frame-&amp;gt;tf_eflags;
</pre></div>
</div>
 </figure></notextile></div></p>

<p><br /></p>

<p>Then check we have direct or indirect system call. Indirect system call is one which is like loadable kernel module which loads system call. Once loaded then it can pass the system call number as argument which can be injected in here.</p>

<p><br />
Then given the system call code we check if we have the code as valid number. If system call code is valid then lookup in system call table which system call is referred else simply store the pointer to indirect system call which is system call 0.
<br />
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>syscall() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1030' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">if</span> (code &amp;gt;= p-&amp;gt;p_sysent-&amp;gt;sv_size)
           callp = &amp;amp;p-&amp;gt;p_sysent-&amp;gt;sv_table[<span style="color:#00D">0</span>];
       <span style="color:#080;font-weight:bold">else</span>
           callp = &amp;amp;p-&amp;gt;p_sysent-&amp;gt;sv_table[code]; 
</pre></div>
</div>
 </figure></notextile></div>
<br />
where <strong>sv_table</strong> entry will have following values</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>sv_table </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">struct</span> sysent {               <span style="color:#777">/* system call table &lt;em&gt;/
     int     sy_narg;     /&lt;/em&gt; number of arguments &lt;em&gt;/
     sy_call_t *sy_call;     /&lt;/em&gt; implementing function &lt;em&gt;/
     au_event_t sy_auevent;     /&lt;/em&gt; audit event associated with syscall &lt;em&gt;/
     systrace_args_func_t sy_systrace_args_func;
                    /&lt;/em&gt; optional argument conversion function. &lt;em&gt;/
     u_int32_t sy_entry;     /&lt;/em&gt; DTrace entry ID for systrace. &lt;em&gt;/
     u_int32_t sy_return;     /&lt;/em&gt; DTrace return ID for systrace. */</span>
};
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Once we know which system it is then we determine how many arguments it have</p>

<blockquote>
  <p>narg = callp-&gt;sy_narg;</p>
</blockquote>

<p>Then we copy all the user space arguments into kernel space using function copying which validates the addresses of source and destination etc.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>syscall() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1040' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#777">/*
      * copyin and the ktrsyscall()/ktrsysret() code is MP-aware
      * copy data from params to args
      */</span>
     <span style="color:#080;font-weight:bold">if</span> (params != <span style="color:#069">NULL</span> &amp;amp;&amp;amp; narg != <span style="color:#00D">0</span>)
          error = copyin(params, (caddr_t)args,
                        (u_int)(narg * <span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">int</span>)));&lt;/p&gt;

&lt;p&gt;</pre></div>
</div>
 </figure></notextile></div></p>

<p>Now, check if we saw any error so far. If we did find the error then we need to return the error but, at this time in kernel it does not know how to return in user space. So, we set the register 0 to be non zero which is the error number and we set another register which is carry bit(eflag). <br /></p>

<p>So, when system call is returned, C lib which issued the system call will check if carry bit(eflag) is set or not. If it is set then it will get the error number from register 0 and map it to human readable error <em>errorno</em> and then override the register 0 with -1. <br />
So, say if open system call encounters error then its going to get the error value from register 0; translate it to meaningful error and then override the register 0 with -1. So open returned the value -1 which is failure.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>syscall() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1056' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">if</span> (error == <span style="color:#00D">0</span>) {
          td-&amp;gt;td_retval[<span style="color:#00D">0</span>] = <span style="color:#00D">0</span>;
          td-&amp;gt;td_retval[<span style="color:#00D">1</span>] = frame-&amp;gt;tf_edx; <span style="color:#777">// return another value in register 1 if we have anything to return</span>
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Now we call the actual system call
&gt; error = (*callp-&gt;sy_call)(td, args);</p>

<p>Here, 
<em>td</em> is the thread pointer
<em>args</em> are the arguments we have copied above from user space to kernel space</p>

<p>We check error and if all fine then we return the values back to user space</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>syscall() </span>  <a href='https://github.com/coolgoose85/FreeBSD/blob/master/sys/i386/i386/trap.c#L1094' target='_blank'>code </a></figcaption> <div class="CodeRay">
  <div class="code"><pre>
<span style="color:#080;font-weight:bold">switch</span> (error) {
     <span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">0</span>:
          frame-&amp;gt;tf_eax = td-&amp;gt;td_retval[<span style="color:#00D">0</span>];
          frame-&amp;gt;tf_edx = td-&amp;gt;td_retval[<span style="color:#00D">1</span>];
          frame-&amp;gt;tf_eflags &amp;amp;= ~PSL_C;
          <span style="color:#080;font-weight:bold">break</span>;&lt;/p&gt;

&lt;p&gt;<span style="color:#080;font-weight:bold">else</span> we handle the error
          frame-&amp;gt;tf_eax = error;
          frame-&amp;gt;tf_eflags |= PSL_C;
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Now we fall back to assembly program from where this function was called.</p>

<p><br /><br /><br /><br /></p>

<p><a href="http://distkeys.com/blog/2014/08/04/debug-freebsd-open/" target="_blank">Continue to Open System Call</a></p>

<p><br /><br /><br /><br /></p>
]]></content>
  </entry>
  
</feed>

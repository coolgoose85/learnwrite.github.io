<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Systems | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/systems/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-02-26T22:45:50-08:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Naming in Distributed Systems]]></title>
    <link href="http://distkeys.com/blog/2014/02/16/naming-in-distributed-systems/"/>
    <updated>2014-02-16T22:47:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/02/16/naming-in-distributed-systems</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#directory-service-for-wan--dns">Directory Service for WAN – DNS	†</a>    <ul>
      <li><a href="#granularity-of-names">Granularity of Names</a></li>
      <li><a href="#caching-of-namesplacement-of-caches">Caching of Names/Placement of Caches</a></li>
      <li><a href="#use-of-replication">Use of Replication</a></li>
      <li><a href="#use-of-distribution">Use of Distribution</a></li>
      <li><a href="#consistencysynchronization-requirement">Consistency/Synchronization Requirement</a></li>
    </ul>
  </li>
  <li><a href="#file-systemcontent-management-system-cms">File system/Content management system (CMS)</a>    <ul>
      <li><a href="#granularity-of-names-1">Granularity of Names</a></li>
      <li><a href="#caching-of-namesplacement-of-caches-1">Caching of Names/Placement of Caches</a></li>
      <li><a href="#use-of-replication-1">Use of Replication</a></li>
      <li><a href="#use-of-distribution-1">Use of Distribution</a></li>
      <li><a href="#consistencysynchronization-requirement-1">Consistency/Synchronization Requirement</a></li>
    </ul>
  </li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>The scope of this post is limited to the study of naming systems for following system<br />
•	Directory Service for Wide Area<br />
•	File system or Content manage system for collaborative work<br /></p>

<p>Naming can be categorized into four kinds<br />
1. Host based naming<br />
2. Global naming<br />
3. User/Objet centered naming <br />
4. Attribute based naming<br />
<!-- more --></p>

<p>The system we are going post will be falling into one of these category or hybrid of it. On the broad level, naming is associated with <strong>users, hosts, services, files, objects and groups</strong>. The requirements for directory for wide area and for Filesystem/CMS can be broadly categorize into following components:<br />
•	Scalability<br />
•	Availability<br />
•	Consistency<br />
•	Reliability<br />
•	Fault isolation<br />
•	Performance and Efficiency<br /><br /></p>

<h3 id="directory-service-for-wan--dns">Directory Service for WAN – DNS	†</h3>

<p>DNS is the case study of directory service for wide area network. The various requirements of DS†† for WAN††† has been summarized and presented in form of DNS as follows:</p>

<h4 id="granularity-of-names">Granularity of Names</h4>

<p>In DNS, domain names are represented by a <strong>character strings</strong> and machine oriented <strong>binary identifier</strong> is called Internet Address. Domain name changes rarely than the host more down the <strong>hierarchy</strong> so, on the course of granularity the <strong>less</strong> frequent to change lead to <strong>less</strong> number of messages and less number of objects to deal. In DNS mechanism of name to machine address lookup, finer the level of granularity more it is prone to change hence leads to <strong>more</strong> number of messages and query flow in network. So higher the hierarchy is lower the name granularity and lower the hierarchy is higher the name granularity.<br /><br /></p>

<h4 id="caching-of-namesplacement-of-caches">Caching of Names/Placement of Caches</h4>

<p>All names are cached which the name server heard about from other name servers while handling the request of name resolution.<br /></p>

<p>• <strong>Iterative query</strong> – Name query goes to local name server where server matches query to the longest name prefix in its local cache. It caches the request and response for future reference.<br />
• <strong>Recursive query</strong> – Every level of name server maintains the cache, in other words the multilevel caching, which tries to resolves longest sequence of name query.  In recursive query look up the server caches the query request and as well as query response.<br />
• <strong>Negative Caching</strong> – Negative caching is used for bad names or absence of a resource record in order to answer future queries as quickly.<br /><br /></p>

<h4 id="use-of-replication">Use of Replication</h4>

<p>To ensure <strong>high availability</strong> and enhance <strong>performance</strong> of name service name servers are replicated and the frequency of <strong>replication</strong> depends upon the frequency of its use and the degree off its <strong>importance</strong> in the network. For example, root name server is highly replicated to ensure its high availability and avoiding frequent name queries.<br /><br /></p>

<h4 id="use-of-distribution">Use of Distribution</h4>

<p>The hierarchical model of DNS distributes the job of managing the handing out of names by <strong>distributing the responsibility</strong> of operating name servers. Distribution is maintained in terms of different domain name servers for different top levels domains, so there is a natural separation in terms of sending particular kind of name queries to one name server and other kind of name queries to other name servers.<br /></p>

<p>More formally, Namespace is delegated at every domain and the whole space is partitioned into number of area called <strong>zones</strong>, which starts a domain and extends till leaf nodes, which is individual computer, or to other domain where other zone starts.<br /><br /></p>

<h4 id="consistencysynchronization-requirement">Consistency/Synchronization Requirement</h4>

<p>DNS cache manager synchronizes the cache records when expired. For consistency caches maintains the <strong>time to live</strong> for every entry. </p>

<p>For any update operation the primary server of a zone is contacted. Each secondary server periodically establishes a communication connection with primary server and gets the update.<br /></p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h3 id="file-systemcontent-management-system-cms">File system/Content management system (CMS)</h3>

<p>File System or CMS for collaborative work is smaller environment as compared to directory service for wide area. Hence, the priority of requirement we discussed earlier changes. The scalability for small scale is not the top priority but it remains requirement for future. But, other requirements like Availability, consistency etc remains a major requirements.<br /></p>

<p>CMS/File System for University can have Global naming, User centric naming system, attribute type naming scheme. <br /></p>

<h4 id="granularity-of-names-1">Granularity of Names</h4>

<p>Granularity of names in CMS systems is large in nature. Since, the system is not huge and not distributed of highest degree, large granularity works. Moreover, in system like this more details can be accommodated in to naming increasing the performance of naming system.<br /></p>

<p>For instance, Tilde naming system is a relative naming system based on collection of small, disjoint, hierarchical namespace. The level of will be very less as compared to wide area hence lower the granularity. <br />
In Prospero File System, Virtual System Model implements the concept of closure, which reduces the granularity.<br /><br /></p>

<h4 id="caching-of-namesplacement-of-caches-1">Caching of Names/Placement of Caches</h4>

<p>In CMS/File Systems environment caching of names provide enormous performance boost because the effect of locality of reference or caching the alias plays a significant role. Cache can be most efficiently used for most frequent access file names, which is limited and manageable in case of small environment like university. Cache can be managed on centralized server or the primary name server based on system naming architecture and boosts the overall availability.<br /><br /></p>

<h4 id="use-of-replication-1">Use of Replication</h4>

<p>Replication is of required for high availability of naming service.  Replication enhances the performance in University environment when using Global naming system and act as a load balancing to serve request quickly. It provides the fault tolerance by maintaining the replication of progressive collaborative work.<br /><br /></p>

<h4 id="use-of-distribution-1">Use of Distribution</h4>

<p>Distribution in global naming system if designed hierarchy, in the case of Prospero, local name server associated serves each requests. Next component is resolved by directory server in response of local name server. So, the naming service is distributed in the context of processing of user name query in <strong>distributed fashion</strong> rather than query served by dedicated <strong>one name server</strong>. Maintaining a non-distributed global name service irrespective of <strong>distributed file content</strong> can be a <strong>bottleneck</strong> and global name server <strong>performance issue</strong>, when files across the server is moved and renamed frequently.<br /><br /></p>

<h4 id="consistencysynchronization-requirement-1">Consistency/Synchronization Requirement</h4>

<p>Consistency is achieved by synchronization and in collaborative environment like university synchronization is high priority. Stale name values in cache or time to live values in cache can lead to poor performance in dynamic collaborative environment.  Although frequent synchronization leads to degrade the system performance but in order to provide consistency and reliability it can be compromised.</p>

<p><br /><br /><br /><br />
† Domain name service<br />
†† Directory Service<br />
††† Wide Area Network<br /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Context Switch]]></title>
    <link href="http://distkeys.com/blog/2014/02/16/context-switch/"/>
    <updated>2014-02-16T14:53:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/02/16/context-switch</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#message-passing">Message Passing</a></li>
  <li><a href="#remote-procedure-calls-rpc">Remote Procedure Calls (RPC)</a></li>
  <li><a href="#lightweight-remote-procedure-call">Lightweight Remote Procedure Call</a></li>
  <li><a href="#distributed-shared-memory--ivy">Distributed Shared Memory – IVY</a></li>
  <li><a href="#further-reading">Further reading</a></li>
</ul>

<p>The scope of this post is limited to the study of context switches in various communication and synchronization primitives in distributed systems mainly focus on following:</p>

<p>•	Message Passing<br />
•	Remote Procedure Calls (RPC) <br />
•	Light weight Procedure Calls (LRPC)<br />
•	Distributed Shared Memory (DSM)<br /></p>

<!-- more -->
<p><br /></p>

<h3 id="message-passing">Message Passing</h3>

<p>Message passing is the communication primitive based on the <code class="myyellow">Client – Server architecture</code> involving communication only through a message passing. In message passing architecture the user process generates the datagram and interrupts the kernel for sending datagram to receiver. This process needs a context switch. <br /><br />
At receiving end, after receiving a datagram by the service the data is sent to application in User Space from Kernel module, which involves the context switch. Same process is done back and forth to send and receive data with respective context switching in Message passing scheme of communication.<br /><br />
Synchronization is achieved by blocking send and receives which may result in blocking the process in execution, while it receives a response from receiver, and volunteering giving up the CPU which might be argued as a context switch but in this post this mechanism is not treated as a context switch. 
<br /><br /></p>

<h3 id="remote-procedure-calls-rpc">Remote Procedure Calls (RPC)</h3>

<p>RPC communication models aims to achieve the results of normal procedure call but in distributed environment. RPC is a level of abstraction on top of message passing and since, the nature of procedure call is continuous RPC follows a synchronous communication methodology. Four components in RPC are:<br /></p>

<p>•	User – In user space<br />
•	User Stub and RPC Communication Package – In Kernel Space<br />
•	Server Stub and RPC Communication Package – In Kernel Space<br />
•	Server – In user space on remote machine<br /></p>

<p>User makes an RPC call like a normal procedure call which result in calling User stub and later the RPC communication package which is called the RPC runtime often. This process involves the context switching and the kernel takes care of RPC request using user stub and RPC runtime for marshaling data and sending to receiver.</p>

<p>At the receiving end, the receiving and unmarshal of data packet is done by RPC runtime and server stub. The data is sent to the required user process for execution. This is point of context switch at the receiving side. Same procedure happens while sending result back to sender for the RPC request. The whole process involves the <code class="myyellow">four context switches.</code> Four context switches is because the interrupt handler receives the incoming packets and delivers to the correct process. It can be reduced to even two context switches if incoming message can be delivered directly to correct process without the intervention of interrupt handler.</p>

<p><code class="myyellow">Binding</code> is the process of knowing the machine names and location which sender machine can connect for RPC operation. It can lead to increase in context switch as it is itself implemented as a separate module. In <code class="myyellow">RPC paper Grapevine</code> is used as a database for binding.  Sending and receiving communication can lead to two additional context switches on the sender side. Same is for the receiver side. 
<br /><br /></p>

<h3 id="lightweight-remote-procedure-call">Lightweight Remote Procedure Call</h3>

<p>This communication model focuses on communication between protection domains on the same machine. In a high level view, LRPC client makes a procedure call to server procedure by kernel trap which leads to a context switch. Kernel processes the request and when the called procedure completes result is returned back to the client from kernel which again leads to the context switch.<br /></p>

<p>Moving to fine granularity of LRPC, during the binding process, client makes import interface request via kernel. Kernel sends the request to server’s waiting clerk and in response waiting clerk sends response to kernel with information. Kernel then return the binding Object to client back and the whole process requires four context switches.<br /></p>

<p>LRPC minimize the use of shared data structures which internally implements its own locks so no explicit lock is required for synchronization. LRPC implements the optimization by reducing the number of context switches by caching domains on idle processors. Kernel looks for the idle processor for the client request and if found one the request is routed to the processor without any context switch. Same is done when returning the result back to client. Kernel looks for any idle client process and uses it without any context switch. If no idle domain can be found then a single processor context switching is done.
<br /><br /></p>

<h3 id="distributed-shared-memory--ivy">Distributed Shared Memory – IVY</h3>

<p>Distributed shared memory is the mode of communication in which a single address space is shared by all the processor. Processor can access any memory location at any time. In this process page size plays an important factor in performance. If the page size is big the two processes are accessing different section of same page, it reduces the performance by generating page fault. <br />
The <code class="myyellow">false sharing</code> increases the context switch.  Context switching and synchronization varies in various methodologies to handle Memory Coherent problem. <br />
<code class="myyellow">Page invalidation</code> approach for Page Synchronization invalidates all the copies of page. Next time when other process requires this page it generates the page fault hence increase the number of context switches. <br />
In <code class="myyellow">write broadcast</code> approach fault handler updates each copy. Next time process don’t generate the page fault because it has an updated copy hence reduces the context switch. In various page ownership approaches like <em>fixed, dynamic with combination of invalidate and write broadcast</em> context switches are required just from passing control from user space to kernel space and vice versa. Then the execution for <em>centralize and distributed</em> approaches can be carried away in kernel mode with different strategies for message passing.</p>

<p><br /><br /></p>

<h3 id="further-reading">Further reading</h3>

<ol>
  <li>Message Passing</li>
  <li>Distributed Shared Memory in <a href="https://www.dropbox.com/s/ukj7np5c78161at/shared%20virtual%20memory%20system.pdf" target="_blank">Ivy</a> (Integrated shared Virtual memory at
Yale) </li>
  <li><a href="https://www.dropbox.com/s/1ktdgouptq41fve/2.ImplementingRPC.pdf" target="_blank">Birrel and Nelson Remote Procedure Call</a></li>
  <li><a href="https://www.dropbox.com/s/7i4kvjg741r5idz/LRPC.pdf" target="_blank">Lightweight Remote Procedure Call</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Process synchronization in OS]]></title>
    <link href="http://distkeys.com/blog/2013/10/07/process-synchronization-in-os/"/>
    <updated>2013-10-07T11:54:00-07:00</updated>
    <id>http://distkeys.com/blog/2013/10/07/process-synchronization-in-os</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#what-is-a-process">What is a Process?</a></li>
  <li><a href="#issues-with-sharing">3 Issues with Sharing</a></li>
  <li><a href="#carls-jr-restaurant">Carl’s Jr. Restaurant</a></li>
  <li><a href="#algorithmic-approach">Algorithmic approach</a></li>
  <li><a href="#software-primitives">Software Primitives</a></li>
  <li><a href="#semaphores">Semaphores</a></li>
  <li><a href="#locks">Locks</a></li>
  <li><a href="#concurrent-programming-construct">Concurrent Programming Construct</a></li>
  <li><a href="#condition-variables">Condition Variables</a></li>
  <li><a href="#producer-consumer-problem">Producer-Consumer Problem</a></li>
  <li><a href="#recommended-reading">Recommended reading</a></li>
</ul>

<h3 id="what-is-a-process">What is a Process?</h3>

<p>Operating system(OS) <code>objective</code> is to keep as many as of the computer resources as busy as possible. It is used to keep track of all the things an OS must remember about the state of user program.</p>

<p>Process is like a box, a complete entity in itself which does a step by step task written in program. More formally it is called <code class="myyellow">program in execution.</code></p>

<p>Lets consider a very basic operating system with very least complexity. This operating system can run only <code>one process</code> at a time. Since, only one process is working at a time, it may happen that all the resources occupied by process will not be used at the same time. 
<!-- more -->
Surround your pullquote like this {" text to be quoted "}</p>

<p>Lets explore the second option, now consider process is like a box and it has resources inside the box. We create multiple <code class="myyellow">child of process which is called thread.</code></p>

<p>Thread is a child of process and hence it will use resources of process. Theoretically, there is no limit on number of child threads a process can have but it seems logical that process should have enough resource for administrative purpose for these threads. </p>

<p>Once there are multiple threads they are going to ask for same resource at the same time. For example, if two children are in one room then they will always fight for same toy. Same applies to threads.</p>

<h3 id="issues-with-sharing">3 Issues with Sharing</h3>
<ol>
  <li>How to <code>Share data</code>?</li>
  <li>How to ensure threads in a process, <code>executes one</code> at a time?</li>
  <li>How to ensure proper <code>sequencing</code> of events?</li>
</ol>

<p>To understand it better, lets take a real world example</p>

<h3 id="carls-jr-restaurant">Carl’s Jr. Restaurant</h3>
<p>Process</p>

<ol>
  <li>Customer arrives</li>
  <li>Employee takes order</li>
  <li>Employee cooks food</li>
  <li>Employee bag food</li>
  <li>Employee takes money</li>
  <li>Customer gets food and leaves</li>
</ol>

<p>If a single employee is doing steps from 1-6 then all other customers have to <code>wait</code> in line and its going to be long wait.
Instead, lets have multiple employees for taking order, cook food, bag food, take money. Each of these ‘employees’ are multiple threads on Process ‘Restaurant’. Each thread is responsible for doing <code>specialized task</code>.</p>

<p>Lets associate <code>3 issues</code> in current situation</p>

<ol>
  <li>What is shared data? - In step 2-3, Quantity of food. In step 3-4, how much food to bag</li>
  <li>Does sequence matters? -  Cook can’t cook food until order arrives. Employee can’t bag food until it is cooked. So, sequencing matters.</li>
</ol>

<p>Shared data can be passed for sharing either using <code>message passing</code> or storing that data in <code>global memory</code> of process and each thread read from that memory location.</p>

<p>The next logical question is how to ensure threads in a process executes one at a time i.e. in <code>exclusion</code>?
More formally there are three types of solution categories</p>

<ol>
  <li>Algorithmic approach</li>
  <li>Software Primitives</li>
  <li>Concurrent programming construct</li>
</ol>

<h3 id="algorithmic-approach">Algorithmic approach</h3>
<p>The algorithmic approach to process synchronization does not use any assistance from the computer architecture or the OS kernel. Instead it uses an arrangement of logical conditions to satisfy the desired synchronization requirements. <a href="http://books.google.com/books/about/Operating_Systems.html?id=kbBn4X9x2mcC" target="_blank">[Dhamdhere]</a></p>

<ul>
  <li>Two process algorithms</li>
  <li><a href="http://en.wikipedia.org/wiki/Dekker's_algorithm" target="_blank">Dekker’s Algorithm</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Peterson's_algorithm" target="_blank">Peterson’s Algorithm</a></li>
  <li>n process algorithm</li>
  <li><a href="http://en.wikipedia.org/wiki/Lamport's_bakery_algorithm" target="_blank">Bakery’s Algorithm</a></li>
</ul>

<h3 id="software-primitives">Software Primitives</h3>
<p>A set of software primitives for mutual exclusion e.g Semaphore, Locks etc. were developed to overcome the logical complexity of algorithmic implementations. This is implemented using some special architectural features of computer systems. But, ease of use and correctness still remained the major obstacle in a development of large concurrent systems.</p>

<h3 id="semaphores">Semaphores</h3>
<p>It is a shared integer variable with <code>non-negative</code> values that have <code>initialization, wait and signal</code> as a indivisible operation.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Semaphore Class </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="keyword">class</span> <span class="class">Semaphore</span> {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="directive">public</span>:
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    <span class="comment">//Constructor</span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    Semaphore(<span class="predefined-type">char</span> *debugName, <span class="predefined-type">int</span> initialValue);&lt;/p&gt;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>&lt;pre&gt;&lt;code&gt;<span class="comment">//Destructor</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>~Semaphore();
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span class="directive">private</span>:
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span class="predefined-type">int</span> value;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>List *waitQueue;
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span class="predefined-type">char</span> *name; }; </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Semaphore Constructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>Semaphore(<span class="predefined-type">char</span> * debugName, <span class="predefined-type">int</span> initialValue) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    name      = debugName;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    value     = initialValue;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    waitQueue = <span class="keyword">new</span> List;
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Semaphore Destructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>~Semaphore() {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span class="keyword">delete</span> waitQueue;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Semaphore Wait </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="comment">//P() - Semaphore Wait</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>Semaphore::P() {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    <span class="comment">//Disable interrupts</span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);&lt;/p&gt;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>&lt;pre&gt;&lt;code&gt;<span class="comment">//Semaphore not available</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="keyword">while</span> (value == <span class="integer">0</span>) {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>waitQueue-&amp;gt;Append((<span class="directive">void</span> *)currentThread);
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>currentThread-&amp;gt;Sleep();
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>}
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span class="comment">//Semaphore now availble</span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>value--;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Semaphore Signal </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="comment">//Semaphore Signal</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>Semaphore::V() {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    Thread *thread;  &lt;/p&gt;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>&lt;pre&gt;&lt;code&gt;IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="comment">//Remove first thread from wait queue</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>thread-&amp;gt;(Thread *)waitQueue-&amp;gt;Remove();
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span class="keyword">if</span> (thread != <span class="predefined-constant">NULL</span>) {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>scheduler-&amp;gt;ReadyToRun(thread);  
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>value++;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<h3 id="locks">Locks</h3>
<p>The basic idea is to <code>close/acquire</code> a lock at the start of critical section or an indivisible operation and <code>open/release</code> it at the end of the critical section or the indivisible operation.</p>

<p>Locks solves how to ensure threads in a process executes one at a time but not the <code>sequencing problem.</code></p>

<p>Lock Class</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Class </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="keyword">class</span> <span class="class">Lock</span> {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="directive">public</span>:
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    Lock (<span class="predefined-type">char</span> *debugName);
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    ~Lock();&lt;/p&gt;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>&lt;pre&gt;&lt;code&gt;<span class="predefined-type">char</span>* getName() { <span class="keyword">return</span> name; }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span class="directive">void</span> acquire();
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span class="directive">void</span> release();
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span class="predefined-type">bool</span> isHeldByCurrentThread;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span class="directive">private</span>:
<span class="line-numbers"><a href="#n14" name="n14">14</a></span><span class="predefined-type">char</span>*   name;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>List*   lockWaitQueue;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span><span class="predefined-type">bool</span>    lockFree;
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>Thread* currentLockThread; }; </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Constructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span class="comment">//Lock Constructor</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>Lock::Lock(<span class="predefined-type">char</span> * debugName) {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    name              = debugName;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    currentLockThread = <span class="predefined-constant">NULL</span>;
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    lockFree          = TRUE;
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    lockWaitQueue     = <span class="keyword">new</span> List;
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Destructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span class="comment">//Lock Destructor</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>~Lock() {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span class="keyword">delete</span> lockWaitQueue;&lt;br /&gt;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Acquire </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>Lock::acquire() {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="comment">//Disable interrupts</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);&lt;/p&gt;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>&lt;pre&gt;&lt;code&gt;<span class="comment">//Check if current thread is an owner</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span><span class="keyword">if</span> (currentThread == currentLockThread) {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="comment">//Already owner  </span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel);
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span class="keyword">return</span>;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>}
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span class="keyword">if</span>(lockFree == TRUE) {
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>lockFree = FALSE;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>currentLockThread = currentThread;      
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>} <span class="keyword">else</span> {
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>lockWaitQueue-&amp;gt;Append((<span class="directive">void</span>*) currentThread);
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>currentThread-&amp;gt;Sleep();
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>}
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Release </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>Lock::release() {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    Thread* waitingThread;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);&lt;/p&gt;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>&lt;pre&gt;&lt;code&gt;<span class="keyword">if</span> (!isHeldByCurrentThread()) {
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span><span class="comment">//Thread is not valid owner of lock its</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="comment">//trying to release</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>DEBUG(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not a lock owner</span><span class="delimiter">&quot;</span></span>);
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel);
<span class="line-numbers"><a href="#n12" name="n12">12</a></span><span class="keyword">return</span>;      
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>waitingThread = (Thread*)lockWaitQueue-&amp;gt;Remove();
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span><span class="keyword">if</span> (waitingThread != <span class="predefined-constant">NULL</span>) {
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>scheduler-&amp;gt;ReadyToRun(waitingThread);
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>currentLockThread = waitingThread;      
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>} <span class="keyword">else</span> {
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>lockFree = TRUE;
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>currentLockThread = <span class="predefined-constant">NULL</span>;
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>}
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>(<span class="directive">void</span>)interrupt-&amp;gt;SetLevel(oldLevel); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Lock Owner </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span class="predefined-type">bool</span> Lock::isHeldByCurrentThread() {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span class="keyword">return</span> ((currentThread != currentLockThread) ?  FALSE : TRUE);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="concurrent-programming-construct">Concurrent Programming Construct</h3>
<p>Locks can only solve <code>mutual exclusion</code> problem, they can not solve <code>sequencing problem</code>. We need another mechanism <code>Monitors</code></p>

<p>Monitors is a programming language construct that supports both data access synchronization and control synchronization.</p>

<p>Monitors have 3 parts</p>

<ol>
  <li><code>Lock</code> for mutual exclusion</li>
  <li>1 or more <code>condition variables</code> for sequencing</li>
  <li>Monitor variables for make sequencing decisions -&gt; Shared data</li>
</ol>

<h3 id="condition-variables">Condition Variables</h3>
<p>Each condition variable is only associated with one lock.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Condition Class </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="keyword">class</span> <span class="class">Condition</span> {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="directive">public</span>:
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    Condition(<span class="predefined-type">char</span> *debugName);
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    ~Conditon();&lt;/p&gt;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>&lt;pre&gt;&lt;code&gt;<span class="predefined-type">char</span>* getName() { <span class="keyword">return</span> name; }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span class="directive">void</span> wait(Lock* conditionLock);
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span class="directive">void</span> signal(Lock* conditionLock);
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span class="directive">void</span> broadcast(Lock* conditionLock);
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span><span class="directive">private</span>:
<span class="line-numbers"><a href="#n14" name="n14">14</a></span><span class="predefined-type">char</span>* name;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>List* cvQueue;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>Lock* cvLock;   }; </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>CV Constructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>Condition::Condition(<span class="predefined-type">char</span> * debugName) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    name    = debugName;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    cvQueue = <span class="keyword">new</span> List;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    cvLock  = <span class="predefined-constant">NULL</span>;&lt;br /&gt;
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>CV Destructor </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>Condition::~Condition() {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span class="keyword">delete</span> cvQueue;  &lt;br /&gt;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>CV Wait </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="directive">void</span> Condition::wait(Lock* conditionLock) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);&lt;/p&gt;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>&lt;pre&gt;&lt;code&gt;<span class="keyword">if</span> (cvQueue-&amp;gt;isEmpty()) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span><span class="comment">//This lock is now associated with CV and</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span><span class="comment">//only removed when last entry is removed</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="comment">//from cvQueue.</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>cvLock = conditionLock;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>}
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span><span class="keyword">if</span> (conditionLock == <span class="predefined-constant">NULL</span>) {
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>interrupt-&amp;gt;SetLevel(oldLevel);  
<span class="line-numbers"><a href="#n14" name="n14">14</a></span><span class="keyword">return</span>;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>}
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>conditionLock-&amp;gt;release();
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>cvQueue-&amp;gt;Append((<span class="directive">void</span>*) currentThread);
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>currentThread-&amp;gt;Sleep();
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span><span class="comment">//Acquire lock when get up</span>
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>conditionLock-&amp;gt;acquire();
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>interrupt-&amp;gt;SetLevel(oldLevel);     } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>CV Signal </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="directive">void</span> Conditon::signal(Lock * conditionLock) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    IntStatus oldLevel = interrupt-&amp;gt;SetLevel(IntOff);&lt;/p&gt;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>&lt;pre&gt;&lt;code&gt;<span class="comment">//If nobody to signal, return</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span><span class="keyword">if</span> (cvQueue-&amp;gt;Empty()) {
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>interrupt-&amp;gt;SetLevel(oldLevel);
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span class="keyword">return</span>;
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span class="comment">//Verify right lock is signalled</span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span><span class="keyword">if</span> (cvLock != conditionLock) {
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>interrupt-&amp;gt;SetLevel(oldLevel);
<span class="line-numbers"><a href="#n14" name="n14">14</a></span><span class="keyword">return</span>;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>}
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>thread = cvQueue-&amp;gt;Remove();
<span class="line-numbers"><a href="#n18" name="n18">18</a></span><span class="keyword">if</span> (thread != <span class="predefined-constant">NULL</span>) {
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>scheduler-&amp;gt;ReadyToRun(thread);
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>}
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>
<span class="line-numbers"><a href="#n22" name="n22">22</a></span><span class="keyword">if</span> (cvQueue-&amp;gt;isEmpty()) {
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>cvLock = <span class="predefined-constant">NULL</span>;
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>}
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>interrupt-&amp;gt;SetLevel(oldLevel); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<h3 id="producer-consumer-problem">Producer-Consumer Problem</h3>

<p>Lets consider we have <code>infinite buffer</code></p>

<p>monitor variable  =&gt; int itemCount = 0;<br />
monitor lock      =&gt; monitorLock;<br />
monitor condition =&gt; needItem;<br /></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Producer </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    monitorLock.acquire();&lt;/p&gt;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>&lt;pre&gt;&lt;code&gt;<span class="comment">//Produce item</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span><span class="comment">//Put in a buffer</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>itemCount++;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>needItem.signal(&amp;amp;monitorLock);
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>monitorLock.Release();     } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>Consumer </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    monitorLock.acquire();&lt;/p&gt;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>&lt;pre&gt;&lt;code&gt;<span class="keyword">while</span>(intemCount == <span class="integer">0</span>) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>needItem.wait(&amp;amp;monitorLock);      
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>}
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span class="comment">//Buffer has atleast one item</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>itemCount--;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>monitorLock.Relase(); } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<h3 id="recommended-reading">Recommended reading</h3>

<ul>
  <li><a href="https://www.dropbox.com/s/8naej9kd0612gkr/implementingcvs.pdf" target="_blank">Implementing CV using semaphore</a></li>
  <li><a href="https://www.dropbox.com/s/gaallrwximrm14g/Monitors.pdf" target="_blank">Monitors by C.A.R Hoare </a></li>
  <li><a href="http://distkeys.com/blog/2013/10/07/process-synchronization-in-linux-kernel/" target="_blank">Process synchronization in Linux Kernel</a></li>
</ul>
]]></content>
  </entry>
  
</feed>

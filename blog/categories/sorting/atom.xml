<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sorting | Learnings]]></title>
  <link href="http://learnwrite.github.io/blog/categories/sorting/atom.xml" rel="self"/>
  <link href="http://learnwrite.github.io/"/>
  <updated>2013-10-12T23:25:25-07:00</updated>
  <id>http://learnwrite.github.io/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sorting]]></title>
    <link href="http://learnwrite.github.io/blog/2013/10/12/sorting/"/>
    <updated>2013-10-12T13:08:00-07:00</updated>
    <id>http://learnwrite.github.io/blog/2013/10/12/sorting</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#sorting-algorithms">Sorting algorithms</a></li>
  <li><a href="#comparisons-based-sorting">Comparisons based sorting</a></li>
  <li><a href="#online-sorts">Online sorts</a></li>
  <li><a href="#stable-sorts">Stable sorts</a></li>
  <li><a href="#time-complexity-chart">Time complexity chart</a></li>
</ul>

<p>This article talks about Sorting, Sorting techniques/algorithms in computer science</p>

<p>Let’s start with Wikipedia entry about sorting</p>

<p><div class="wikipedia">
  
    <img src="//upload.wikimedia.org/wikipedia/commons/thumb/8/82/Sorting_stability_playing_cards.svg/220px-Sorting_stability_playing_cards.svg.png"/>
  
  <h2>sorting algorithm</h2>
  <div>
    <p>A <strong>sorting algorithm</strong> is an <a href="http://en.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a> that puts elements of a <a href="http://en.wikipedia.org/wiki/List_(computing)" title="List (computing)" class="mw-redirect">list</a> in a certain <a href="http://en.wikipedia.org/wiki/Total_order" title="Total order">order</a>. The most-used orders are numerical order and <a href="http://en.wikipedia.org/wiki/Lexicographical_order" title="Lexicographical order">lexicographical order</a>. Efficient <a href="http://en.wikipedia.org/wiki/Sorting" title="Sorting">sorting</a> is important for optimizing the use of other algorithms (such as <a href="http://en.wikipedia.org/wiki/Search_algorithm" title="Search algorithm">search</a> and <a href="http://en.wikipedia.org/wiki/Merge_algorithm" title="Merge algorithm">merge</a> algorithms) which require input data to be in sorted lists; it is also often useful for <a href="http://en.wikipedia.org/wiki/Canonicalization" title="Canonicalization">canonicalizing</a> data and for producing human-readable output. More formally, the output must satisfy two conditions:
</p>
  </div>
  <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">Read more</a>
</div>
</p>

<p><br /></p>

<p>Sorting algorithms can be divided into categories</p>

<h3 id="sorting-algorithms">Sorting algorithms</h3>
<ol>
  <li><strong><em>Comparisons based sorts</em></strong> - 24 algorithms in this category</li>
  <li><strong><em>Online sorts</em></strong>            - 5 algorithms in this category</li>
  <li><strong><em>Stable sorts</em></strong>            - 14 algorithms in this category</li>
</ol>

<p>Donald Knuth pioneer in algorithms and field of Computer Science have divided sorting into</p>

<ol>
  <li><strong><em>Internal sorting</em></strong> - by insertion, by exchange, by selection, by merging, by distribution<br /></li>
  <li><strong><em>Optimum sorting</em></strong>  - min-comparison sorting, min-comparison merging, min-comparison selection<br /></li>
  <li><strong><em>External sorting</em></strong> <br /></li>
</ol>

<h3 id="comparisons-based-sorting">Comparisons based sorting</h3>
<p>It is particular type of sorting algorithm which read the list elements through comparison operator that determines which of two elements should occur first int he final sorted list.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li>Adaptive heap sort</li>
  <li>Bogosort</li>
  <li>Bubble sort</li>
  <li>Cascade merge sort</li>
  <li>Cocktail sort</li>
  <li>Comb sort</li>
  <li>Cycle sort</li>
  <li>Gnome sort</li>
  <li>Heapsort</li>
  <li>Insertion sort</li>
  <li>Introsort</li>
  <li>Library sort</li>
  <li>Merge sort</li>
  <li>Odd–even sort</li>
  <li>Oscillating merge sort</li>
  <li>Patience sorting</li>
  <li>Polyphase merge sort</li>
  <li>Quicksort</li>
  <li>Selection sort</li>
  <li>Shellsort</li>
  <li>Smoothsort</li>
  <li>Stooge sort</li>
  <li>Strand sort</li>
  <li>Timsort</li>
</ul>

<p><br /></p>

<h3 id="online-sorts">Online sorts</h3>

<p>These sorts can start sorting their input without having received all of it. It can process its input piece-by-piece in a serial fashion, i.e., in the order that the input is fed to the algorithm, without having the entire input available from the start.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li>Cycle sort</li>
  <li>Insertion sort</li>
  <li>Library sort</li>
  <li>Merge sort</li>
  <li>Polyphase merge sort</li>
</ul>

<p><br /></p>

<h3 id="stable-sorts">Stable sorts</h3>

<p>A sorting algorithm is stable if whenever there are two records R and S with the <code>same key</code> and with R appearing before S in the original list, <code>R will appear before S</code> in the sorted list.</p>

<p><strong><em>Algorithms</em></strong></p>

<ul>
  <li>Bubble sort</li>
  <li>Bucket sort</li>
  <li>Cascade merge sort</li>
  <li>Cocktail sort</li>
  <li>Counting sort</li>
  <li>Gnome sort</li>
  <li>Insertion sort</li>
  <li>Library sort</li>
  <li>Merge sort</li>
  <li>Odd–even sort</li>
  <li>Oscillating merge sort</li>
  <li>Pigeonhole sort</li>
  <li>Proxmap sort</li>
  <li>Radix sort</li>
</ul>

<h3 id="time-complexity-chart">Time complexity chart</h3>

<table>
<thead>
<tr>
    <th><code class="mygreen">Good</code></th><th><code class="myyellow">Fair</code></th><th><code class="myred">Poor</code></th>
</tr>
</thead>
</table>

<p><br /></p>
<table>
<thead>
<tr>
    <th>Algorithm</th><th colspan="3">Time complexity</th><th>Space complexity</th>
</tr>
<tr>
    <th /><th>Best</th><th>Average</th><th>Worst</th><th />
</tr>
</thead>
<tbody>
<tr>
    <td>Adaptive heap sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Bogosort</td>
    <td><code class="mygreen">Ω(n)</code></td>
    <td>O(n × n!)</td>
    <td><code class="myred">Unbounded</code></td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Bubble sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Cascade merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Cocktail sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Comb sort</td>
    <td>O(n)</td>
    <td>Ω(<math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><mrow><msup><mi>2</mi><mn>p</mn></msup></mrow></mfrac></math>)</td>
    <td>Ω(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Cycle sort</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(n)</td>
</tr>
<tr>
    <td>Gnome sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Heapsort</td>
    <td>Ω(n), O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Insertion sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Introsort</td>
    <td />
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td />
</tr>
<tr>
    <td>Library sort</td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Merge sort</td>
    <td>O(n), O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Odd–even sort</td>
    <td />
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td />
</tr>
<tr>
    <td>Oscillating merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Patience sorting</td>
    <td />
    <td />
    <td>O(nlogn)</td>
    <td />
</tr>
<tr>
    <td>Polyphase merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Quicksort</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Selection sort</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Shellsort</td>
    <td>Depends on gap seq</td>
    <td>Depends on gap seq</td>
    <td>Depends on gap seq</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Smoothsort</td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Stooge sort</td>
    <td />
    <td />
    <td />
    <td>O(n)</td>
</tr>
<tr>
    <td>Strand sort</td>
    <td>O(n)</td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td><code class="myred">O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</code></td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Timsort</td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Online sorting</th>
    <th />
    <th />
    <th />
    <th />
</tr>
<tr>
    <td>Cycle sort</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>Θ(n)</td>
</tr>
<tr>
    <td>Insertion sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Library sort</td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Merge sort</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Polyphase merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Stable sorting</th>
    <th />
    <th />
    <th />
    <th />
</tr>
<tr>
    <td>Bubble sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Bucket sort</td>
    <td />
    <td>O(n + k)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n.k)</td>
</tr>
<tr>
    <td>Cascade merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Cocktail sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Counting sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Gnome sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Insertion sort</td>
    <td>O(n)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Library sort</td>
    <td>O(n)</td>
    <td>O(nlogn)</td>
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Merge sort</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Odd–even sort</td>
    <td />
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td />
</tr>
<tr>
    <td>Oscillating merge sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Pigeonhole sort</td>
    <td />
    <td />
    <td>O(N + n)</td>
    <td>O(N + n)</td>
</tr>
<tr>
    <td>Proxmap sort</td>
    <td>O(n)</td>
    <td />
    <td>O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Radix sort</td>
    <td />
    <td />
    <td>O(kN)</td>
    <td>O(k + N)</td>
</tr>
<tr>
    <td />
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <th>Non-category Sorts</th>
    <th />
    <th />
    <th />
    <th />
</tr>
<tr>
    <td>Adaptive sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>American flag sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Bead sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Burstsort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Cartesian tree</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Comparison sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Dutch national flag problem</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Elevator algorithm</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>External sorting</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Flashsort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Integer sorting</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Internal sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>J sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Median cut</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Ordicate</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Pairwise sorting network</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Pancake sorting</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Partial sorting</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Proxmap sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Quantum sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Samplesort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Sorting network</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Spaghetti sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Spreadsort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Topological sorting</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Tournament sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>Tree sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
<tr>
    <td>UnShuffle sort</td>
    <td />
    <td />
    <td />
    <td />
</tr>
</tbody>
</table>
]]></content>
  </entry>
  
</feed>

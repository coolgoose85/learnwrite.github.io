<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tries | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/tries/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-04T00:07:42-08:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trie and Trees]]></title>
    <link href="http://distkeys.com/blog/2013/11/26/trie-and-trees/"/>
    <updated>2013-11-26T23:18:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/11/26/trie-and-trees</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#trie-problems">Trie Problems</a></li>
  <li><a href="#trie-explanation">Trie explanation</a></li>
  <li><a href="#trie-code">Trie Code</a></li>
  <li><a href="#ifdef-debug">ifdef DEBUG</a></li>
  <li><a href="#ifdef-debug-1">ifdef DEBUG</a>    <ul>
      <li><a href="#infix-to-postfix">Infix to Postfix</a></li>
      <li><a href="#postfix-to-infix">Postfix to Infix</a>        <ul>
          <li><a href="#evaluate-postfix-expression">Evaluate Postfix expression</a></li>
        </ul>
      </li>
      <li><a href="#tree-problems">Tree Problems</a>        <ul>
          <li><a href="#find-bst-is-balanced-or-not">Find BST is balanced or not</a></li>
          <li><a href="#find-binary-tree-is-bst-or-not">Find Binary Tree is BST or not</a></li>
          <li><a href="#bst---recursive-inorder-traversal">BST - Recursive Inorder Traversal</a></li>
          <li><a href="#bst---iterative-inorder-traversal">BST - Iterative Inorder Traversal</a></li>
          <li><a href="#bst---morris-inorder-traversal">BST - Morris Inorder Traversal</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>This article is about Trie and Trees data structure.</p>

<p>{% wikipedia Trie %}</p>

<!-- more -->
<p><br /></p>

<p>Trie is one of the most important data structure for autocomplete.</p>

<h3 id="trie-problems">Trie Problems</h3>

<p>Various problems on Trie can be found <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=usingTries" target="_blnk">here</a></p>

<h3 id="trie-explanation">Trie explanation</h3>

<p>Trie code implementation is based on this <a href="https://www.dropbox.com/s/tg94q18u1t86y23/Trie.pdf" target="_blank">article.</a></p>

<h3 id="trie-code">Trie Code</h3>

<p>{% coderay lang:c linenos:true Trie.h %}
typedef int trieValueT;</p>

<p>typedef struct trieNodeTag {
    char key;
    int words;
    int prefix;
    trieValueT value;
    struct trieNodeTag *next, *children;
} trieNodeT;</p>

<p>typedef struct trieCDT {
    trieNodeT *root;
} trieCDT;</p>

<p>typedef struct trieCDT *trieADT;</p>

<p>// Functions
void trieCreate(trieCDT <em>trie);
void trieAdd(trieNodeT *trie, char *key, int value);
trieNodeT</em> addChild(char key);
int trieIsMember(trieCDT trie, char keys[]);
int totalStringsWithPrefix(trieCDT trie, char keys[]);
void trieDestroy(trieNodeT *root);
void test1();
void startTesting();
void startTestingFromFile(char** stdip_v);
{% endcoderay %}</p>

<p>{% coderay lang:cplusplus linenos:true Trie.c http://ideone.com/AV5jKS Run Trie.c %}
#include <stdio.h>
#include <stdlib.h>
#include "trie.h"</stdlib.h></stdio.h></p>

<p>// To enable debug messages uncomment #define
#define TEST 1
// To test trie by providing input from file, uncomment ‘TESTFROMFILE’
// Compile code and while executing provide file name at command line
// For e.g. &gt; ./a.out ipFile.txt
//
//#define TESTFROMFILE 1
//
// To enable debug messages uncomment ‘DEBUG’
//#define DEBUG 1</p>

<h1 id="ifdef-debug">ifdef DEBUG</h1>
<p>#  define D(x) x
#else
#  define D(x)
#endif</p>

<p>int main(int argc, char* argv[])
{
    #ifdef TEST
        startTesting();
    #endif</p>

<pre><code>#ifdef TESTFROMFILE
    startTestingFromFile(argv);
#endif

return 0; }
</code></pre>

<p>// Create root node of trie
void trieCreate(trieCDT <em>trie)
{
    trie-&gt;root = (trieNodeT</em>)calloc(1,sizeof(trieNodeT));</p>

<pre><code>if (trie-&gt;root == NULL) {
printf("Can not alloc memory\n");
return;
}

trie-&gt;root-&gt;key = '\0';
trie-&gt;root-&gt;value = -1;
trie-&gt;root-&gt;next = NULL;
trie-&gt;root-&gt;children = NULL; }
</code></pre>

<p>// This is recursive function for adding node in trie
// It covers 3 cases
// Case 1: When only root node is present in a trie. In this
//         case keep on adding node one level after another.
//
//         If input given is “Good” and if ‘G’ is not found then
//         insert ‘G’ and return ‘G’ node from where next insertion
//         has to be done as we have already found there is no
//         other ‘G’ exist.
//
// Case 2: When matching key node is already found return the matching
//         node and increment key
//
// Case 3: When key does not match to existing children i.e. for
//         “abcd”, “abef” and “abgh”
//         .  —-&gt; root
//         |
//         a
//         |
//         b
//         |
//         c ===&gt; e ===&gt; g        (LL, children of b)
//         |      |      |
//         d      f      h</p>

<p>void trieAdd(trieNodeT* trie, char *key, int value) {</p>

<pre><code>// Get root of children
if (key == NULL) {
return;
} else if (trie-&gt;children == NULL &amp;&amp; trie-&gt;next == NULL) {

    // Case 1
trieNodeT* child = addChild(*key);
trie-&gt;children = child;

if (*key == '\0') {
    child-&gt;value = value;
    child-&gt;words++;
    return;
}

return trieAdd(child, ++key, value);
}

trieNodeT* level = trie-&gt;children;
trieNodeT* current;
for (current = level; current != NULL; current = current-&gt;next) {

// Case 2
if (current-&gt;key == *key) {
    current-&gt;prefix++;

    if (*key == '\0') {
	current-&gt;words++;
	return;
    }
    return trieAdd(current, ++key, value);
}

// This is last element in LL and key is not found
// For e.g. for "abc" and "abd", c and d should be
// child of b.
// Since, c != d, Append d to c in LL signifying they
// are both child of 'b' and are on same level
//
// Case 3
if (current-&gt;next == NULL) {
    //Add key
    trieNodeT* child = addChild(*key);
    current-&gt;next = child;

    if (*key == '\0') {
        child-&gt;words++;
	child-&gt;value = value;
	return;
    }

    return trieAdd(child, ++key, value);
}
} }
</code></pre>

<p>trieNodeT* addChild(char key)
{
    trieNodeT* child = (trieNodeT*)calloc(1,sizeof(trieNodeT));</p>

<pre><code>if (child == NULL) {
printf("Can not alloc memory\n");
return NULL;
}
child-&gt;key = key;
child-&gt;value = -1;
child-&gt;next = NULL;
child-&gt;children = NULL;
child-&gt;prefix = 1;
child-&gt;words = 0;

return child; }
</code></pre>

<p>int totalStringsWithPrefix(trieCDT trie, char keys[])
{
    trieNodeT *level = trie.root-&gt;children;</p>

<pre><code>while (keys != NULL) {
trieNodeT *found = NULL;
trieNodeT *current;

for (current = level; current != NULL; current = current-&gt;next) {
    if (current-&gt;key == *keys) {
	found = current;
	break;
    }
}

if (found == NULL) {
    return 0;
} else if (*(keys + 1)  == '\0') {
    return found-&gt;prefix;
}
level = found -&gt; children;
keys++;
}

return 0; }
</code></pre>

<p>int trieIsMember(trieCDT trie, char keys[])
{
    trieNodeT *level = trie.root-&gt;children;</p>

<pre><code>while (keys != NULL) {
trieNodeT *found = NULL;
trieNodeT *current;

for (current = level; current != NULL; current = current-&gt;next) {
    if (current-&gt;key == *keys) {
	found = current;
	break;
    }
}

if (found == NULL) {
    return 0;
} else if (*keys == '\0') {
    return 1;
}
level = found -&gt; children;
keys++;
}

return 0; }
</code></pre>

<p>void trieDestroy(trieNodeT * root)
{
    if (root-&gt;children == NULL &amp;&amp; root-&gt;next == NULL) {
        D(printf(“Destroying %d\n”, root-&gt;value));
	free (root);
	return;
    }</p>

<pre><code>// If root have next and children free them first
if (root-&gt;next != NULL) {
trieDestroy(root-&gt;next);
}

if (root-&gt;children != NULL) {
trieDestroy(root-&gt;children);
}
</code></pre>

<h1 id="ifdef-debug-1">ifdef DEBUG</h1>
<pre><code>if (root-&gt;key != '\0') {
printf("Destroying %c\n", root-&gt;key);
} else {
printf("Destroying Root %d\n", root-&gt;value);
} #endif

free (root); }
</code></pre>

<p>void test1()
{
    char s[] = “ABCD”;
    char s1[] = “ABCDE”;
    int i = 0;
    trieCDT trie;
    trieCreate(&amp;trie);
    trieAdd(trie.root, “ABCD”, 20);
    trieAdd(trie.root, “ABCDE”, 30);</p>

<pre><code>if (trieIsMember(trie, s)) {
printf("Found member 'ABCD'\n");
}

i = totalStringsWithPrefix(trie, "ABC");
printf("Total words with prefix 'ABC' %d\n", i);

trieDestroy(trie.root); }
</code></pre>

<p>void startTesting()
{
    test1();
}</p>

<p>void startTestingFromFile(char** stdip_v)
{
    FILE *fp = NULL;
    char key[50];
    trieCDT trie;
    int i = 0;</p>

<pre><code>fp = fopen(stdip_v[1], "r");
if(fp == NULL) {
fprintf(stderr, "Can not read file!!\n");
return;
}

trieCreate(&amp;trie);

while(fscanf(fp, "%s", key) != EOF) {
trieAdd(trie.root, key, i);
i++;

if(!trieIsMember(trie, key)) {
    printf("Key '%s' NOT found in trie\n", key);
}
}

printf("Total words inserted in trie %d\n", i);

i = totalStringsWithPrefix(trie, "Abe");

printf("Total prefixs with 'Abe' %d\n", i);

trieDestroy(trie.root); } {% endcoderay %}
</code></pre>

<p><br /></p>

<h3 id="infix-to-postfix">Infix to Postfix</h3>

<iframe width="420" height="315" src="http://distkeys.com//www.youtube.com/embed/rA0x7b4YiMI" frameborder="0" allowfullscreen=""></iframe>
<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h3 id="postfix-to-infix">Postfix to Infix</h3>

<iframe width="420" height="315" src="http://distkeys.com//www.youtube.com/embed/OlRENYiiIiw" frameborder="0" allowfullscreen=""></iframe>
<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="evaluate-postfix-expression">Evaluate Postfix expression</h4>

<p>Valid operators are +, -, *, /.<br /> Each operand may be an integer or another expression.</p>

<p>Some examples:<br />
<code>
["2", "1", "+", "3", "*"] -&gt; ((2 + 1) * 3) -&gt; 9<br />
["4", "13", "5", "/", "+"] -&gt; (4 + (13 / 5)) -&gt; 6
</code></p>

<p>{% coderay lang:c linenos:true Postfix  %}
class Solution {
    public:
	Solution(){};
	~Solution() {};</p>

<pre><code>int evalRPN(vector&lt;string&gt; &amp;tokens) {
    int num = 0;
    vector&lt;string&gt;::const_iterator cii;

    for(int ii=0; ii &lt; tokens.size(); ii++)
    {
	num = atoi(tokens.at(ii).c_str());
	if (!((tokens[ii] == "+") || (tokens[ii] == "-") ||
		    (tokens[ii] == "*") || (tokens[ii] == "/"))) {
	    mystack.push(num);
	} else {
	    if (mystack.empty()) {
		return 0;
	    }

	    num = mystack.top();
	    mystack.pop();

	    if (mystack.empty()) {
		return 0;
	    }

	    if (tokens[ii] == "+") {
		num += mystack.top();
	    } else if (tokens[ii] == "-") {
		num = mystack.top() - num;
	    } else if (tokens[ii] == "*") {
		num *= mystack.top();
	    } else if (tokens[ii] == "/") {
		if (num == 0)  {
		    return 0;
		}
		num = mystack.top() / num;
	    } else {
		return 0;
	    }

	    mystack.pop();
	    mystack.push(num);
	}
    }

    return mystack.top();
}

std::stack&lt;int&gt; mystack; }; {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h3 id="tree-problems">Tree Problems</h3>

<h4 id="find-bst-is-balanced-or-not">Find BST is balanced or not</h4>

<p>Balanced tree is defined to be a tree such that no two leaf nodes differ in distance from the root by more than one.</p>

<p>{% coderay lang:cplusplus linenos:true Balance BST http://ideone.com/2rEls9 Run %}
#include <stdio.h>
#include <stdlib.h /></stdio.h></p>

<p>int arrLen = 5;
int maxdepth = 0;
int mindepth = 10;
int totalElem = 8;</p>

<p>typedef struct BST {
    int data;
    struct BST *left;
    struct BST *right;
} nodeBST;</p>

<p>void balanceBST(int arr[]);
nodeBST* addNode(int data);
void addNodeToBST(nodeBST *root, nodeBST *node);
void traverse(nodeBST *root);
void maxDepth(nodeBST *root, int depth);
void minDepth(nodeBST *root, int depth);</p>

<p>int maxDepthWithoutGlobalVar(nodeBST *root, int depth, int maxDeep);
int minDepthWithoutGlobalVar(nodeBST *root, int depth, int minDeep);</p>

<p>int main()
{
    int arr[10] = {5,3,7,10,6,12,2,1};</p>

<pre><code>(void)balanceBST(arr);

return 0; }
</code></pre>

<p>void balanceBST(int arr[])
{
    nodeBST *node;
    nodeBST *root;
    int max = 0;
    int min = 100000;</p>

<pre><code>for (int i = 0; i &lt; totalElem; i++) {
node = addNode(arr[i]);
if (node == NULL) {
    return;
}

if (i == 0) {
    root = node;
    continue;
}

addNodeToBST(root, node);
}

printf("Nodes created\n");
traverse(root);
maxDepth(root, 0);
printf("\nMax Depth %d\n", maxdepth);
minDepth(root, 0);
printf("Min Depth %d\n\n", mindepth);

max = maxDepthWithoutGlobalVar(root, 0, max);
printf("Max Depth %d\n", max);

min = minDepthWithoutGlobalVar(root, 0, min);
printf("Min Depth %d\n", min);

if ((max - min) &gt; 1) {
printf("Binary search tree is not Balanced\n");
} else {
printf("Binary search tree is Balanced\n");
} }
</code></pre>

<p>nodeBST* addNode(int data)
{
    nodeBST <em>node = (nodeBST</em>)calloc(1, sizeof(nodeBST));</p>

<pre><code>if (node == NULL) {
return NULL;
}

node-&gt;data = data;
node-&gt;left = NULL;
node-&gt;right = NULL;

return node; }
</code></pre>

<p>void addNodeToBST(nodeBST *root, nodeBST *node)
{
    while(root != NULL) {
	if (node-&gt;data &lt; root-&gt;data) {
	    if (root-&gt;left != NULL) {
		root = root-&gt;left;
	    } else {
		root-&gt;left = node;
		return;
	    }
	} else {
	    if (root-&gt;right != NULL) {
		root = root-&gt;right;
	    } else {
		root-&gt;right = node;
		return;
	    }
	}
    }</p>

<pre><code>return; }
</code></pre>

<p>void traverse(nodeBST *root)
{
    if (root == NULL) {
	return;
    } else {
	traverse(root-&gt;left);
	printf(“%d “, root-&gt;data);
	traverse(root-&gt;right);
    }</p>

<pre><code>return; }
</code></pre>

<p>void maxDepth(nodeBST *root, int depth)
{
    if (root == NULL) {
	if (maxdepth &lt; depth) {
	    maxdepth = depth;
	}
    } else {
	maxDepth(root-&gt;left, (depth + 1));
	maxDepth(root-&gt;right, (depth + 1));
    }
}</p>

<p>void minDepth(nodeBST *root, int depth)
{
    if (root == NULL) {
	if (mindepth &gt; depth) {
	    mindepth = depth;
	}
    } else {
	minDepth(root-&gt;left, (depth + 1));
	minDepth(root-&gt;right, (depth + 1));
    }
}</p>

<p>int maxDepthWithoutGlobalVar(nodeBST *root, int depth, int maxDeep)
{
    if (root == NULL) {
	if (maxDeep &lt;= depth) {
	    maxDeep = depth;
	}
	return maxDeep;
    } else {
        maxDeep = maxDepthWithoutGlobalVar(root-&gt;left, (depth + 1), maxDeep);
	maxDeep = maxDepthWithoutGlobalVar(root-&gt;right, (depth + 1), maxDeep);
    }</p>

<pre><code>return maxDeep; }
</code></pre>

<p>int minDepthWithoutGlobalVar(nodeBST *root, int depth, int minDeep)
{
    if (root == NULL) {
	if (minDeep &gt;= depth) {
	    minDeep = depth;
	}
	return minDeep;
    } else {
        minDeep = minDepthWithoutGlobalVar(root-&gt;left, (depth + 1), minDeep);
	minDeep = minDepthWithoutGlobalVar(root-&gt;right, (depth + 1), minDeep);
    }</p>

<pre><code>return minDeep; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="find-binary-tree-is-bst-or-not">Find Binary Tree is BST or not</h4>

<p>A binary search tree (BST) is a node based binary tree data structure which has the following properties.<br />
• The left subtree of a node contains only nodes with keys less than the node’s key.<br />
• The right subtree of a node contains only nodes with keys greater than the node’s key.<br />
• Both the left and right subtrees must also be binary search trees.<br /><br /></p>

<p><strong>Method 1</strong></p>

<p>Perform inorder traversal on tree and store it in temporary array. By property of inorder traversal the numbers stored should be sorted sequence of it’s a BST else it’s not BST.</p>

<blockquote>
  <p>The only caveat is that this method require O(n) space</p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true Verify BST  %}</p>

<p>int temp[TREESIZE];</p>

<p>void traverse(nodeBST *root)
{
    static int n = 0;</p>

<pre><code>if (root == NULL) {
    return;
} else {
    traverse(root-&gt;left);
    temp[n++] = root-&gt;data;
    traverse1(root-&gt;right);
}

return; }
</code></pre>

<p>for (int i = 0; i &lt; TREESIZE; i++) {
	if (temp[i] &gt; temp [i + 1]) {
		return 0; // Binary tree is not BST
	}	
}
return 1;
{% endcoderay %}</p>

<p><br /><br /></p>

<p><strong>Method 2</strong></p>

<p>{% coderay lang:cplusplus linenos:true Verify BST  %}
int isBSTUtil(nodeBST* node, int min, int max);</p>

<p>/* Returns true if the given tree is a binary search tree 
 (efficient version). <em>/
int isBST(nodeBST</em> node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} </p>

<p>/* Returns true if the given tree is a BST and its 
   values are &gt;= min and &lt;= max. <em>/
int isBSTUtil(nodeBST</em> node, int min, int max) 
{ 
  /* an empty tree is BST */
  if (node==NULL) 
     return 1;</p>

<p>/* false if this node violates the min/max constraint */ 
  if (node-&gt;data &lt; min || node-&gt;data &gt; max) 
     return 0; </p>

<p>/* otherwise check the subtrees recursively, 
   tightening the min or max constraint */
  return
    isBSTUtil(node-&gt;left, min, (node-&gt;data - 1)) &amp;&amp;  // Allow only distinct values
    isBSTUtil(node-&gt;right, (node-&gt;data + 1), max);  // Allow only distinct values
} 
{% endcoderay %}</p>

<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h4 id="bst---recursive-inorder-traversal">BST - Recursive Inorder Traversal</h4>

<blockquote>
  <p>Time complexity O(n) and space complexity is size of stack for function calls</p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true  Recursive Inorder http://ideone.com/Bo2ZpL Run Code%}
 // Recursive inorder traverse
 void traverse(nodeBST *root)
 {
     if (root == NULL) {
         return;
     } else {
         traverse(root-&gt;left);
         printf(“%d “, root-&gt;data);
         traverse(root-&gt;right);
     }</p>

<pre><code> return;  } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h4 id="bst---iterative-inorder-traversal">BST - Iterative Inorder Traversal</h4>

<blockquote>
  <p>Time complexity O(n) and space complexity is size of stack </p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true  Iterative Inorder http://ideone.com/Bo2ZpL Run Code %}
 // Iterative
 // 1) Create an empty stack S.
 // 2) Initialize current node as root
 // 3) Push the current node to S and set current = current-&gt;left until curt is NULL
 // 4) If current is NULL and stack is not empty then$
 //      a) Pop the top item from stack.
 //      b) Print the popped item, set current = current-&gt;right
 //      c) Go to step 3.
 // 5) If current is NULL and stack is empty then we are done.</p>

<p>void iterativeInorder(nodeBST *root)
 {
     createStack();</p>

<pre><code> while(1) {
     if (root != NULL) {
         // Keep pushing in the stack
         push(root);
         root = root-&gt;left;
     } else {
         if (isStackEmpty()) {
             break;
         }
 
         root = pop();
         printf("%d ", root-&gt;data);
 
         root = root-&gt;right;
     }
 }  } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt;&lt;br&gt; &lt;br&gt;
</code></pre>

<h4 id="bst---morris-inorder-traversal">BST - Morris Inorder Traversal</h4>

<p>Morris Inorder Traversal run without using recursion and without extra stack space.</p>

<blockquote>
  <p>Morris Inorder runs in O(NlogN) time and O(1) space</p>
</blockquote>

<p>{% img /assets/morris.png [morris.png] %}</p>

<p>{% coderay lang:cplusplus linenos:true Morris Inorder http://ideone.com/Bo2ZpL Run Code %}
  void MorrisInorder(nodeBST <em>root) {
      nodeBST</em> current,*pre;
      current=root;
      while(current!=NULL) {
          if(current-&gt;left==NULL) {
              printf(“%d “,current-&gt;data);
              current=current-&gt;right;
          }
          else {
              pre=current-&gt;left;
              while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right !=current)
                  pre=pre-&gt;right;
              if(pre-&gt;right==NULL) {
                  printf(“Link %d, %d\n”, pre-&gt;data, current-&gt;data);
                  pre-&gt;right=current;
                  current=current-&gt;left;
              }
              else {
                  pre-&gt;right=NULL;
                  printf(“%d “,current-&gt;data);
                  current=current-&gt;right;
              }
          }
      }
  }
{% endcoderay %}
&lt;hr style="border-top: 1.5px dotted black"/&gt;<br /></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system design | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/system-design/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-11T23:20:17-07:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[System Design Problems]]></title>
    <link href="http://distkeys.com/blog/2014/02/27/system-design-problems/"/>
    <updated>2014-02-27T22:51:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/02/27/system-design-problems</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#unique-user-id">Unique User ID</a></li>
  <li><a href="#mean-and-median">Mean and Median</a></li>
  <li><a href="#how-ls-works">How ls works?</a></li>
  <li><a href="#file-descriptor">File descriptor</a></li>
</ul>

<h3 id="unique-user-id">Unique User ID</h3>

<p>Design a system to generate unique id for 1 billion user in distributed system
<br /><br /></p>

<h3 id="mean-and-median">Mean and Median</h3>

<p>You are given say 20 nodes in a distributed system and each node have 1 billion numbers. Find mean and median. You can have some other nodes for co-ordination.</p>

<p>Mean = (sum of all the numbers) / total numbers<br />
Median = Mid element in sorted sequence</p>

<p>For example<br />
Input = [2, 3, 4, 1]<br /></p>

<p>Mean = (2+3+4+1) / 4 =2.5<br />
For median sorted sequence is [1, 2, 3, 4]. Median is 2 or 3.
<!-- more --></p>

<p><br /><br /></p>

<h3 id="how-ls-works">How ls works?</h3>

<ul>
  <li>Distributed systems people talk about NFS<br /></li>
  <li>Typical low-level systems folks get into the copy-on-write implementation of fork<br /></li>
  <li>Filesystem folks get into finding the blocks that constitute the directory
<br /><br /></li>
</ul>

<h3 id="file-descriptor">File descriptor</h3>

<p>How file descriptor is generated?</p>

<p>Before I start talking about <em>File Descriptor</em> lets first understand the Library functions and System calls.</p>

<blockquote>
  <p>System calls are functions that transfer control from the user process to the
operating system kernel.</p>
</blockquote>

<p>Functions such as <em>read()</em>, <em>write()</em> etc are system calls.</p>

<blockquote>
  <p>Library functions typically provide a richer set of features. Library functions are implemented on top of system calls.</p>
</blockquote>

<p>The first step is the <em>open()</em> system call which either open an existing file or create a new file. 
Multiple parameters can be provided for the requirement. For details of these parameters visit <a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?open+2" target="_blank">here.</a></p>

<p>In C program, we use <em>fopen()</em> rather than <em>open()</em> and this is the difference between Library function and System Call. Library function <em>fopen()</em> will internally call <em>open()</em> and configure parameter based on input provided to <em>fopen()</em></p>

<p>{% coderay lang:cplusplus linenos:false fopen() %}
#include <stdio.h /></p>

<p>int main()
{
   FILE *fp;</p>

<pre><code>//Open file test.txt in read mode    fp = fopen("/tmp/test.txt", "r");    fclose(fp);
</code></pre>

<p>return 0;
}
{% endcoderay%}</p>

<p>Executing this code under <em>dtruss</em></p>

<p>{% blockquote %}
 $ sudo dtruss ./file 2&gt;&amp;1 | grep open
open_nocancel(“/tmp/test.txt\0”, 0x0, 0x1B6)		 = -1 Err#2
open(“/dev/dtracehelper\0”, 0x2, 0x7FFF5CE62180)		 = 3 0
open(“.\0”, 0x0, 0x1)		 = 3 0
open(“/usr/lib/dtrace/libdtrace_dyld.dylib\0”, 0x0, 0x0)		 = 3 0
{% endblockquote %}</p>

<p>Lets deep dive now into the File descriptor. In above C code we created a FILE* which is <em>file pointer or *file descriptor</em> at Library function level. In reality library function <em>fopen()</em> will call system call <em>open()</em> which will get the <em>file descriptor</em> information from filesystem. </p>

<p><em>fopen()</em> library call want to embed the file descriptor information with some additional information. For this purpose a struct is created called FILE and in this structure file descriptor information returned by <em>open()</em> system call is stored with other information.</p>

<blockquote>
  <p>FILE structure fields may vary depending on OS</p>
</blockquote>

<p>In MAC OS its as follows</p>

<p>{% coderay lang:cplusplus linenos:false FILE - stdio.h %}
 /*
  * stdio state variables.
  *
  * The following always hold:
  *
  *        if (_flags&amp;(__SLBF|__SWR)) == (__SLBF|__SWR),
  *                _lbfsize is -_bf._size, else _lbfsize is 0
  *        if _flags&amp;__SRD, _w is 0
  *        if _flags&amp;__SWR, _r is 0
  *
  * This ensures that the getc and putc macros (or inline functions) never
  * try to write or read from a file that is in <code>read' or </code>write’ mode.
  * (Moreover, they can, and do, automatically switch from read mode to
  * write mode, and back, on “r+” and “w+” files.)
  *
  * _lbfsize is used only to make the inline line-buffered output stream
  * code as compact as possible.
  *
  * _ub, _up, and _ur are used when ungetc() pushes back more characters
  * than fit in the current _bf, or when ungetc() pushes back a character
  * that does not match the previous one in _bf.  When this happens,
  * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
  * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
  *
  * NB: see WARNING above before changing the layout of this structure!
  */</p>

<p>typedef struct __sFILE {
         unsigned char <em>_p;        /</em> current position in (some) buffer <em>/
         int     _r;               /</em> read space left for getc() <em>/
         int     _w;               /</em> write space left for putc() <em>/
         short   _flags;           /</em> flags, below; this FILE is free if 0 <em>/
         short   _file;            /</em> fileno, if Unix descriptor, else -1 <em>/
         struct  __sbuf _bf;       /</em> the buffer (at least 1 byte, if !NULL) <em>/
         int     _lbfsize;         /</em> 0 or -_bf._size, for inline putc */</p>

<pre><code>     /* operations */
     void    *_cookie;        /* cookie passed to io functions */
     int     (*_close)(void *);
     int     (*_read) (void *, char *, int);
     fpos_t  (*_seek) (void *, fpos_t, int);
     int     (*_write)(void *, const char *, int);
 
     /* separate buffer for long sequences of ungetc() */
     struct  __sbuf _ub;     /* ungetc buffer */
     struct __sFILEX *_extra; /* additions to FILE to not break ABI */
     int     _ur;            /* saved _r when _r is counting ungetc data */
 
     /* tricks to meet minimum requirements even when malloc() fails */
     unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
     unsigned char _nbuf[1]; /* guarantee a getc() buffer */
 
     /* separate buffer for fgetln() when line crosses buffer boundary */
     struct  __sbuf _lb;     /* buffer for fgetln() */
 
     /* Unix stdio files get aligned to block boundaries on fseek() */
     int     _blksize;        /* stat.st_blksize (may be != _bf._size) */
     fpos_t  _offset;        /* current lseek offset (see WARNING) */  } FILE; {% endcoderay%}
</code></pre>

<p>In above snippet
{% coderay lang:cplusplus linenos:false FILE - stdio.h %}
  <code>// File descriptor from open()</code>
  short   _file;            /* fileno, if Unix descriptor, else -1 */</p>

<p>// The buffer through which the data will pass to system calls.
  struct  __sbuf _bf;       /* the buffer (at least 1 byte, if !NULL) <em>/
  int     _lbfsize;         /</em> 0 or -_bf._size, for inline putc */</p>

<p>unsigned char _ubuf[3]; /* guarantee an ungetc() buffer <em>/
  unsigned char _nbuf[1]; /</em> guarantee a getc() buffer */
{% endcoderay%}</p>

<p>{% img /assets/fopen.png [fopen.png] %}</p>

<p>To be continued…</p>

<p><br /><br /></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system design | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/system-design/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-11T23:42:58-07:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[System Design Problems]]></title>
    <link href="http://distkeys.com/blog/2014/02/27/system-design-problems/"/>
    <updated>2014-02-27T22:51:00-08:00</updated>
    <id>http://distkeys.com/blog/2014/02/27/system-design-problems</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#unique-user-id">Unique User ID</a></li>
  <li><a href="#mean-and-median">Mean and Median</a></li>
  <li><a href="#how-ls-works">How ls works?</a></li>
  <li><a href="#file-descriptor">File descriptor</a></li>
</ul>

<h3 id="unique-user-id">Unique User ID</h3>

<p>Design a system to generate unique id for 1 billion user in distributed system
<br /><br /></p>

<h3 id="mean-and-median">Mean and Median</h3>

<p>You are given say 20 nodes in a distributed system and each node have 1 billion numbers. Find mean and median. You can have some other nodes for co-ordination.</p>

<p>Mean = (sum of all the numbers) / total numbers<br />
Median = Mid element in sorted sequence</p>

<p>For example<br />
Input = [2, 3, 4, 1]<br /></p>

<p>Mean = (2+3+4+1) / 4 =2.5<br />
For median sorted sequence is [1, 2, 3, 4]. Median is 2 or 3.
<!-- more --></p>

<p><br /><br /></p>

<h3 id="how-ls-works">How ls works?</h3>

<ul>
  <li>Distributed systems people talk about NFS<br /></li>
  <li>Typical low-level systems folks get into the copy-on-write implementation of fork<br /></li>
  <li>Filesystem folks get into finding the blocks that constitute the directory
<br /><br /></li>
</ul>

<h3 id="file-descriptor">File descriptor</h3>

<p>How file descriptor is generated?</p>

<p>Before I start talking about <em>File Descriptor</em> lets first understand the Library functions and System calls.</p>

<blockquote>
  <p>System calls are functions that transfer control from the user process to the
operating system kernel.</p>
</blockquote>

<p>Functions such as <em>read()</em>, <em>write()</em> etc are system calls.</p>

<blockquote>
  <p>Library functions typically provide a richer set of features. Library functions are implemented on top of system calls.</p>
</blockquote>

<p>The first step is the <em>open()</em> system call which either open an existing file or create a new file. 
Multiple parameters can be provided for the requirement. For details of these parameters visit <a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?open+2" target="_blank">here.</a></p>

<p>In C program, we use <em>fopen()</em> rather than <em>open()</em> and this is the difference between Library function and System Call. Library function <em>fopen()</em> will internally call <em>open()</em> and configure parameter based on input provided to <em>fopen()</em></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>fopen() </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h /&gt;</span>&lt;/p&gt;

&lt;p&gt;<span class="predefined-type">int</span> main()
{
   FILE *fp;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="comment">//Open file test.txt in read mode    fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);    fclose(fp);</span>
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;<span class="keyword">return</span> <span class="integer">0</span>;
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Executing this code under <em>dtruss</em></p>

<p><blockquote><p>$ sudo dtruss ./file 2&gt;&amp;1 | grep open<br/>open_nocancel(“/tmp/test.txt\0”, 0x0, 0x1B6)		 = -1 Err#2<br/>open(“/dev/dtracehelper\0”, 0x2, 0x7FFF5CE62180)		 = 3 0<br/>open(“.\0”, 0x0, 0x1)		 = 3 0<br/>open(“/usr/lib/dtrace/libdtrace_dyld.dylib\0”, 0x0, 0x0)		 = 3 0</p></blockquote></p>

<p>Lets deep dive now into the File descriptor. In above C code we created a FILE* which is <em>file pointer or *file descriptor</em> at Library function level. In reality library function <em>fopen()</em> will call system call <em>open()</em> which will get the <em>file descriptor</em> information from filesystem. </p>

<p><em>fopen()</em> library call want to embed the file descriptor information with some additional information. For this purpose a struct is created called FILE and in this structure file descriptor information returned by <em>open()</em> system call is stored with other information.</p>

<blockquote>
  <p>FILE structure fields may vary depending on OS</p>
</blockquote>

<p>In MAC OS its as follows</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>FILE - stdio.h </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
 <span class="comment">/*
  * stdio state variables.
  *
  * The following always hold:
  *
  *        if (_flags&amp;amp;(__SLBF|__SWR)) == (__SLBF|__SWR),
  *                _lbfsize is -_bf._size, else _lbfsize is 0
  *        if _flags&amp;amp;__SRD, _w is 0
  *        if _flags&amp;amp;__SWR, _r is 0
  *
  * This ensures that the getc and putc macros (or inline functions) never
  * try to write or read from a file that is in &lt;code&gt;read' or &lt;/code&gt;write’ mode.
  * (Moreover, they can, and do, automatically switch from read mode to
  * write mode, and back, on “r+” and “w+” files.)
  *
  * _lbfsize is used only to make the inline line-buffered output stream
  * code as compact as possible.
  *
  * _ub, _up, and _ur are used when ungetc() pushes back more characters
  * than fit in the current _bf, or when ungetc() pushes back a character
  * that does not match the previous one in _bf.  When this happens,
  * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
  * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
  *
  * NB: see WARNING above before changing the layout of this structure!
  */</span>&lt;/p&gt;

&lt;p&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span> __sFILE {
         <span class="predefined-type">unsigned</span> <span class="predefined-type">char</span> &lt;em&gt;_p;        /&lt;/em&gt; current position in (some) buffer &lt;em&gt;/
         <span class="predefined-type">int</span>     _r;               /&lt;/em&gt; read space left <span class="keyword">for</span> getc() &lt;em&gt;/
         <span class="predefined-type">int</span>     _w;               /&lt;/em&gt; write space left <span class="keyword">for</span> putc() &lt;em&gt;/
         <span class="predefined-type">short</span>   _flags;           /&lt;/em&gt; flags, below; <span class="local-variable">this</span> FILE is free <span class="keyword">if</span> <span class="integer">0</span> &lt;em&gt;/
         <span class="predefined-type">short</span>   _file;            /&lt;/em&gt; fileno, <span class="keyword">if</span> Unix descriptor, <span class="keyword">else</span> -<span class="integer">1</span> &lt;em&gt;/
         <span class="keyword">struct</span>  __sbuf _bf;       /&lt;/em&gt; the buffer (at least <span class="integer">1</span> byte, <span class="keyword">if</span> !<span class="predefined-constant">NULL</span>) &lt;em&gt;/
         <span class="predefined-type">int</span>     _lbfsize;         /&lt;/em&gt; <span class="integer">0</span> <span class="keyword">or</span> -_bf._size, <span class="keyword">for</span> <span class="directive">inline</span> putc */&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     <span class="comment">/* operations */</span>
     <span class="directive">void</span>    *_cookie;        <span class="comment">/* cookie passed to io functions */</span>
     <span class="predefined-type">int</span>     (*_close)(<span class="directive">void</span> *);
     <span class="predefined-type">int</span>     (*_read) (<span class="directive">void</span> *, <span class="predefined-type">char</span> *, <span class="predefined-type">int</span>);
     fpos_t  (*_seek) (<span class="directive">void</span> *, fpos_t, <span class="predefined-type">int</span>);
     <span class="predefined-type">int</span>     (*_write)(<span class="directive">void</span> *, <span class="directive">const</span> <span class="predefined-type">char</span> *, <span class="predefined-type">int</span>);
 
     <span class="comment">/* separate buffer for long sequences of ungetc() */</span>
     <span class="keyword">struct</span>  __sbuf _ub;     <span class="comment">/* ungetc buffer */</span>
     <span class="keyword">struct</span> __sFILEX *_extra; <span class="comment">/* additions to FILE to not break ABI */</span>
     <span class="predefined-type">int</span>     _ur;            <span class="comment">/* saved _r when _r is counting ungetc data */</span>
 
     <span class="comment">/* tricks to meet minimum requirements even when malloc() fails */</span>
     <span class="predefined-type">unsigned</span> <span class="predefined-type">char</span> _ubuf[<span class="integer">3</span>]; <span class="comment">/* guarantee an ungetc() buffer */</span>
     <span class="predefined-type">unsigned</span> <span class="predefined-type">char</span> _nbuf[<span class="integer">1</span>]; <span class="comment">/* guarantee a getc() buffer */</span>
 
     <span class="comment">/* separate buffer for fgetln() when line crosses buffer boundary */</span>
     <span class="keyword">struct</span>  __sbuf _lb;     <span class="comment">/* buffer for fgetln() */</span>
 
     <span class="comment">/* Unix stdio files get aligned to block boundaries on fseek() */</span>
     <span class="predefined-type">int</span>     _blksize;        <span class="comment">/* stat.st_blksize (may be != _bf._size) */</span>
     fpos_t  _offset;        <span class="comment">/* current lseek offset (see WARNING) */</span>  } FILE; </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p>In above snippet
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header'><span>FILE - stdio.h </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
  &lt;code&gt;<span class="comment">// File descriptor from open()&lt;/code&gt;</span>
  <span class="predefined-type">short</span>   _file;            <span class="comment">/* fileno, if Unix descriptor, else -1 */</span>&lt;/p&gt;

&lt;p&gt;<span class="comment">// The buffer through which the data will pass to system calls.</span>
  <span class="keyword">struct</span>  __sbuf _bf;       <span class="comment">/* the buffer (at least 1 byte, if !NULL) &lt;em&gt;/
  int     _lbfsize;         /&lt;/em&gt; 0 or -_bf._size, for inline putc */</span>&lt;/p&gt;

&lt;p&gt;<span class="predefined-type">unsigned</span> <span class="predefined-type">char</span> _ubuf[<span class="integer">3</span>]; <span class="comment">/* guarantee an ungetc() buffer &lt;em&gt;/
  unsigned char _nbuf[1]; /&lt;/em&gt; guarantee a getc() buffer */</span>
</pre></div>
</div>
 </figure></notextile></div></p>

<p><img src="/assets/fopen.png" title="[fopen.png]" ></p>

<p>To be continued…</p>

<p><br /><br /></p>
]]></content>
  </entry>
  
</feed>

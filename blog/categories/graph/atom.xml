<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: graph | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/graph/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-02-19T21:33:35-08:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Graph Algorithms]]></title>
    <link href="http://distkeys.com/blog/2013/12/14/graph-algorithms/"/>
    <updated>2013-12-14T13:03:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/12/14/graph-algorithms</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#graph-problems">Graph problems</a>    <ul>
      <li><a href="#find-neighbour-in-array">Find neighbour in array</a></li>
      <li><a href="#find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</a></li>
    </ul>
  </li>
</ul>

<h3 id="graph-problems">Graph problems</h3>

<h4 id="find-neighbour-in-array">Find neighbour in array</h4>

<p>Find all the neighbours of a given element in array<br /></p>

<p>Neighbours can be defined as<br /></p>

<ol>
  <li>Neighbours are only vertical and horizontal elements next to given element<br /></li>
  <li>Neighbours are only vertical, horizontal and diagonal elements next to given element<br /></li>
  <li>Neighbours are all vertical, horizontal and diagonal elements next to given element<br /></li>
</ol>

<!-- more -->
<p>{% coderay lang:c linenos:true Neighbour1 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: neighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8
 * Neighbour for 1 (0,0) = 4, 2
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void neighbour(int sx, int sy)
{
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
		printf(“%d “, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
	printf("%d ", array[sx - 1][sy]);
}
 
if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
	printf("%d ", array[sx][sy + 1]);
}
 
if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
	printf("%d ", array[sx + 1][sy]);
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour2 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: diagnolNeighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy and
 * diagonal neighbours too.
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8, 1, 3, 7, 9
 * Neighbour for 1 (0,0) = 4, 2, 5
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void diagnolNeighbour(int sx, int sy) {
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
		printf(“%d “, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
	printf("%d ", array[sx - 1][sy]);
 
	//Diagnols
	if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
	    printf("%d ", array[sx - 1][sy - 1]);
	}
	if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
	    printf("%d ", array[sx - 1][sy + 1]);
	}
}
 
if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
	printf("%d ", array[sx][sy + 1]);
}
 
if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
	printf("%d ", array[sx + 1][sy]);
 
	//Diagnols
	if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
	    printf("%d ", array[sx + 1][sy - 1]);
	}
	if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
	    printf("%d ", array[sx + 1][sy + 1]);
	}
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour3 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**
 * Function: allNeighbour(int sx, int sy)
 * This function returns all the neighbour of sx, sy and
 * all diagonal neighbours.
 * For e.g.
 * 1   2   3   4
 * 5   6   7   8
 * 9   10  11  12
 * 13  14  15  16
 *
 * Neighbour for 5  (1,0) = 1, 9, 13, 6, 7, 8, 10, 15
 * Neighbour for 11 (2,2) = 3, 7, 15, 9, 10, 12, 1, 6, 16
 * **</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void allNeighbour(int sx, int sy)
{
    int done = 0;
    int tempX = sx;
    int tempY = sy;
    int i = 0;
    int j = 0;</p>

<pre><code>// Get all the elements in row
for (i = 0; i &lt;= row; i++) {
	if (array[i][sy] == array[sx][sy]) {
	    continue;
	}
	printf("%d ", array[i][sy]);
}
 
// Get all the elements in col
for (j = 0; j &lt;= col; j++) {
	if (array[sx][j] == array[sx][sy]) {
	    continue;
	}
	printf("%d ", array[sx][j]);
}
 
// Diagnols
while (1) {
    tempX--; tempY--;
	if (tempX &gt;= startRow  &amp;&amp; tempY &gt;= startCol) {
	    printf("%d ", array[tempX][tempY]);
	} else {
	    done = 1;
	}
 
	sx++,sy++;
	if (sx &lt;= row &amp;&amp; sy &lt;= col) {
	    printf("%d ", array[sx][sy]);
	} else if (done) {
	    break;
	}
} } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt; &lt;br&gt;&lt;br&gt;
</code></pre>

<h4 id="find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</h4>

<p>Given array as
<br /></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[\begin{array}{cc} 1 & 6 & 8\\ 4 & 7 & 9\\ 5 & 2 & 3
\end{array}\right]
 %]]&gt;</script>

<p>Find all the paths from 1 to 3.
The possible ascending path are</p>

<p><code class="numberCircle">1</code> -&gt;6-&gt;8-&gt;9-&gt; <code class="numberCircle">3</code><br /></p>

<p><code class="numberCircle">1</code> -&gt;4-&gt;7-&gt;9-&gt;<code class="numberCircle">3</code></p>

<p><br />
<code class="numberCircle">1</code> -&gt;6-&gt;7-&gt;2-&gt;<code class="numberCircle">3</code> is not the right solution as 7 &gt; 2</p>

<p><br /><br /></p>

]]></content>
  </entry>
  
</feed>

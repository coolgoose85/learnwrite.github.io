<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-11T23:20:17-07:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trie and Trees]]></title>
    <link href="http://distkeys.com/blog/2013/11/26/trie-and-trees/"/>
    <updated>2013-11-26T23:18:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/11/26/trie-and-trees</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#trie-problems">Trie Problems</a></li>
  <li><a href="#trie-explanation">Trie explanation</a></li>
  <li><a href="#trie-code">Trie Code</a></li>
  <li><a href="#ifdef-debug">ifdef DEBUG</a></li>
  <li><a href="#ifdef-debug-1">ifdef DEBUG</a>    <ul>
      <li><a href="#infix-to-postfix">Infix to Postfix</a></li>
      <li><a href="#postfix-to-infix">Postfix to Infix</a>        <ul>
          <li><a href="#evaluate-postfix-expression">Evaluate Postfix expression</a></li>
        </ul>
      </li>
      <li><a href="#tree-problems">Tree Problems</a>        <ul>
          <li><a href="#find-bst-is-balanced-or-not">Find BST is balanced or not</a></li>
          <li><a href="#find-binary-tree-is-bst-or-not">Find Binary Tree is BST or not</a></li>
          <li><a href="#bst---recursive-inorder-traversal">BST - Recursive Inorder Traversal</a></li>
          <li><a href="#bst---iterative-inorder-traversal">BST - Iterative Inorder Traversal</a></li>
          <li><a href="#bst---morris-inorder-traversal">BST - Morris Inorder Traversal</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>This article is about Trie and Trees data structure.</p>

<p>{% wikipedia Trie %}</p>

<!-- more -->
<p><br /></p>

<p>Trie is one of the most important data structure for autocomplete.</p>

<h3 id="trie-problems">Trie Problems</h3>

<p>Various problems on Trie can be found <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=usingTries" target="_blnk">here</a></p>

<h3 id="trie-explanation">Trie explanation</h3>

<p>Trie code implementation is based on this <a href="https://www.dropbox.com/s/tg94q18u1t86y23/Trie.pdf" target="_blank">article.</a></p>

<h3 id="trie-code">Trie Code</h3>

<p>{% coderay lang:c linenos:true Trie.h %}
typedef int trieValueT;</p>

<p>typedef struct trieNodeTag {
    char key;
    int words;
    int prefix;
    trieValueT value;
    struct trieNodeTag *next, *children;
} trieNodeT;</p>

<p>typedef struct trieCDT {
    trieNodeT *root;
} trieCDT;</p>

<p>typedef struct trieCDT *trieADT;</p>

<p>// Functions
void trieCreate(trieCDT <em>trie);
void trieAdd(trieNodeT *trie, char *key, int value);
trieNodeT</em> addChild(char key);
int trieIsMember(trieCDT trie, char keys[]);
int totalStringsWithPrefix(trieCDT trie, char keys[]);
void trieDestroy(trieNodeT *root);
void test1();
void startTesting();
void startTestingFromFile(char** stdip_v);
{% endcoderay %}</p>

<p>{% coderay lang:cplusplus linenos:true Trie.c http://ideone.com/AV5jKS Run Trie.c %}
#include <stdio.h>
#include <stdlib.h>
#include "trie.h"</stdlib.h></stdio.h></p>

<p>// To enable debug messages uncomment #define
#define TEST 1
// To test trie by providing input from file, uncomment ‘TESTFROMFILE’
// Compile code and while executing provide file name at command line
// For e.g. &gt; ./a.out ipFile.txt
//
//#define TESTFROMFILE 1
//
// To enable debug messages uncomment ‘DEBUG’
//#define DEBUG 1</p>

<h1 id="ifdef-debug">ifdef DEBUG</h1>
<p>#  define D(x) x
#else
#  define D(x)
#endif</p>

<p>int main(int argc, char* argv[])
{
    #ifdef TEST
        startTesting();
    #endif</p>

<pre><code>#ifdef TESTFROMFILE
    startTestingFromFile(argv);
#endif

return 0; }
</code></pre>

<p>// Create root node of trie
void trieCreate(trieCDT <em>trie)
{
    trie-&gt;root = (trieNodeT</em>)calloc(1,sizeof(trieNodeT));</p>

<pre><code>if (trie-&gt;root == NULL) {
printf("Can not alloc memory\n");
return;
}

trie-&gt;root-&gt;key = '\0';
trie-&gt;root-&gt;value = -1;
trie-&gt;root-&gt;next = NULL;
trie-&gt;root-&gt;children = NULL; }
</code></pre>

<p>// This is recursive function for adding node in trie
// It covers 3 cases
// Case 1: When only root node is present in a trie. In this
//         case keep on adding node one level after another.
//
//         If input given is “Good” and if ‘G’ is not found then
//         insert ‘G’ and return ‘G’ node from where next insertion
//         has to be done as we have already found there is no
//         other ‘G’ exist.
//
// Case 2: When matching key node is already found return the matching
//         node and increment key
//
// Case 3: When key does not match to existing children i.e. for
//         “abcd”, “abef” and “abgh”
//         .  —-&gt; root
//         |
//         a
//         |
//         b
//         |
//         c ===&gt; e ===&gt; g        (LL, children of b)
//         |      |      |
//         d      f      h</p>

<p>void trieAdd(trieNodeT* trie, char *key, int value) {</p>

<pre><code>// Get root of children
if (key == NULL) {
return;
} else if (trie-&gt;children == NULL &amp;&amp; trie-&gt;next == NULL) {

    // Case 1
trieNodeT* child = addChild(*key);
trie-&gt;children = child;

if (*key == '\0') {
    child-&gt;value = value;
    child-&gt;words++;
    return;
}

return trieAdd(child, ++key, value);
}

trieNodeT* level = trie-&gt;children;
trieNodeT* current;
for (current = level; current != NULL; current = current-&gt;next) {

// Case 2
if (current-&gt;key == *key) {
    current-&gt;prefix++;

    if (*key == '\0') {
	current-&gt;words++;
	return;
    }
    return trieAdd(current, ++key, value);
}

// This is last element in LL and key is not found
// For e.g. for "abc" and "abd", c and d should be
// child of b.
// Since, c != d, Append d to c in LL signifying they
// are both child of 'b' and are on same level
//
// Case 3
if (current-&gt;next == NULL) {
    //Add key
    trieNodeT* child = addChild(*key);
    current-&gt;next = child;

    if (*key == '\0') {
        child-&gt;words++;
	child-&gt;value = value;
	return;
    }

    return trieAdd(child, ++key, value);
}
} }
</code></pre>

<p>trieNodeT* addChild(char key)
{
    trieNodeT* child = (trieNodeT*)calloc(1,sizeof(trieNodeT));</p>

<pre><code>if (child == NULL) {
printf("Can not alloc memory\n");
return NULL;
}
child-&gt;key = key;
child-&gt;value = -1;
child-&gt;next = NULL;
child-&gt;children = NULL;
child-&gt;prefix = 1;
child-&gt;words = 0;

return child; }
</code></pre>

<p>int totalStringsWithPrefix(trieCDT trie, char keys[])
{
    trieNodeT *level = trie.root-&gt;children;</p>

<pre><code>while (keys != NULL) {
trieNodeT *found = NULL;
trieNodeT *current;

for (current = level; current != NULL; current = current-&gt;next) {
    if (current-&gt;key == *keys) {
	found = current;
	break;
    }
}

if (found == NULL) {
    return 0;
} else if (*(keys + 1)  == '\0') {
    return found-&gt;prefix;
}
level = found -&gt; children;
keys++;
}

return 0; }
</code></pre>

<p>int trieIsMember(trieCDT trie, char keys[])
{
    trieNodeT *level = trie.root-&gt;children;</p>

<pre><code>while (keys != NULL) {
trieNodeT *found = NULL;
trieNodeT *current;

for (current = level; current != NULL; current = current-&gt;next) {
    if (current-&gt;key == *keys) {
	found = current;
	break;
    }
}

if (found == NULL) {
    return 0;
} else if (*keys == '\0') {
    return 1;
}
level = found -&gt; children;
keys++;
}

return 0; }
</code></pre>

<p>void trieDestroy(trieNodeT * root)
{
    if (root-&gt;children == NULL &amp;&amp; root-&gt;next == NULL) {
        D(printf(“Destroying %d\n”, root-&gt;value));
	free (root);
	return;
    }</p>

<pre><code>// If root have next and children free them first
if (root-&gt;next != NULL) {
trieDestroy(root-&gt;next);
}

if (root-&gt;children != NULL) {
trieDestroy(root-&gt;children);
}
</code></pre>

<h1 id="ifdef-debug-1">ifdef DEBUG</h1>
<pre><code>if (root-&gt;key != '\0') {
printf("Destroying %c\n", root-&gt;key);
} else {
printf("Destroying Root %d\n", root-&gt;value);
} #endif

free (root); }
</code></pre>

<p>void test1()
{
    char s[] = “ABCD”;
    char s1[] = “ABCDE”;
    int i = 0;
    trieCDT trie;
    trieCreate(&amp;trie);
    trieAdd(trie.root, “ABCD”, 20);
    trieAdd(trie.root, “ABCDE”, 30);</p>

<pre><code>if (trieIsMember(trie, s)) {
printf("Found member 'ABCD'\n");
}

i = totalStringsWithPrefix(trie, "ABC");
printf("Total words with prefix 'ABC' %d\n", i);

trieDestroy(trie.root); }
</code></pre>

<p>void startTesting()
{
    test1();
}</p>

<p>void startTestingFromFile(char** stdip_v)
{
    FILE *fp = NULL;
    char key[50];
    trieCDT trie;
    int i = 0;</p>

<pre><code>fp = fopen(stdip_v[1], "r");
if(fp == NULL) {
fprintf(stderr, "Can not read file!!\n");
return;
}

trieCreate(&amp;trie);

while(fscanf(fp, "%s", key) != EOF) {
trieAdd(trie.root, key, i);
i++;

if(!trieIsMember(trie, key)) {
    printf("Key '%s' NOT found in trie\n", key);
}
}

printf("Total words inserted in trie %d\n", i);

i = totalStringsWithPrefix(trie, "Abe");

printf("Total prefixs with 'Abe' %d\n", i);

trieDestroy(trie.root); } {% endcoderay %}
</code></pre>

<p><br /></p>

<h3 id="infix-to-postfix">Infix to Postfix</h3>

<iframe width="420" height="315" src="http://distkeys.com//www.youtube.com/embed/rA0x7b4YiMI" frameborder="0" allowfullscreen=""></iframe>
<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h3 id="postfix-to-infix">Postfix to Infix</h3>

<iframe width="420" height="315" src="http://distkeys.com//www.youtube.com/embed/OlRENYiiIiw" frameborder="0" allowfullscreen=""></iframe>
<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="evaluate-postfix-expression">Evaluate Postfix expression</h4>

<p>Valid operators are +, -, *, /.<br /> Each operand may be an integer or another expression.</p>

<p>Some examples:<br />
<code>
["2", "1", "+", "3", "*"] -&gt; ((2 + 1) * 3) -&gt; 9<br />
["4", "13", "5", "/", "+"] -&gt; (4 + (13 / 5)) -&gt; 6
</code></p>

<p>{% coderay lang:c linenos:true Postfix  %}
class Solution {
    public:
	Solution(){};
	~Solution() {};</p>

<pre><code>int evalRPN(vector&lt;string&gt; &amp;tokens) {
    int num = 0;
    vector&lt;string&gt;::const_iterator cii;

    for(int ii=0; ii &lt; tokens.size(); ii++)
    {
	num = atoi(tokens.at(ii).c_str());
	if (!((tokens[ii] == "+") || (tokens[ii] == "-") ||
		    (tokens[ii] == "*") || (tokens[ii] == "/"))) {
	    mystack.push(num);
	} else {
	    if (mystack.empty()) {
		return 0;
	    }

	    num = mystack.top();
	    mystack.pop();

	    if (mystack.empty()) {
		return 0;
	    }

	    if (tokens[ii] == "+") {
		num += mystack.top();
	    } else if (tokens[ii] == "-") {
		num = mystack.top() - num;
	    } else if (tokens[ii] == "*") {
		num *= mystack.top();
	    } else if (tokens[ii] == "/") {
		if (num == 0)  {
		    return 0;
		}
		num = mystack.top() / num;
	    } else {
		return 0;
	    }

	    mystack.pop();
	    mystack.push(num);
	}
    }

    return mystack.top();
}

std::stack&lt;int&gt; mystack; }; {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h3 id="tree-problems">Tree Problems</h3>

<h4 id="find-bst-is-balanced-or-not">Find BST is balanced or not</h4>

<p>Balanced tree is defined to be a tree such that no two leaf nodes differ in distance from the root by more than one.</p>

<p>{% coderay lang:cplusplus linenos:true Balance BST http://ideone.com/2rEls9 Run %}
#include <stdio.h>
#include <stdlib.h /></stdio.h></p>

<p>int arrLen = 5;
int maxdepth = 0;
int mindepth = 10;
int totalElem = 8;</p>

<p>typedef struct BST {
    int data;
    struct BST *left;
    struct BST *right;
} nodeBST;</p>

<p>void balanceBST(int arr[]);
nodeBST* addNode(int data);
void addNodeToBST(nodeBST *root, nodeBST *node);
void traverse(nodeBST *root);
void maxDepth(nodeBST *root, int depth);
void minDepth(nodeBST *root, int depth);</p>

<p>int maxDepthWithoutGlobalVar(nodeBST *root, int depth, int maxDeep);
int minDepthWithoutGlobalVar(nodeBST *root, int depth, int minDeep);</p>

<p>int main()
{
    int arr[10] = {5,3,7,10,6,12,2,1};</p>

<pre><code>(void)balanceBST(arr);

return 0; }
</code></pre>

<p>void balanceBST(int arr[])
{
    nodeBST *node;
    nodeBST *root;
    int max = 0;
    int min = 100000;</p>

<pre><code>for (int i = 0; i &lt; totalElem; i++) {
node = addNode(arr[i]);
if (node == NULL) {
    return;
}

if (i == 0) {
    root = node;
    continue;
}

addNodeToBST(root, node);
}

printf("Nodes created\n");
traverse(root);
maxDepth(root, 0);
printf("\nMax Depth %d\n", maxdepth);
minDepth(root, 0);
printf("Min Depth %d\n\n", mindepth);

max = maxDepthWithoutGlobalVar(root, 0, max);
printf("Max Depth %d\n", max);

min = minDepthWithoutGlobalVar(root, 0, min);
printf("Min Depth %d\n", min);

if ((max - min) &gt; 1) {
printf("Binary search tree is not Balanced\n");
} else {
printf("Binary search tree is Balanced\n");
} }
</code></pre>

<p>nodeBST* addNode(int data)
{
    nodeBST <em>node = (nodeBST</em>)calloc(1, sizeof(nodeBST));</p>

<pre><code>if (node == NULL) {
return NULL;
}

node-&gt;data = data;
node-&gt;left = NULL;
node-&gt;right = NULL;

return node; }
</code></pre>

<p>void addNodeToBST(nodeBST *root, nodeBST *node)
{
    while(root != NULL) {
	if (node-&gt;data &lt; root-&gt;data) {
	    if (root-&gt;left != NULL) {
		root = root-&gt;left;
	    } else {
		root-&gt;left = node;
		return;
	    }
	} else {
	    if (root-&gt;right != NULL) {
		root = root-&gt;right;
	    } else {
		root-&gt;right = node;
		return;
	    }
	}
    }</p>

<pre><code>return; }
</code></pre>

<p>void traverse(nodeBST *root)
{
    if (root == NULL) {
	return;
    } else {
	traverse(root-&gt;left);
	printf(“%d “, root-&gt;data);
	traverse(root-&gt;right);
    }</p>

<pre><code>return; }
</code></pre>

<p>void maxDepth(nodeBST *root, int depth)
{
    if (root == NULL) {
	if (maxdepth &lt; depth) {
	    maxdepth = depth;
	}
    } else {
	maxDepth(root-&gt;left, (depth + 1));
	maxDepth(root-&gt;right, (depth + 1));
    }
}</p>

<p>void minDepth(nodeBST *root, int depth)
{
    if (root == NULL) {
	if (mindepth &gt; depth) {
	    mindepth = depth;
	}
    } else {
	minDepth(root-&gt;left, (depth + 1));
	minDepth(root-&gt;right, (depth + 1));
    }
}</p>

<p>int maxDepthWithoutGlobalVar(nodeBST *root, int depth, int maxDeep)
{
    if (root == NULL) {
	if (maxDeep &lt;= depth) {
	    maxDeep = depth;
	}
	return maxDeep;
    } else {
        maxDeep = maxDepthWithoutGlobalVar(root-&gt;left, (depth + 1), maxDeep);
	maxDeep = maxDepthWithoutGlobalVar(root-&gt;right, (depth + 1), maxDeep);
    }</p>

<pre><code>return maxDeep; }
</code></pre>

<p>int minDepthWithoutGlobalVar(nodeBST *root, int depth, int minDeep)
{
    if (root == NULL) {
	if (minDeep &gt;= depth) {
	    minDeep = depth;
	}
	return minDeep;
    } else {
        minDeep = minDepthWithoutGlobalVar(root-&gt;left, (depth + 1), minDeep);
	minDeep = minDepthWithoutGlobalVar(root-&gt;right, (depth + 1), minDeep);
    }</p>

<pre><code>return minDeep; } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h4 id="find-binary-tree-is-bst-or-not">Find Binary Tree is BST or not</h4>

<p>A binary search tree (BST) is a node based binary tree data structure which has the following properties.<br />
• The left subtree of a node contains only nodes with keys less than the node’s key.<br />
• The right subtree of a node contains only nodes with keys greater than the node’s key.<br />
• Both the left and right subtrees must also be binary search trees.<br /><br /></p>

<p><strong>Method 1</strong></p>

<p>Perform inorder traversal on tree and store it in temporary array. By property of inorder traversal the numbers stored should be sorted sequence of it’s a BST else it’s not BST.</p>

<blockquote>
  <p>The only caveat is that this method require O(n) space</p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true Verify BST  %}</p>

<p>int temp[TREESIZE];</p>

<p>void traverse(nodeBST *root)
{
    static int n = 0;</p>

<pre><code>if (root == NULL) {
    return;
} else {
    traverse(root-&gt;left);
    temp[n++] = root-&gt;data;
    traverse1(root-&gt;right);
}

return; }
</code></pre>

<p>for (int i = 0; i &lt; TREESIZE; i++) {
	if (temp[i] &gt; temp [i + 1]) {
		return 0; // Binary tree is not BST
	}	
}
return 1;
{% endcoderay %}</p>

<p><br /><br /></p>

<p><strong>Method 2</strong></p>

<p>{% coderay lang:cplusplus linenos:true Verify BST  %}
int isBSTUtil(nodeBST* node, int min, int max);</p>

<p>/* Returns true if the given tree is a binary search tree 
 (efficient version). <em>/
int isBST(nodeBST</em> node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} </p>

<p>/* Returns true if the given tree is a BST and its 
   values are &gt;= min and &lt;= max. <em>/
int isBSTUtil(nodeBST</em> node, int min, int max) 
{ 
  /* an empty tree is BST */
  if (node==NULL) 
     return 1;</p>

<p>/* false if this node violates the min/max constraint */ 
  if (node-&gt;data &lt; min || node-&gt;data &gt; max) 
     return 0; </p>

<p>/* otherwise check the subtrees recursively, 
   tightening the min or max constraint */
  return
    isBSTUtil(node-&gt;left, min, (node-&gt;data - 1)) &amp;&amp;  // Allow only distinct values
    isBSTUtil(node-&gt;right, (node-&gt;data + 1), max);  // Allow only distinct values
} 
{% endcoderay %}</p>

<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h4 id="bst---recursive-inorder-traversal">BST - Recursive Inorder Traversal</h4>

<blockquote>
  <p>Time complexity O(n) and space complexity is size of stack for function calls</p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true  Recursive Inorder http://ideone.com/Bo2ZpL Run Code%}
 // Recursive inorder traverse
 void traverse(nodeBST *root)
 {
     if (root == NULL) {
         return;
     } else {
         traverse(root-&gt;left);
         printf(“%d “, root-&gt;data);
         traverse(root-&gt;right);
     }</p>

<pre><code> return;  } {% endcoderay %}
</code></pre>

<hr style="border-top: 1.5px dotted black" />
<p><br />
<br /></p>

<h4 id="bst---iterative-inorder-traversal">BST - Iterative Inorder Traversal</h4>

<blockquote>
  <p>Time complexity O(n) and space complexity is size of stack </p>
</blockquote>

<p>{% coderay lang:cplusplus linenos:true  Iterative Inorder http://ideone.com/Bo2ZpL Run Code %}
 // Iterative
 // 1) Create an empty stack S.
 // 2) Initialize current node as root
 // 3) Push the current node to S and set current = current-&gt;left until curt is NULL
 // 4) If current is NULL and stack is not empty then$
 //      a) Pop the top item from stack.
 //      b) Print the popped item, set current = current-&gt;right
 //      c) Go to step 3.
 // 5) If current is NULL and stack is empty then we are done.</p>

<p>void iterativeInorder(nodeBST *root)
 {
     createStack();</p>

<pre><code> while(1) {
     if (root != NULL) {
         // Keep pushing in the stack
         push(root);
         root = root-&gt;left;
     } else {
         if (isStackEmpty()) {
             break;
         }
 
         root = pop();
         printf("%d ", root-&gt;data);
 
         root = root-&gt;right;
     }
 }  } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt;&lt;br&gt; &lt;br&gt;
</code></pre>

<h4 id="bst---morris-inorder-traversal">BST - Morris Inorder Traversal</h4>

<p>Morris Inorder Traversal run without using recursion and without extra stack space.</p>

<blockquote>
  <p>Morris Inorder runs in O(NlogN) time and O(1) space</p>
</blockquote>

<p>{% img /assets/morris.png [morris.png] %}</p>

<p>{% coderay lang:cplusplus linenos:true Morris Inorder http://ideone.com/Bo2ZpL Run Code %}
  void MorrisInorder(nodeBST <em>root) {
      nodeBST</em> current,*pre;
      current=root;
      while(current!=NULL) {
          if(current-&gt;left==NULL) {
              printf(“%d “,current-&gt;data);
              current=current-&gt;right;
          }
          else {
              pre=current-&gt;left;
              while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right !=current)
                  pre=pre-&gt;right;
              if(pre-&gt;right==NULL) {
                  printf(“Link %d, %d\n”, pre-&gt;data, current-&gt;data);
                  pre-&gt;right=current;
                  current=current-&gt;left;
              }
              else {
                  pre-&gt;right=NULL;
                  printf(“%d “,current-&gt;data);
                  current=current-&gt;right;
              }
          }
      }
  }
{% endcoderay %}
&lt;hr style="border-top: 1.5px dotted black"/&gt;<br /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion]]></title>
    <link href="http://distkeys.com/blog/2013/11/18/recursion/"/>
    <updated>2013-11-18T22:18:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/11/18/recursion</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#recusion-problems">Recusion problems</a>    <ul>
      <li><a href="#factorial">Factorial</a></li>
      <li><a href="#total-bunnyears">Total BunnyEars</a></li>
      <li><a href="#evenodd-bunnyears">Even/Odd BunnyEars</a></li>
      <li><a href="#triangle">Triangle</a></li>
      <li><a href="#sum-of-digits">Sum of Digits</a></li>
      <li><a href="#count-no-7">Count no 7</a></li>
      <li><a href="#count-x-in-string">Count X in String</a></li>
      <li><a href="#count-hi">Count Hi</a></li>
      <li><a href="#change-xy-string">Change XY String</a></li>
      <li><a href="#change-pi">Change PI</a></li>
      <li><a href="#no-x-in-string">No X in String</a></li>
      <li><a href="#no-star-in-string">No Star in String</a></li>
      <li><a href="#substring">Substring</a></li>
      <li><a href="#string-permutation-non-repeating">String permutation non repeating</a></li>
      <li><a href="#power-x-n">Power (x, n)</a></li>
    </ul>
  </li>
</ul>

<p>This article is all about recusion.</p>

<p>{% wikipedia Recursion %}</p>

<!-- more -->
<p><br /></p>

<p>Recursion is basis Dynamic programming, another important area in algorithms.</p>

<p>Best way to learn about recursion is to solve recursion problem.</p>

<p><br /></p>

<h3 id="recusion-problems">Recusion problems</h3>

<h4 id="factorial">Factorial</h4>

<p>Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) … 1
Compute the result recursively (without loops).</p>

<p>factorial(1) → 1<br />
factorial(2) → 2<br />
factorial(3) → 6<br /></p>

<script src="http://ideone.com/e.js/XWZvBI" type="text/javascript"></script>

<p><br /></p>

<h4 id="total-bunnyears">Total BunnyEars</h4>

<p>We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication).</p>

<p>bunnyEars(0) → 0<br />
bunnyEars(1) → 2<br />
bunnyEars(2) → 4<br /></p>

<script src="http://ideone.com/e.js/vrDEiY" type="text/javascript"></script>

<p><br /></p>

<h4 id="evenodd-bunnyears">Even/Odd BunnyEars</h4>

<p>We have bunnies standing in a line, numbered 1, 2, … The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we’ll say have 3 ears, because they each have a raised foot. Recursively return the number of “ears” in the bunny line 1, 2, … n (without loops or multiplication).</p>

<p>bunnyEars2(0) → 0<br />
bunnyEars2(1) → 2<br />
bunnyEars2(2) → 5<br /></p>

<script src="http://ideone.com/e.js/U92tnQ" type="text/javascript"></script>

<p><br /></p>

<h4 id="triangle">Triangle</h4>

<p>We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows. </p>

<p>triangle(0) → 0<br />
triangle(1) → 1<br />
triangle(2) → 3<br /></p>

<script src="http://ideone.com/e.js/3qfqXz" type="text/javascript"></script>

<p><br /></p>

<h4 id="sum-of-digits">Sum of Digits</h4>

<p>Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12).</p>

<p>sumDigits(126) → 9<br />
sumDigits(49) → 13<br />
sumDigits(12) → 3<br /></p>

<script src="http://ideone.com/e.js/AmFVVT" type="text/javascript"></script>

<p><br /></p>

<h4 id="count-no-7">Count no 7</h4>

<p>Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). </p>

<p>count7(717) → 2<br />
count7(7) → 1<br />
count7(123) → 0<br /></p>

<script src="http://ideone.com/e.js/QX5h4w" type="text/javascript"></script>

<p><br /></p>

<h4 id="count-x-in-string">Count X in String</h4>

<p>Given a string, compute recursively (no loops) the number of lowercase ‘x’ chars in the string. </p>

<p>countX(“xxhixx”) → 4 <br />
countX(“xhixhix”) → 3<br />
countX(“hi”) → 0<br /></p>

<script src="http://ideone.com/e.js/DwK19H" type="text/javascript"></script>

<p><br /></p>

<h4 id="count-hi">Count Hi</h4>

<p>Given a string, compute recursively (no loops) the number of times lowercase “hi” appears in the string. </p>

<p>countHi(“xxhixx”) → 1<br />
countHi(“xhixhix”) → 2<br />
countHi(“hi”) → 1<br /></p>

<script src="http://ideone.com/e.js/vGNoFy" type="text/javascript"></script>

<p><br /></p>

<h4 id="change-xy-string">Change XY String</h4>

<p>Given a string, compute recursively (no loops) a new string where all the lowercase ‘x’ chars have been changed to ‘y’ chars.</p>

<p>changeXY(“codex”) → “codey”<br />
changeXY(“xxhixx”) → “yyhiyy”<br />
changeXY(“xhixhix”) → “yhiyhiy”<br /></p>

<p>public String changeXY(String str) {</p>

<p>}</p>

<p><br /></p>

<h4 id="change-pi">Change PI</h4>

<p>Given a string, compute recursively (no loops) a new string where all appearances of “pi” have been replaced by “3.14”. </p>

<p>changePi(“xpix”) → “x3.14x”<br />
changePi(“pipi”) → “3.143.14”<br />
changePi(“pip”) → “3.14p”<br /></p>

<p>public String changePi(String str) {</p>

<p>}
<br /></p>

<h4 id="no-x-in-string">No X in String</h4>

<p>Given a string, compute recursively a new string where all the ‘x’ chars have been removed. </p>

<p>noX(“xaxb”) → “ab” <br />
noX(“abc”) → “abc”<br />
noX(“xx”) → ““<br /></p>

<p>public String noX(String str) {</p>

<p>}
<br /></p>

<h4 id="no-star-in-string">No Star in String</h4>

<p>Given a string, compute recursively a new string where all the adjacent chars are now separated by a “*”. </p>

<p>allStar(“hello”) → “h*e*l*l*o”<br />
allStar(“abc”) → “a*b*c”<br />
allStar(“ab”) → “a*b”<br /></p>

<p>public String allStar(String str) {</p>

<p>}</p>

<p><br /></p>

<h4 id="substring">Substring</h4>

<p>It’s also convenient to have a function that, given a sentence, selects a small portion
of a sentence for us. For example, if we had the sentence:<br />
(russians declare war rington vodka to be excellent)</p>

<p>We could imagine using a hypothetical subsentence function that would let us pull out the first few words
of that sentence, if we tell it where to start and stop the selection:<br />
(subsentence ‘(russians declare war rington vodka to be excellent) 1 3)<br />
(russians declare war)</p>

<p>(subsentence ‘(no shirt no shoes no service) 4 4)<br />
(shoes)<br /></p>

<p>Write the function subsentence, which takes in three arguments: a sentence, the starting endpoint,
and the stopping endpoint. It should return back a sentence that includes the words between the start and
stop endpoints. Assume that the user is nice, and won’t give weird input. In Scheme notation, we mean
that we can assume (&lt;= 1 start stop (count sent)) is always true.</p>

<script src="http://ideone.com/e.js/EsxIJg" type="text/javascript"></script>

<p><br /></p>

<h4 id="string-permutation-non-repeating">String permutation non repeating</h4>

<p>Write all the non repeating permutations of given string i.e.</p>

<p>For string ABC<br />
ABC, ACB, BAC, BCA, CAB, CBA</p>

<p>Detailed solution with explanation can be found <a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/" target="_blank">here</a></p>

<p>{% img left http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/NewPermutation.gif %}</p>

<p><br /></p>

<script src="http://ideone.com/e.js/yvIH1b" type="text/javascript"></script>

<p>This code will output reapeated string if input string given is say ‘ABA’.<br />
To avoid that store all the strings generated in array/hash and compare everytime for uniquesness.
<br /></p>

<h4 id="power-x-n">Power (x, n)</h4>

<p>Write a C program to calculate pow(x, n)</p>

<p>For e.g <br /></p>

<script type="math/tex; mode=display">\begin{align}
  2^4 = 16
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
2^3 = 8
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
       2^{-2} = 0.25
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
       2^{-4} = 0.0625
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
      -2^{-3} = -0.125
\end{align}</script>

<p><strong>Solution</strong>
Idea is that if power is even then multiply evenly i.e. </p>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>2</mi><mn>4</mn></msup></math> will be (2 * 2) * (2 * 2)</p>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>2</mi><mn>3</mn></msup></math> will be 2 * (2  * 2)</p>

<p>{% coderay lang:cplusplus linenos:true Power (x, n) http://ideone.com/BpMEJ8 Run Code %}
#include <stdio.h /></p>

<p>float power(float x, int n)
{
    float temp;
    if( n == 0)
        return 1;
    temp = power(x, n/2);
    if ((n % 2) == 0)
        return temp<em>temp;
    else
    {
        if(n &gt; 0)
            return x</em>temp*temp;
        else
            return (temp * temp) / x;
    }
}</p>

<p>int main()
{
    float res = power(2, 4);
    printf(“Result 2^4 = %f \n”, res);</p>

<pre><code>res = power(2, 3);
printf("Result 2^3 = %f \n", res);

res = power(2, -2);
printf("Result 2^-2 = %f \n", res);

res = power(2, -4);
printf("Result 2^-4 = %f \n", res);

res = power(-2, -3);
printf("Result 2^4 = %f \n", res);

return 0; } {% endcoderay %}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparison based Sorting]]></title>
    <link href="http://distkeys.com/blog/2013/10/13/comparison-based-sorting/"/>
    <updated>2013-10-13T01:43:00-07:00</updated>
    <id>http://distkeys.com/blog/2013/10/13/comparison-based-sorting</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#merge-sort">Merge Sort</a></li>
  <li><a href="#table-based-comparison">Table based comparison</a></li>
  <li><a href="#merge-sort-code">Merge sort code</a></li>
  <li><a href="#define-eoa-100000--end-of-array">define EOA 100000  //End of array</a></li>
  <li><a href="#ifdef-debug">ifdef DEBUG</a>    <ul>
      <li><a href="#quick-sort-code">Quick sort code</a></li>
    </ul>
  </li>
  <li><a href="#ifdef-debug-1">ifdef DEBUG</a>    <ul>
      <li><a href="#references">References</a></li>
    </ul>
  </li>
</ul>

<h3 id="merge-sort">Merge Sort</h3>

<p>Merge sort follows <code>divide-and-conquer</code> approach.</p>

<p><br /><br /><br /><br /></p>

<p>{% coderay lang:c linenos:true Merge-Sort %}
MERGE-SORT(A, p, r) // A is array of numbers
{                   // p is starting index of array
                    // r is last index of array
    if p &lt; r
    then q &lt;- ⌊(p + r)⌋ / 2;<br />
        MERGE-SORT(A, p, q)
        MERGE-SORT(A, q + 1, r)
        MERGE(A, p, q, r)
}
{% endcoderay %}
<!-- more -->
<br /></p>

<p>Merge Sort</p>

<p>{% coderay lang:c linenos:true Merge-Sort %}
MERGE(A, p, q, r)
n1 &lt;- q - p + 1
n2 &lt;- r - q
create arrays L[1…n1 + 1] and R[1… n2 + 1] // It took O(n) space</p>

<p>//Assign elements to new sub arrays
for i &lt;- 1 to n1
    do L[i] &lt;- A[p + i - 1]</p>

<p>for j &lt;- 1 to n2
    do R[j] &lt;- A[q + j]</p>

<p>//Mark end of array
L[n1 + 1] &lt;- ∞
R[n2 + 1] &lt;- ∞
{% endcoderay %}
<br /></p>

<p>Merging two arrays L[] and R[]</p>

<p>{% coderay lang:c linenos:true Merge step %}
i &lt;- 1
j &lt;- 1</p>

<p>for k &lt;- p to r {
    do if L[i] &lt;= R[j]
        then A[k] &lt;- L[i]
            i &lt;- i + 1
        else A[k] &lt;- R[j]
            j &lt;- j + 1
}
{% endcoderay %}
<br /></p>

<p><strong>Analysis</strong></p>

<p>Time complexity</p>

<p>Fully expanded recursion tree has <code>logn + 1</code> levels.<br />
Each level contributes to total cost of <code>cn</code></p>

<p>Total cost = <em>cn logn + cn = O(nlogn)</em> </p>

<h3 id="table-based-comparison">Table based comparison</h3>

<table>
<thead>
<tr>
    <th><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">Merge Sort</a></th><th><a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank">Heap Sort</a></th><th><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank">Quick Sort</a></th>
</tr>
</thead>
<tbody>
<tr>
    <td>Space O(n)</td>
    <td><code class="mygreen">In place</code></td>
    <td><code class="mygreen">In place</code></td>
</tr>
<tr>
    <td>Best:  O(nlogn)<br />Avg:   O(nlogn)<br />Worst: O(nlogn)</td>
    <td>Best:  O(nlogn)<br />Avg:   O(nlogn)<br />Worst: O(nlogn)</td>
    <td>Best:  O(nlogn)<br />Avg:   O(nlogn)<br />Worst: O(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math>)</td>
</tr>
<tr>
    <td>Divide and Conquer</td>
    <td />
    <td>Divide and Conquer</td>
</tr>
<tr>
    <td>Runs better than heapsort<br /> in data cache if its on array</td>
    <td>Runs faster in small data cache</td>
    <td>Works really well in<br /> virtual memory env/Caches</td>
</tr>
<tr>
    <td>Access frequent contiguous<br /> memory locations</td>
    <td>Spread throughout the heap</td>
    <td>Access frequent contiguous<br /> memory locations</td>
</tr>
<tr>
    <td>Stable</td>
    <td>Not Stable</td>
    <td>Not Stable</td>
</tr>
<tr>
    <td>Parallelize well</td>
    <td>Do not Parallelize well</td>
    <td>Parallelize well</td>
</tr>
<tr>
    <td>Used in external sort</td>
    <td>Can not be used in external sort.<br /> <code class="myred">Locality of ref is issue.</code></td>
    <td>Used in external sort</td>
</tr>
</tbody>
</table>

<p><br /></p>

<h3 id="merge-sort-code">Merge sort code</h3>

<p>{% coderay lang:cplusplus linenos:true Merge Sort http://ideone.com/BuLW5z Run Code %}
// Merge Sort example
// For input array
// 2 8 7 1 3 5 6 4 9 0
//
// First partion in L[] and R[] will be
// L[] = 2 8 7 1 3 ==&gt; L[] = 2 8 7 | R[] = 1 3 ==&gt; L[] = 2 8 | R[] = 7
// R[] = 5 6 4 9 0
//
#include <stdio.h /></p>

<h1 id="define-eoa-100000--end-of-array">define EOA 100000  //End of array</h1>

<p>// To enable debug messages uncomment #define
// #define DEBUG 1</p>

<h1 id="ifdef-debug">ifdef DEBUG</h1>
<p>#  define D(x) x
#else
#  define D(x)
#endif</p>

<p>void mergesort(int arr[], int p, int r); 
void merge(int arr[], int p, int q, int r); </p>

<p>int arr[10] = {2, 8, 7, 1, 3, 5, 6, 4, 9, 0}; </p>

<p>int main()
{
    int i = 0;
    printf(“Input array\n”);
    for (i = 0; i &lt;= 9; i++) {
        printf(“%d “, arr[i]);
    } <br />
    printf(“\n\n”);</p>

<pre><code>mergesort(arr, 0, 9); 
 
printf("Sorted output\n");
for (i = 0; i &lt;= 9; i++) {
    printf("%d ", arr[i]);
}   
printf("\n");
 
return 0; }
</code></pre>

<p>void mergesort(int arr[], int p, int r)
{
    if (p &lt; r) {
        int q = (p + r) / 2;</p>

<pre><code>    mergesort(arr, p, q);
    mergesort(arr, q+1, r);
    merge(arr, p, q, r);
} }
</code></pre>

<p>void merge(int arr[], int p, int q, int r)
{
    int n1 = q - p + 1;
    int n2 = r - q;
    int i = 0;
    int j = 0;</p>

<pre><code>int L[15];
int R[15];
 
//Copy elements from p to n1 in L[]
for (i = 0; i &lt; n1; i++) {
    L[i] = arr[p + i];
}
L[i] = EOA;
 
for (j = 0; j &lt; n2; j++) {
    R[j] = arr[q + j + 1];
}
R[j] = EOA;
 
int lindx = 0;
int rindx = 0;
//Merge array L[] and R[]
for (i = p; i &lt;= r; i++) {
    if(L[lindx] &lt;= R[rindx]) {
        arr[i] = L[lindx++];
    } else {
        arr[i] = R[rindx++];
    }
}
 
// Print debug statements
D(printf("\n######################\n"));
D(printf("Left array\n"));
 
for (i = 0; i &lt; n1; i++) {
    D(printf("%d ", L[i]));
}
 
D(printf("\nRight array\n"));
for (i = 0; i &lt; n2; i++) {
    D(printf("%d ", R[i]));
}
 
D(printf("\nAfter Merge\n"));
for (i = p; i &lt;= r; i++) {
    D(printf("%d ", arr[i]));
}
D(printf("\n\n")); } {% endcoderay %}
</code></pre>

<p><br /></p>

<h3 id="quick-sort-code">Quick sort code</h3>
<p><a href="https://www.dropbox.com/s/czbcc6seqfl1eir/Quicksort%20Example.pdf" target="_blank">Quicksort explanation</a></p>

<p>{% coderay lang:cplusplus linenos:true Quick Sort http://ideone.com/qGqmLR Run Code %}
// Quick Sort example
// For input array
// 2 8 7 1 3 5 6 4
//
#include <stdio.h>
#define IPSIZE 8</stdio.h></p>

<p>// To enable debug messages uncomment #define
// #define DEBUG 1</p>

<h1 id="ifdef-debug-1">ifdef DEBUG</h1>
<p>#  define D(x) x
#else
#  define D(x)
#endif</p>

<p>void quicksort(int arr[], int p, int r); 
int partition(int arr[], int p, int r); 
void swap(int i, int j); </p>

<p>int arr[IPSIZE] = {2, 8, 7, 1, 3, 5, 6, 4}; </p>

<p>int main()
{
	int i = 0;
    printf(“Input array\n”);
    for (i = 0; i &lt;= IPSIZE - 1; i++) {
        printf(“%d “, arr[i]);
    } <br />
    printf(“\n\n”);</p>

<pre><code>quicksort(arr, 0, IPSIZE - 1); 
 
printf("Sorted output\n");
for (i = 0; i &lt;= IPSIZE - 1; i++) {
    printf("%d ", arr[i]);
}   
printf("\n");
 
return 0; }
</code></pre>

<p>void quicksort(int arr[], int p, int r)
{
    if (p &lt; r) {
        int pivotIndx = partition(arr, p, r);</p>

<pre><code>    quicksort(arr, p, pivotIndx - 1);
    quicksort(arr, pivotIndx + 1, r);
} }
</code></pre>

<p>int partition(int arr[], int p, int r)
{
    int pivot = arr[r];
    int i = p - 1;
    int j = 0;</p>

<pre><code>// Debug messages
D(printf("\n############\n"));
D(printf("Partition\n"));
D(printf("p=%d, r=%d, pivot=%d\n", p, r, pivot));
D(printf("Elements\n"));
for (j = p; j &lt;= r; j++) {
    D(printf("%d ", arr[j]));
}
D(printf("\n"));
 
for (j = p; j &lt;= r - 1; j++) {
    if (arr[j] &lt;= pivot) {
        i++;
        swap(i, j);
    }
}
 
swap(i + 1, r);
 
D(printf("Elements after partition\n"));
for (j = p; j &lt;= r; j++) {
    D(printf("%d ", arr[j]));
}
D(printf("\n"));
 
return (i + 1); }
</code></pre>

<p>void swap(int i, int j)
{
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
{% endcoderay %}</p>

<p><br /></p>

<h3 id="references">References</h3>
<ul>
  <li>
    <p><a href="https://www.dropbox.com/s/4kcfkbvkwmnmgib/sorting.pdf" target="_blank">Article comparing sorting</a></p>
  </li>
  <li>
    <p><a href="http://distkeys.com/blog/2013/10/12/sorting/" target="_blank">Sorting in detail</a></p>
  </li>
  <li>
    <p><a href="http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Tremblay/L06-QuickSortEX.htm" target="_blank">Median of 3 quicksort</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: interview | Distributed Knowledge]]></title>
  <link href="http://distkeys.com/blog/categories/interview/atom.xml" rel="self"/>
  <link href="http://distkeys.com/"/>
  <updated>2014-03-12T00:16:57-07:00</updated>
  <id>http://distkeys.com/</id>
  <author>
    <name><![CDATA[Vaibhav Gautam]]></name>
    <email><![CDATA[gautam.usc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Graph Algorithms]]></title>
    <link href="http://distkeys.com/blog/2013/12/14/graph-algorithms/"/>
    <updated>2013-12-14T13:03:00-08:00</updated>
    <id>http://distkeys.com/blog/2013/12/14/graph-algorithms</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#graph-problems">Graph problems</a>    <ul>
      <li><a href="#find-neighbour-in-array">Find neighbour in array</a></li>
      <li><a href="#find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</a></li>
    </ul>
  </li>
  <li><a href="#define-xindex-3">define xIndex 3</a></li>
</ul>

<h3 id="graph-problems">Graph problems</h3>

<h4 id="find-neighbour-in-array">Find neighbour in array</h4>

<p>Find all the neighbours of a given element in array<br /></p>

<p>Neighbours can be defined as<br /></p>

<ol>
  <li>Neighbours are only vertical and horizontal elements next to given element<br /></li>
  <li>Neighbours are only vertical, horizontal and diagonal elements next to given element<br /></li>
  <li>Neighbours are all vertical, horizontal and diagonal elements next to given element<br /></li>
</ol>

<!-- more -->
<p>{% coderay lang:c linenos:true Neighbour1 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: neighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8
 * Neighbour for 1 (0,0) = 4, 2
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void neighbour(int sx, int sy)
{
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf(“\n[%d][%d]: %d “, sx, sy - 1, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
            printf("\n[%d][%d]: %d ", sx - 1, sy, array[sx - 1][sy]);
}

if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
            printf("\n[%d][%d]: %d ", sx, sy + 1, array[sx][sy + 1]);
}

if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
            printf("\n[%d][%d]: %d ", sx + 1, sy,array[sx + 1][sy]);
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour2 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
 * Function: diagnolNeighbour(int sx, int sy)
 * This function returns the neighbour of sx, sy and
 * diagonal neighbours too.
 * For e.g.
 * 1 2 3
 * 4 5 6
 * 7 8 9
 *
 * Neighbour for 5 (1,1) = 4, 2, 6, 8, 1, 3, 7, 9
 * Neighbour for 1 (0,0) = 4, 2, 5
 * <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void diagnolNeighbour(int sx, int sy) {
    if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf(“%d “, array[sx][sy - 1]);
    }</p>

<pre><code>if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
            printf("%d ", array[sx - 1][sy]);
 
            //Diagnols
            if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf("%d ", array[sx - 1][sy - 1]);
            }
            if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
                printf("%d ", array[sx - 1][sy + 1]);
            }
}
 
if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
            printf("%d ", array[sx][sy + 1]);
}
 
if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
            printf("%d ", array[sx + 1][sy]);
 
            //Diagnols
            if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
                printf("%d ", array[sx + 1][sy - 1]);
            }
            if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
                printf("%d ", array[sx + 1][sy + 1]);
            }
} } {% endcoderay %}
</code></pre>

<p>{% coderay lang:c linenos:true Neighbour3 http://ideone.com/0ddGnZ Run Code %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**
 * Function: allNeighbour(int sx, int sy)
 * This function returns all the neighbour of sx, sy and
 * all diagonal neighbours.
 * For e.g.
 * 1   2   3   4
 * 5   6   7   8
 * 9   10  11  12
 * 13  14  15  16
 *
 * Neighbour for 5  (1,0) = 1, 9, 13, 6, 7, 8, 10, 15
 * Neighbour for 11 (2,2) = 3, 7, 15, 9, 10, 12, 1, 6, 16
 * **</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
void allNeighbour(int sx, int sy)
{
    int done = 0;
    int tempX = sx;
    int tempY = sy;
    int i = 0;
    int j = 0;</p>

<pre><code>// Get all the elements in row
for (i = 0; i &lt;= row; i++) {
            if (array[i][sy] == array[sx][sy]) {
                continue;
            }
            printf("%d ", array[i][sy]);
}
 
// Get all the elements in col
for (j = 0; j &lt;= col; j++) {
            if (array[sx][j] == array[sx][sy]) {
                continue;
            }
            printf("%d ", array[sx][j]);
}
 
// Diagnols
while (1) {
    tempX--; tempY--;
            if (tempX &gt;= startRow  &amp;&amp; tempY &gt;= startCol) {
                printf("%d ", array[tempX][tempY]);
            } else {
                done = 1;
            }
 
            sx++,sy++;
            if (sx &lt;= row &amp;&amp; sy &lt;= col) {
                printf("%d ", array[sx][sy]);
            } else if (done) {
                break;
            }
} } {% endcoderay %} &lt;hr style="border-top: 1.5px dotted black"/&gt; &lt;br&gt;&lt;br&gt;
</code></pre>

<h4 id="find-all-the-ascending-paths-in-graph">Find all the ascending paths in graph</h4>

<p>Given array as
<br /></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[\begin{array}{cc} 1 & 6 & 8\\ 4 & 7 & 9\\ 5 & 2 & 3
\end{array}\right]
 %]]&gt;</script>

<p>Find all the paths from 1 to 3.
The possible ascending path are</p>

<p><code class="numberCircle">1</code> -&gt;6-&gt;8-&gt;9-&gt; <code class="numberCircle">3</code><br /></p>

<p><code class="numberCircle">1</code> -&gt;4-&gt;7-&gt;9-&gt;<code class="numberCircle">3</code></p>

<p><br />
<code class="numberCircle">1</code> -&gt;6-&gt;7-&gt;2-&gt;<code class="numberCircle">3</code> is not the right solution as 7 &gt; 2</p>

<p>{% coderay lang:c linenos:true Graph Traversal  http://ideone.com/0oLlT1 Run code %}
#include <stdio.h>
#include <stdlib.h /></stdio.h></p>

<h1 id="define-xindex-3">define xIndex 3</h1>
<p>#define yIndex 3
#define TRUE 1
#define FALSE 0</p>

<p>int startIndX = 0;
int startIndY = 0;
int endIndX = 2;
int endIndY = 2;</p>

<p>// Structure to construct final path
typedef struct node {
        int x;
        int y;
        int parentVal;
} parent;</p>

<p>typedef struct queue {
    int x;
    int y;
    struct queue *next;
} qnode;</p>

<p>qnode *head;
qnode *tail;</p>

<p>// Neighbour index coordinates
int neighbourIndex[4][2];
int array[xIndex][yIndex];
int visited[xIndex][yIndex];
int row = xIndex - 1;
int col = yIndex - 1;
int startRow = 0;
int startCol = 0;</p>

<p>parent* parentArr[xIndex][yIndex];</p>

<p>// Function declarations
void neighbour(int sx, int sy);
int isVisited(int x, int y);
void markVisited(int x, int y);
void markUnvisited(int x, int y);
void markParent(int childX, int childY, int parentX, int parentY);
void findPath(int startX, int startY, int endX, int endY);
void enqueue(int x, int y);
qnode* dequeue();
int isQueueEmpty();
void printPath(int x, int y);
void freeQueue();
void test1();</p>

<p>void neighbour(int sx, int sy)
{
    int i = 0;
    int j = 0;</p>

<pre><code>for (i = 0; i &lt; 4; i++) {
    for (j = 0; j &lt; 2; j++) {
        neighbourIndex[i][j] = -1;
    }
}

i = 0; j = 0;

if (sy - 1 &gt;= startCol &amp;&amp; sy - 1 &lt;= col) {
    neighbourIndex[i][0] = sx;
    neighbourIndex[i][1] = sy - 1;
    i++;
}

if (sx - 1 &gt;= startRow &amp;&amp; sx - 1 &lt;= row) {
    neighbourIndex[i][0] = sx - 1;
    neighbourIndex[i][1] = sy;
    i++;
}

if (sy + 1 &gt;= startCol &amp;&amp; sy + 1 &lt;= col) {
    neighbourIndex[i][0] = sx;
    neighbourIndex[i][1] = sy + 1;
    i++;
}

if (sx + 1 &gt;= startRow &amp;&amp; sx + 1 &lt;= row) {
    neighbourIndex[i][0] = sx + 1;
    neighbourIndex[i][1] = sy;
    i++;
} }
</code></pre>

<p>int isVisited(int x, int y)
{
    return visited[x][y];
}</p>

<p>void markVisited(int x, int y)
{
    visited[x][y] = 1;
}</p>

<p>void markUnvisited(int x, int y)
{
    visited[x][y] = 0;
}</p>

<p>void markParent(int childX, int childY, int parentX, int parentY)
{
    parent* temp = (parent *)malloc(sizeof(parent));</p>

<pre><code>if (temp == NULL) {
    // Put ASSERT
}

temp-&gt;x = parentX;
temp-&gt;y = parentY;
temp-&gt;parentVal = array[parentX][parentY];

parentArr[childX][childY] = temp; }
</code></pre>

<p>void enqueue(int x, int y)
{
    qnode *temp = (qnode *)malloc(sizeof(qnode));
    if (temp == NULL) {
    // Put ASSERT
    }</p>

<pre><code>temp-&gt;x = x;
temp-&gt;y = y;
temp-&gt;next = NULL;

tail-&gt;next = temp;

tail = temp; }
</code></pre>

<p>qnode* dequeue()
{
    qnode *temp;</p>

<pre><code>if (!isQueueEmpty()) {
    temp = head-&gt;next;

    if (temp == tail) {
        tail = head;
    }
    head-&gt;next = temp-&gt;next;
    return temp;
}

return head-&gt;next; }
</code></pre>

<p>int isQueueEmpty()
{
    if (head-&gt;next == NULL) {
        return TRUE;
    }</p>

<pre><code>return FALSE; }
</code></pre>

<p>void freeQueue()
{
    qnode* temp;</p>

<pre><code>while (head-&gt;next != NULL) {
    temp = head-&gt;next;
    head-&gt;next = head-&gt;next-&gt;next;

    free (temp);
}
</code></pre>

<p>}</p>

<p>void printPath(int x, int y)
{
    parent *pInfo;</p>

<pre><code>printf("Path:\n");
while (1) {
    printf ("%d ", array[x][y]);

    pInfo = parentArr[x][y];
    x = pInfo-&gt;x;
    y = pInfo-&gt;y;

    if (x == startIndX &amp;&amp; y == startIndY) {
        printf ("%d ", array[x][y]);
        break;
    }
} }
</code></pre>

<p>void findPath(int startX, int startY, int endX, int endY)
{
    int i = 0;
    int j = 0;
    int x = startX;
    int y = startY;
    int neighbourX = startX;
    int neighbourY = startY;
    int reached = FALSE;
    qnode *nextNode;</p>

<pre><code>while (1) {
    neighbour(x, y);

    // Check, are we neighbour of destination?
    for (i = 0; i &lt; 4; i++) {
        if (neighbourIndex[i][0] == endX &amp;&amp; neighbourIndex[i][1] == endY) {
            // Reached destination
            neighbourX = neighbourIndex[i][0];
            neighbourY = neighbourIndex[i][1];
            markParent(neighbourX, neighbourY, x, y);

            reached = TRUE;
            break;
        } else {
            // Validate neighbour
            if (neighbourIndex[i][0] != -1) {
                neighbourX = neighbourIndex[i][0];
                neighbourY = neighbourIndex[i][1];
                if (array[x][y] &lt; array[neighbourX][neighbourY]) {
                    // Mark neighbour index as visited
                    markVisited(x, y);
                    markVisited(neighbourX, neighbourY);

                    // Make me parent of neighbour index
                    markParent(neighbourX, neighbourY, x, y);

                    // Add neighbour to queue
                    enqueue(neighbourX, neighbourY);
                }
            }
        }
    } // end of for

    if (reached) {
        // print path
        printPath(endIndX, endIndY);
        break;
    }

    if (isQueueEmpty()) {
        // If queue is empty then halt, no path found
        printf ("No valid path exist");
        break;
    }

    // Get next item from queue
    nextNode = dequeue();
    if (nextNode != NULL) {
        x = nextNode-&gt;x;
        y = nextNode-&gt;y;

        free (nextNode);
    }
} // end of while }
</code></pre>

<p>void test1()
{
    int i = 0;
    int j = 0;</p>

<pre><code>array[0][0] = 1;
array[0][1] = 6;
array[0][2] = 8;
array[1][0] = 4;
array[1][1] = 7;
array[1][2] = 9;
array[2][0] = 5;
array[2][1] = 2;
array[2][2] = 3;

printf("\n\n");
for (i = 0; i &lt;= row; i++) {
    for (j = 0; j &lt;= col; j++) {
        printf("%d   ", array[i][j]);
    }
    printf("\n");
}

findPath(startIndX, startIndY, endIndX, endIndY);
freeQueue(); }
</code></pre>

<p>int main()
{
    head = (qnode*)malloc(sizeof(qnode));
    head-&gt;x = -1;
    head-&gt;y = -1;
    head-&gt;next = NULL;</p>

<pre><code>tail = head;

test1();

return 0; } {% endcoderay %}
</code></pre>

<p><br /><br /></p>

]]></content>
  </entry>
  
</feed>

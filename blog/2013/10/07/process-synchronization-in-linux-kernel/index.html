
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Process synchronization in Linux Kernel - Learnings</title>
  <meta name="author" content="Vaibhav Gautam">

  
  <meta name="description" content="Synchronization Primitives Summary of Synchronization Primitives Per-CPU variables Atomic Operations As we have discussed earlier about process &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://learnwrite.github.io/blog/2013/10/07/process-synchronization-in-linux-kernel/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
   <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Learnings" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  

</head>

<body   >
  <header role="banner"><hgroup>
</hgroup>

</header>
  <!-- <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:learnwrite.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav> -->
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Process Synchronization in Linux Kernel</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-07T20:56:00-07:00" pubdate data-updated="true">Oct 7<span>th</span>, 2013</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><ul id="markdown-toc">
  <li><a href="#synchronization-primitives">Synchronization Primitives</a></li>
  <li><a href="#summary-of-synchronization-primitives">Summary of Synchronization Primitives</a></li>
  <li><a href="#per-cpu-variables">Per-CPU variables</a></li>
  <li><a href="#atomic-operations">Atomic Operations</a></li>
</ul>

<p>As we have discussed earlier about process synchronization, lets discuss about process synchronization primitives offered in Linux Kernel.</p>

<p>This blog is summary of this <a href="https://docs.google.com/file/d/0BySPJjyZBnC2UVYzWkdSLWNrdEE/edit?usp=sharing" target="_blank">article</a></p>

<h3 id="synchronization-primitives">Synchronization Primitives</h3>

<ol>
  <li>Per-CPU variables</li>
  <li>Atomic Operation</li>
  <li>Memory barrier</li>
  <li>Spin Lock</li>
  <li>Semaphore</li>
  <li>SeqLocks</li>
  <li>Local Interrupt disabling</li>
  <li>Local softirq disabling</li>
  <li>Read-Copy-Update</li>
</ol>

<h3 id="summary-of-synchronization-primitives">Summary of Synchronization Primitives</h3>

<table>
<tr>
<td>Technique</td><td>Description</td><td>Scope</td>
</tr>
<tr>
<td>Per-CPU variables</td><td>Duplicate a data structure among the CPUs</td><td><code>All CPUs</code></td>
</tr>
<tr>
<td>Atomic operation</td><td>Atomic read-modify-write instruction to a counter</td><td><code>All CPUs</code></td>
</tr>
<tr>
<td>Memory barrier</td><td>Avoid instruction reordering</td><td><code>Local CPU or All CPUs</code></td>
</tr>
<tr>
<td>Spin lock</td><td>Lock with busy wait</td><td><code>All CPUs</code></td>
</tr>
<tr>
<td>Semaphore</td><td>Lock with blocking wait (sleep)</td><td><code>All CPUs</code></td>
</tr>
<tr>
<td>Seqlocks</td><td>Lock based on an access counter</td><td><code>All CPUs</code></td>
</tr>
<tr>
<td>Local interrupt disabling</td><td>Forbid interrupt handling on a single CPU</td><td>Local CPU</td>
</tr>
<tr>
<td>Local softirq disabling</td><td>Forbid deferrable function handling on a single CPU</td><td>Local CPU</td>
</tr>
<tr>
<td>Read-copy-update (RCU)</td><td>Lock-free access to shared data structures through pointers</td><td><code>All CPUs</code></td>
</tr>
</table>
<p><br /></p>

<h3 id="per-cpu-variables">Per-CPU variables</h3>

<p>The best synchronization technique consists in designing the kernel so as to avoid
the need for synchronization in the first place.</p>

<p><code>Basically, a per-CPU variable is an array of data structures, one element per each CPU in the system.</code>
A CPU should not access the elements of the array corresponding to the other CPUs.</p>

<p><code>Pros</code></p>

<ul>
  <li>Freely read and modify its own element without fear of race conditions.<br /></li>
  <li>It avoids cache line snooping and invalidations, which are costly operations.</li>
</ul>

<p><strong>[Snooping and Invalidations]</strong> Snooping is the process where the individual caches monitor address lines,  for accesses to memory locations that they have cached. When a write operation is observed to a location that a cache has a copy of, the cache controller invalidates its own copy of the snooped memory location.</p>

<p><code>Cons</code>
* It can only be used when it make sense to <code>logically split</code> the data across the CPUs of the system
* Do not provide <code>protection</code> against access from asynchronous functions such as <code>interrupt handlers and deferrable functions.</code>
* Per-CPU variables are variables are prone to <code>race conditions</code> caused by kernel preemption, both in uniprocessor and multiprocessor systems.</p>

<p><strong>[Problem]</strong> What would happen if a kernel control path gets the address of its local copy of a per-CPU variable, and then it is preempted and moved to another CPU: the address still refers to the element of the previous CPU.</p>

<p>As a general rule, a kernel control path should access a per-CPU variable with kernel preemption disabled.</p>

<hr style="border-top: 1.5px dotted black" />
<p><br /></p>

<h3 id="atomic-operations">Atomic Operations</h3>

<p><strong>[Problem]</strong> Several assembly language instructions are of type “read-modify-write” i.e. memory location is accessed twice first to read the old value and second time to write a new value</p>

<p><strong>Detailed explanation</strong><br />
Suppose that two kernel control paths running on two CPUs try to “read-modify-write” the same memory location at the same time by executing nonatomic operations.<br />
At first, <code>both CPUs try to read the same location</code>, but the memory arbiter (a hardware circuit that serializes accesses to the RAM chips) steps in to grant access to one of them and delay the other. However, when the first read operation has completed, the delayed CPU reads exactly the same (old) value from the memory location.
<code>Both CPUs then try to write the same (new) value to the memory location</code>; again, the bus memory access is serialized by the memory arbiter, and eventually both write operations succeed. However, the global result is incorrect because both CPUs write the same (new) value. Thus, the two interleaving “read-modify-write” operations act as a single one.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Vaibhav Gautam</span></span>

      








  


<time datetime="2013-10-07T20:56:00-07:00" pubdate data-updated="true">Oct 7<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/kernel/'>kernel</a>, <a class='category' href='/blog/categories/linux/'>linux</a>, <a class='category' href='/blog/categories/operating-systems/'>operating systems</a>, <a class='category' href='/blog/categories/os/'>os</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://learnwrite.github.io/blog/2013/10/07/process-synchronization-in-linux-kernel/" data-via="_vaibhavg" data-counturl="http://learnwrite.github.io/blog/2013/10/07/process-synchronization-in-linux-kernel/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/10/07/process-synchronization-in-os/" title="Previous Post: Process synchronization in OS">&laquo; Process synchronization in OS</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <ul id="recent_posts">
      <li class="post">
      <a href="http://learnwrite.github.io" alt="Home"><img src="/images/Home.png"></a>
      <a href="http://learnwrite.github.io/archives/" alt="Archives"><img src="/images/Calendar.png"></a>
      
      </li>
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p><img src="/images/linked-in.png"><a href="http://www.linkedin.com/pub/vaibhav-gautam/11/663/163">Vaibhav Gautam</a></p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/07/process-synchronization-in-linux-kernel/">Process synchronization in Linux Kernel</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/07/process-synchronization-in-os/">Process synchronization in OS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/06/gdb-print-bit-values-of-bytes/">GDB - Print Bit values of bytes</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/learnwrite">@learnwrite</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'learnwrite',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>Twitter</h1>
<a class="twitter-timeline" href="https://twitter.com/_vaibhavg" data-widget-id="386954016019587072">Tweets by @_vaibhavg</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - <a href="http://www.linkedin.com/pub/vaibhav-gautam/11/663/163">Vaibhav Gautam</a> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'coolgoose85';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://learnwrite.github.io/blog/2013/10/07/process-synchronization-in-linux-kernel/';
        var disqus_url = 'http://learnwrite.github.io/blog/2013/10/07/process-synchronization-in-linux-kernel/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
